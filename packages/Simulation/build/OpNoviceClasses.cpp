// Generated at Thu May 21 12:13:33 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/usr/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/usr/bin/c++"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic "
  GCCXML_EXECUTABLE="/usr/bin/gccxml_cc1plus"
  GCCXML_CPP="/usr/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__FLT_MIN__='1.17549435e-38F' -D__CHAR_BIT__='8' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='4.9406564584124654e-324' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__LP64__='1' -D__GNUC_PATCHLEVEL__='7' -D__DEC64_MAX_EXP__='385' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__unix='1' -D__LDBL_MAX_EXP__='16384' -D__linux__='1' -D__SCHAR_MAX__='127' -D__DBL_DIG__='15' -D_FORTIFY_SOURCE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209290e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__SIZEOF_LONG__='8' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='1.7976931348623157e+308' -D__DBL_HAS_INFINITY__='1' -D__DEC32_MIN_EXP__='(-94)' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__DBL_MIN__='2.2250738585072014e-308' -D__FLT_MIN_10_EXP__='(-37)' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__DBL_HAS_DENORM__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.4.7 20120313 (Red Hat 4.4.7-11)"' -D__DEC64_EPSILON__='1E-15DD' -D__DEC128_MIN_EXP__='(-6142)' -Dunix='1' -D__SIZE_TYPE__='long unsigned int' -D__ELF__='1' -D__FLT_RADIX__='2' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__GNUC_RH_RELEASE__='11' -D__k8='1' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__DEC64_MANT_DIG__='16' -D__DEC32_MAX_EXP__='97' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__k8__='1' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__DEC64_MIN_EXP__='(-382)' -D__FLT_DIG__='6' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__FLT_MAX_EXP__='128' -D__DBL_MANT_DIG__='53' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__SSP__='1' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='2.2204460492503131e-16' -D_LP64='1' -D__SIZEOF_WCHAR_T__='4' -D__DEC_EVAL_METHOD__='2' -D__INTMAX_MAX__='9223372036854775807L' -D__FLT_DENORM_MIN__='1.40129846e-45F' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282347e+38F' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='4' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__GNUC_GNU_INLINE__='1' -D_GNU_SOURCE='1' -iwrapper"/usr/share/gccxml-0.9/GCC/4.4" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/backward" -isystem"/usr/local/include" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/usr/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.4.7 20120313 (Red Hat 4.4.7-11)
Copyright (C) 2010 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/project/Gruppo3/fiber5/celentano/OptoTracker/packages/Simulation/include/OpNoviceClasses.hh"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("CLHEP") );
  ::Reflex::Type type_45 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_59 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_136 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_980 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_325 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_391 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_1760 = ::Reflex::TypeBuilder(Reflex::Literal("G4VHit"));
  ::Reflex::Type type_1035 = ::Reflex::TypeBuilder(Reflex::Literal("G4VDigi"));
  ::Reflex::Type type_2224 = ::Reflex::TypeBuilder(Reflex::Literal("G4String"));
  ::Reflex::Type type_487 = ::Reflex::TypeBuilder(Reflex::Literal("OpNoviceDigi"));
  ::Reflex::Type type_82 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_1751 = ::Reflex::TypeBuilder(Reflex::Literal("G4SubString"));
  ::Reflex::Type type_147 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_1659 = ::Reflex::TypeBuilder(Reflex::Literal("OpNovicePMTHit"));
  ::Reflex::Type type_1351 = ::Reflex::TypeBuilder(Reflex::Literal("G4VPhysicalVolume"));
  ::Reflex::Type type_1016 = ::Reflex::TypeBuilder(Reflex::Literal("CLHEP::Hep3Vector"));
  ::Reflex::Type type_2138 = ::Reflex::TypeBuilder(Reflex::Literal("CLHEP::HepRotation"));
  ::Reflex::Type type_2851 = ::Reflex::TypeBuilder(Reflex::Literal("CLHEP::HepAxisAngle"));
  ::Reflex::Type type_2362 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_2494 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<char>"));
  ::Reflex::Type type_4651 = ::Reflex::TypeBuilder(Reflex::Literal("CLHEP::HepEulerAngles"));
  ::Reflex::Type type_2486 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<double>"));
  ::Reflex::Type type_2544 = ::Reflex::TypeBuilder(Reflex::Literal("std::char_traits<char>"));
  ::Reflex::Type type_2365 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<G4AttValue>"));
  ::Reflex::Type type_2384 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_5346 = ::Reflex::EnumTypeBuilder(Reflex::Literal("G4String::caseCompare"));
  ::Reflex::Type type_2363 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<OpNoviceDigi*>"));
  ::Reflex::Type type_2569 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<G4String,G4AttDef>"));
  ::Reflex::Type type_2364 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<OpNovicePMTHit*>"));
  ::Reflex::Type type_2487 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<OpNoviceDigi*>"));
  ::Reflex::Type type_2488 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<OpNovicePMTHit*>"));
  ::Reflex::Type type_6558 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>::_Alloc_hider"));
  ::Reflex::Type type_206 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_istream<char,std::char_traits<char> >"));
  ::Reflex::Type type_2686 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<double,std::allocator<double> >"));
  ::Reflex::Type type_3303 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<double*,std::vector<double> >"));
  ::Reflex::Type type_3315 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >"));
  ::Reflex::Type type_2684 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<OpNoviceDigi*,std::allocator<OpNoviceDigi*> >"));
  ::Reflex::Type type_3304 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const double*,std::vector<double> >"));
  ::Reflex::Type type_3318 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >"));
  ::Reflex::Type type_2685 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<OpNovicePMTHit*,std::allocator<OpNovicePMTHit*> >"));
  ::Reflex::Type type_3299 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >"));
  ::Reflex::Type type_3301 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >"));
  ::Reflex::Type type_3300 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<OpNoviceDigi* const*,std::vector<OpNoviceDigi*> >"));
  ::Reflex::Type type_2590 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<double*,std::vector<double> > >"));
  ::Reflex::Type type_3302 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<OpNovicePMTHit* const*,std::vector<OpNovicePMTHit*> >"));
  ::Reflex::Type type_2608 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,std::basic_string<char> > >"));
  ::Reflex::Type type_2589 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const double*,std::vector<double> > >"));
  ::Reflex::Type type_2607 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> > >"));
  ::Reflex::Type type_2586 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> > >"));
  ::Reflex::Type type_2588 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> > >"));
  ::Reflex::Type type_2585 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<OpNoviceDigi* const*,std::vector<OpNoviceDigi*> > >"));
  ::Reflex::Type type_2587 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<OpNovicePMTHit* const*,std::vector<OpNovicePMTHit*> > >"));
  ::Reflex::Type type_231 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("G4int"), type_45);
  ::Reflex::Type type_1847 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("G4double"), type_391);
  ::Reflex::Type type_5845 = ::Reflex::PointerBuilder(type_1351);
  ::Reflex::Type type_487c = ::Reflex::ConstBuilder(type_487);
  ::Reflex::Type type_5215 = ::Reflex::ReferenceBuilder(type_487c);
  ::Reflex::Type type_613 = ::Reflex::PointerBuilder(type_136);
  ::Reflex::Type type_1441 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_82);
  ::Reflex::Type type_1016c = ::Reflex::ConstBuilder(type_1016);
  ::Reflex::Type type_9830 = ::Reflex::ReferenceBuilder(type_1016c);
  ::Reflex::Type type_5949 = ::Reflex::ReferenceBuilder(type_391);
  ::Reflex::Type type_9831 = ::Reflex::ReferenceBuilder(type_1016);
  ::Reflex::Type type_2138c = ::Reflex::ConstBuilder(type_2138);
  ::Reflex::Type type_9832 = ::Reflex::ReferenceBuilder(type_2138c);
  ::Reflex::Type type_2851c = ::Reflex::ConstBuilder(type_2851);
  ::Reflex::Type type_9833 = ::Reflex::ReferenceBuilder(type_2851c);
  ::Reflex::Type type_4651c = ::Reflex::ConstBuilder(type_4651);
  ::Reflex::Type type_9834 = ::Reflex::ReferenceBuilder(type_4651c);
  ::Reflex::Type type_9837 = ::Reflex::ReferenceBuilder(type_1035);
  ::Reflex::Type type_1035c = ::Reflex::ConstBuilder(type_1035);
  ::Reflex::Type type_9838 = ::Reflex::ReferenceBuilder(type_1035c);
  ::Reflex::Type type_2569c = ::Reflex::ConstBuilder(type_2569);
  ::Reflex::Type type_9839 = ::Reflex::PointerBuilder(type_2569c);
  ::Reflex::Type type_9840 = ::Reflex::PointerBuilder(type_2365);
  ::Reflex::Type type_1086 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("G4bool"), type_980);
  ::Reflex::Type type_1659c = ::Reflex::ConstBuilder(type_1659);
  ::Reflex::Type type_5271 = ::Reflex::ReferenceBuilder(type_1659c);
  ::Reflex::Type type_10813 = ::Reflex::ReferenceBuilder(type_1760);
  ::Reflex::Type type_1760c = ::Reflex::ConstBuilder(type_1760);
  ::Reflex::Type type_10814 = ::Reflex::ReferenceBuilder(type_1760c);
  ::Reflex::Type type_2397 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2384);
  ::Reflex::Type type_325c = ::Reflex::ConstBuilder(type_325);
  ::Reflex::Type type_2830 = ::Reflex::PointerBuilder(type_325c);
  ::Reflex::Type type_2244 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("str_size"), type_1441);
  ::Reflex::Type type_2224c = ::Reflex::ConstBuilder(type_2224);
  ::Reflex::Type type_9696 = ::Reflex::ReferenceBuilder(type_2224c);
  ::Reflex::Type type_1751c = ::Reflex::ConstBuilder(type_1751);
  ::Reflex::Type type_10810 = ::Reflex::ReferenceBuilder(type_1751c);
  ::Reflex::Type type_2397c = ::Reflex::ConstBuilder(type_2397);
  ::Reflex::Type type_7942 = ::Reflex::ReferenceBuilder(type_2397c);
  ::Reflex::Type type_10812 = ::Reflex::ReferenceBuilder(type_2224);
  ::Reflex::Type type_5925 = ::Reflex::ReferenceBuilder(type_325);
  ::Reflex::Type type_6548 = ::Reflex::ReferenceBuilder(type_325c);
  ::Reflex::Type type_207 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::istream"), type_206);
  ::Reflex::Type type_10175 = ::Reflex::ReferenceBuilder(type_207);
  ::Reflex::Type type_3129 = ::Reflex::PointerBuilder(type_391);
  ::Reflex::Type type_391c = ::Reflex::ConstBuilder(type_391);
  ::Reflex::Type type_5947 = ::Reflex::PointerBuilder(type_391c);
  ::Reflex::Type type_5951 = ::Reflex::ReferenceBuilder(type_391c);
  ::Reflex::Type type_1141 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("ptrdiff_t"), type_59);
  ::Reflex::Type type_2486c = ::Reflex::ConstBuilder(type_2486);
  ::Reflex::Type type_10994 = ::Reflex::ReferenceBuilder(type_2486c);
  ::Reflex::Type type_2362c = ::Reflex::ConstBuilder(type_2362);
  ::Reflex::Type type_10995 = ::Reflex::ReferenceBuilder(type_2362c);
  ::Reflex::Type type_10996 = ::Reflex::ReferenceBuilder(type_2362);
  ::Reflex::Type type_5209 = ::Reflex::PointerBuilder(type_487);
  ::Reflex::Type type_6010 = ::Reflex::PointerBuilder(type_5209);
  ::Reflex::Type type_5209c = ::Reflex::ConstBuilder(type_5209);
  ::Reflex::Type type_6012 = ::Reflex::PointerBuilder(type_5209c);
  ::Reflex::Type type_6014 = ::Reflex::ReferenceBuilder(type_5209);
  ::Reflex::Type type_6016 = ::Reflex::ReferenceBuilder(type_5209c);
  ::Reflex::Type type_2487c = ::Reflex::ConstBuilder(type_2487);
  ::Reflex::Type type_10998 = ::Reflex::ReferenceBuilder(type_2487c);
  ::Reflex::Type type_2363c = ::Reflex::ConstBuilder(type_2363);
  ::Reflex::Type type_10999 = ::Reflex::ReferenceBuilder(type_2363c);
  ::Reflex::Type type_11000 = ::Reflex::ReferenceBuilder(type_2363);
  ::Reflex::Type type_5265 = ::Reflex::PointerBuilder(type_1659);
  ::Reflex::Type type_6075 = ::Reflex::PointerBuilder(type_5265);
  ::Reflex::Type type_5265c = ::Reflex::ConstBuilder(type_5265);
  ::Reflex::Type type_6077 = ::Reflex::PointerBuilder(type_5265c);
  ::Reflex::Type type_6079 = ::Reflex::ReferenceBuilder(type_5265);
  ::Reflex::Type type_6081 = ::Reflex::ReferenceBuilder(type_5265c);
  ::Reflex::Type type_2488c = ::Reflex::ConstBuilder(type_2488);
  ::Reflex::Type type_11002 = ::Reflex::ReferenceBuilder(type_2488c);
  ::Reflex::Type type_2364c = ::Reflex::ConstBuilder(type_2364);
  ::Reflex::Type type_11003 = ::Reflex::ReferenceBuilder(type_2364c);
  ::Reflex::Type type_11004 = ::Reflex::ReferenceBuilder(type_2364);
  ::Reflex::Type type_1888 = ::Reflex::PointerBuilder(type_325);
  ::Reflex::Type type_2494c = ::Reflex::ConstBuilder(type_2494);
  ::Reflex::Type type_11070 = ::Reflex::ReferenceBuilder(type_2494c);
  ::Reflex::Type type_2384c = ::Reflex::ConstBuilder(type_2384);
  ::Reflex::Type type_8034 = ::Reflex::ReferenceBuilder(type_2384c);
  ::Reflex::Type type_7949 = ::Reflex::ReferenceBuilder(type_2384);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __OpNoviceDigi
#undef __OpNoviceDigi
#endif
class __OpNoviceDigi : public ::G4VDigi {
  public:
  __OpNoviceDigi();
  virtual ~__OpNoviceDigi() throw();
  ::G4String fName;
  ::G4int fPmtNumber;
  ::G4int fPixelNumber;
  ::G4int fNPhe;
  ::G4double fFirstHitTime;
  void* fPhysVolMother;
  void* fPhysVol;
};
#ifdef __CLHEP__Hep3Vector
#undef __CLHEP__Hep3Vector
#endif
class __CLHEP__Hep3Vector {
  public:
  __CLHEP__Hep3Vector();
  double dx;
  double dy;
  double dz;
};
#ifdef __G4VDigi
#undef __G4VDigi
#endif
class __G4VDigi {
  public:
  __G4VDigi();
  virtual ~__G4VDigi() throw();
};
#ifdef __OpNovicePMTHit
#undef __OpNovicePMTHit
#endif
class __OpNovicePMTHit : public ::G4VHit {
  public:
  __OpNovicePMTHit();
  virtual ~__OpNovicePMTHit() throw();
  ::G4int fPmtNumber;
  ::G4int fNPhe;
  ::G4int fNPixels;
  ::G4String fName;
  ::std::vector<double> fTime;
  ::std::vector<double> fEnergy;
  ::std::vector<double> fX;
  ::std::vector<double> fY;
  ::std::vector<double> fPixel;
  void* fPhysVolMother;
  void* fPhysVol;
  ::G4bool fDrawit;
  ::G4int fDrawScaleMin;
  ::G4int fDrawScaleMax;
};
#ifdef __G4VHit
#undef __G4VHit
#endif
class __G4VHit {
  public:
  __G4VHit();
  virtual ~__G4VHit() throw();
};
#ifdef __G4String
#undef __G4String
#endif
class __G4String : public ::std::basic_string<char> {
  public:
  __G4String();
};
#ifdef __std__vector_double_
#undef __std__vector_double_
#endif
class __std__vector_double_ : protected ::std::_Vector_base<double,std::allocator<double> > {
  public:
  __std__vector_double_();
};
#ifdef __std__vector_OpNoviceDigip_
#undef __std__vector_OpNoviceDigip_
#endif
class __std__vector_OpNoviceDigip_ : protected ::std::_Vector_base<OpNoviceDigi*,std::allocator<OpNoviceDigi*> > {
  public:
  __std__vector_OpNoviceDigip_();
};
#ifdef __std__vector_OpNovicePMTHitp_
#undef __std__vector_OpNovicePMTHitp_
#endif
class __std__vector_OpNovicePMTHitp_ : protected ::std::_Vector_base<OpNovicePMTHit*,std::allocator<OpNovicePMTHit*> > {
  public:
  __std__vector_OpNovicePMTHitp_();
};
#ifdef __std__basic_string_char_
#undef __std__basic_string_char_
#endif
struct __std__basic_string_char_ {
  public:
  __std__basic_string_char_();
#ifdef __std__basic_string_char____Rep_base
#undef __std__basic_string_char____Rep_base
#endif
  struct __std__basic_string_char____Rep_base {
    public:
    __std__basic_string_char____Rep_base();
    ::size_t _M_length;
    ::size_t _M_capacity;
    ::_Atomic_word _M_refcount;
  };
#ifdef __std__basic_string_char____Rep
#undef __std__basic_string_char____Rep
#endif
  struct __std__basic_string_char____Rep :   public __std__basic_string_char____Rep_base   {
    public:
    __std__basic_string_char____Rep();
  };
#ifdef __std__basic_string_char____Alloc_hider
#undef __std__basic_string_char____Alloc_hider
#endif
  struct __std__basic_string_char____Alloc_hider :   public ::std::allocator<char>   {
    public:
    __std__basic_string_char____Alloc_hider();
    void* _M_p;
  };
  __std__basic_string_char____Alloc_hider _M_dataplus;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class OpNoviceDigi -------------------------------
static void constructor_3329( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::OpNoviceDigi();
  else ::new(mem) ::OpNoviceDigi();
}

static void constructor_3330( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::OpNoviceDigi(*(::G4String*)arg[0]);
  else ::new(mem) ::OpNoviceDigi(*(::G4String*)arg[0]);
}

static void destructor_3331(void*, void * o, const std::vector<void*>&, void *) {
(((::OpNoviceDigi*)o)->::OpNoviceDigi::~OpNoviceDigi)();
}
static void constructor_3332( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::OpNoviceDigi(*(const ::OpNoviceDigi*)arg[0]);
  else ::new(mem) ::OpNoviceDigi(*(const ::OpNoviceDigi*)arg[0]);
}

static  void operator_3333( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::OpNoviceDigi*)o)->operator=)(*(const ::OpNoviceDigi*)arg[0]);
  else   (((::OpNoviceDigi*)o)->operator=)(*(const ::OpNoviceDigi*)arg[0]);
}

static  void operator_3334( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::OpNoviceDigi*)o)->operator==)(*(const ::OpNoviceDigi*)arg[0]));
  else   (((const ::OpNoviceDigi*)o)->operator==)(*(const ::OpNoviceDigi*)arg[0]);
}

static  void operator_3335( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDigi*)o)->operator new)(*(::size_t*)arg[0]));
  else   (((::OpNoviceDigi*)o)->operator new)(*(::size_t*)arg[0]);
}

static  void operator_3336( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->operator delete)((void*)arg[0]);
}

static  void method_3337( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNoviceDigi*)o)->Draw)();
}

static  void method_3338( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNoviceDigi*)o)->Print)();
}

static  void method_3339( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetPMTNumber)(*(::G4int*)arg[0]);
}

static  void method_3340( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNoviceDigi*)o)->GetPMTNumber)());
  else   (((::OpNoviceDigi*)o)->GetPMTNumber)();
}

static  void method_3341( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetPixelNumber)(*(::G4int*)arg[0]);
}

static  void method_3342( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNoviceDigi*)o)->GetPixelNumber)());
  else   (((::OpNoviceDigi*)o)->GetPixelNumber)();
}

static  void method_3343( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetFirstHitTime)(*(::G4double*)arg[0]);
}

static  void method_3344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNoviceDigi*)o)->GetFirstHitTime)());
  else   (((::OpNoviceDigi*)o)->GetFirstHitTime)();
}

static  void method_3345( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetPheCount)(*(::G4int*)arg[0]);
}

static  void method_3346( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNoviceDigi*)o)->IncrementPheCount)();
}

static  void method_3347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNoviceDigi*)o)->GetPheCount)());
  else   (((::OpNoviceDigi*)o)->GetPheCount)();
}

static  void method_3348( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetPMTPhysVol)((::G4VPhysicalVolume*)arg[0]);
}

static  void method_3349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDigi*)o)->GetPMTPhysVol)());
  else   (((::OpNoviceDigi*)o)->GetPMTPhysVol)();
}

static  void method_3350( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetPMTPhysVolMother)((::G4VPhysicalVolume*)arg[0]);
}

static  void method_3351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDigi*)o)->GetPMTPhysVolMother)());
  else   (((::OpNoviceDigi*)o)->GetPMTPhysVolMother)();
}

static void method_newdel_487( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::OpNoviceDigi >::new_np_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::OpNoviceDigi >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::OpNoviceDigi >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::OpNoviceDigi >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::OpNoviceDigi >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("G4VDigi")), ::Reflex::BaseOffset< ::OpNoviceDigi,::G4VDigi >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class OpNoviceDigi -------------------------------
void __OpNoviceDigi_db_datamem(Reflex::Class*);
void __OpNoviceDigi_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __OpNoviceDigi_datamem_bld(&__OpNoviceDigi_db_datamem);
Reflex::GenreflexMemberBuilder __OpNoviceDigi_funcmem_bld(&__OpNoviceDigi_db_funcmem);
void __OpNoviceDigi_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("OpNoviceDigi"), typeid(::OpNoviceDigi), sizeof(::OpNoviceDigi), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1035, ::Reflex::BaseOffset< ::OpNoviceDigi, ::G4VDigi >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("OpNoviceDigi"), constructor_3329, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2224), Reflex::Literal("OpNoviceDigi"), constructor_3330, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~OpNoviceDigi"), destructor_3331, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5215), Reflex::Literal("OpNoviceDigi"), constructor_3332, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_487, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__OpNoviceDigi_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__OpNoviceDigi_funcmem_bld);
}

//------Delayed data member builder for class OpNoviceDigi -------------------
void __OpNoviceDigi_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2224, Reflex::Literal("fName"), OffsetOf(__shadow__::__OpNoviceDigi, fName), ::Reflex::PRIVATE)
  .AddDataMember(type_231, Reflex::Literal("fPmtNumber"), OffsetOf(__shadow__::__OpNoviceDigi, fPmtNumber), ::Reflex::PRIVATE)
  .AddDataMember(type_231, Reflex::Literal("fPixelNumber"), OffsetOf(__shadow__::__OpNoviceDigi, fPixelNumber), ::Reflex::PRIVATE)
  .AddDataMember(type_231, Reflex::Literal("fNPhe"), OffsetOf(__shadow__::__OpNoviceDigi, fNPhe), ::Reflex::PRIVATE)
  .AddDataMember(type_1847, Reflex::Literal("fFirstHitTime"), OffsetOf(__shadow__::__OpNoviceDigi, fFirstHitTime), ::Reflex::PRIVATE)
  .AddDataMember(type_5845, Reflex::Literal("fPhysVolMother"), OffsetOf(__shadow__::__OpNoviceDigi, fPhysVolMother), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_5845, Reflex::Literal("fPhysVol"), OffsetOf(__shadow__::__OpNoviceDigi, fPhysVol), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class OpNoviceDigi -------------------
void __OpNoviceDigi_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5215, type_5215), Reflex::Literal("operator="), operator_3333, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45, type_5215), Reflex::Literal("operator=="), operator_3334, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_1441), Reflex::Literal("operator new"), operator_3335, 0, "", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_613), Reflex::Literal("operator delete"), operator_3336, 0, "aDigi", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("Draw"), method_3337, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("Print"), method_3338, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_231), Reflex::Literal("SetPMTNumber"), method_3339, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231), Reflex::Literal("GetPMTNumber"), method_3340, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_231), Reflex::Literal("SetPixelNumber"), method_3341, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231), Reflex::Literal("GetPixelNumber"), method_3342, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1847), Reflex::Literal("SetFirstHitTime"), method_3343, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231), Reflex::Literal("GetFirstHitTime"), method_3344, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_231), Reflex::Literal("SetPheCount"), method_3345, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("IncrementPheCount"), method_3346, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231), Reflex::Literal("GetPheCount"), method_3347, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_5845), Reflex::Literal("SetPMTPhysVol"), method_3348, 0, "physVol", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5845), Reflex::Literal("GetPMTPhysVol"), method_3349, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_5845), Reflex::Literal("SetPMTPhysVolMother"), method_3350, 0, "physVol", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5845), Reflex::Literal("GetPMTPhysVolMother"), method_3351, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Hep3Vector -------------------------------
static void constructor_4052( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector();
  else ::new(mem) ::CLHEP::Hep3Vector();
}

static void constructor_4053( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0]);
  else ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0]);
}

static void constructor_4054( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0],
      *(double*)arg[1]);
}

static void constructor_4055( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
}

static void constructor_4056( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else ::new(mem) ::CLHEP::Hep3Vector(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static void destructor_4057(void*, void * o, const std::vector<void*>&, void *) {
(((::CLHEP::Hep3Vector*)o)->::CLHEP::Hep3Vector::~Hep3Vector)();
}
static  void operator_4058( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->operator())(*(int*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator())(*(int*)arg[0]);
}

static  void operator_4059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->operator[])(*(int*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator[])(*(int*)arg[0]);
}

static  void operator_4060( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator())(*(int*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator())(*(int*)arg[0]);
}

static  void operator_4061( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator[])(*(int*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator[])(*(int*)arg[0]);
}

static  void method_4062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->x)());
  else   (((const ::CLHEP::Hep3Vector*)o)->x)();
}

static  void method_4063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->y)());
  else   (((const ::CLHEP::Hep3Vector*)o)->y)();
}

static  void method_4064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->z)());
  else   (((const ::CLHEP::Hep3Vector*)o)->z)();
}

static  void method_4065( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setX)(*(double*)arg[0]);
}

static  void method_4066( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setY)(*(double*)arg[0]);
}

static  void method_4067( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setZ)(*(double*)arg[0]);
}

static  void method_4068( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->set)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->phi)());
  else   (((const ::CLHEP::Hep3Vector*)o)->phi)();
}

static  void method_4070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->theta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->theta)();
}

static  void method_4071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->cosTheta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->cosTheta)();
}

static  void method_4072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->cos2Theta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->cos2Theta)();
}

static  void method_4073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->mag2)());
  else   (((const ::CLHEP::Hep3Vector*)o)->mag2)();
}

static  void method_4074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->mag)());
  else   (((const ::CLHEP::Hep3Vector*)o)->mag)();
}

static  void method_4075( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setPhi)(*(double*)arg[0]);
}

static  void method_4076( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setTheta)(*(double*)arg[0]);
}

static  void method_4077( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setMag)(*(double*)arg[0]);
}

static  void method_4078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->perp2)());
  else   (((const ::CLHEP::Hep3Vector*)o)->perp2)();
}

static  void method_4079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->perp)());
  else   (((const ::CLHEP::Hep3Vector*)o)->perp)();
}

static  void method_4080( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setPerp)(*(double*)arg[0]);
}

static  void method_4081( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setCylTheta)(*(double*)arg[0]);
}

static  void method_4082( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->perp2)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->perp2)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4083( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->perp)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->perp)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4084( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4085( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator==)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator==)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4086( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator!=)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator!=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4087( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isNear)(*(const ::CLHEP::Hep3Vector*)arg[0]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isNear)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isNear)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isNear)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_4088( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->howNear)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->howNear)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->deltaR)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->deltaR)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4090( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator+=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator+=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4091( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator-=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator-=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->operator-)());
  else   (((const ::CLHEP::Hep3Vector*)o)->operator-)();
}

static  void operator_4093( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator*=)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator*=)(*(double*)arg[0]);
}

static  void operator_4094( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator/=)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator/=)(*(double*)arg[0]);
}

static  void method_4095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->unit)());
  else   (((const ::CLHEP::Hep3Vector*)o)->unit)();
}

static  void method_4096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->orthogonal)());
  else   (((const ::CLHEP::Hep3Vector*)o)->orthogonal)();
}

static  void method_4097( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->dot)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->dot)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4098( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->cross)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->cross)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4099( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->angle)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->angle)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->pseudoRapidity)());
  else   (((const ::CLHEP::Hep3Vector*)o)->pseudoRapidity)();
}

static  void method_4101( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setEta)(*(double*)arg[0]);
}

static  void method_4102( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setCylEta)(*(double*)arg[0]);
}

static  void method_4103( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotateX)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotateX)(*(double*)arg[0]);
}

static  void method_4104( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotateY)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotateY)(*(double*)arg[0]);
}

static  void method_4105( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotateZ)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotateZ)(*(double*)arg[0]);
}

static  void method_4106( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotateUz)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotateUz)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4107( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(double*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(double*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]);
}

static  void operator_4108( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator*=)(*(const ::CLHEP::HepRotation*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator*=)(*(const ::CLHEP::HepRotation*)arg[0]);
}

static  void method_4109( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->transform)(*(const ::CLHEP::HepRotation*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->transform)(*(const ::CLHEP::HepRotation*)arg[0]);
}

static  void method_4110( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRThetaPhi)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4111( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setREtaPhi)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4112( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRhoPhiZ)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4113( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRhoPhiTheta)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4114( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRhoPhiEta)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getX)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getX)();
}

static  void method_4116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getY)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getY)();
}

static  void method_4117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getZ)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getZ)();
}

static  void method_4118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getR)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getR)();
}

static  void method_4119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getTheta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getTheta)();
}

static  void method_4120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getPhi)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getPhi)();
}

static  void method_4121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->r)());
  else   (((const ::CLHEP::Hep3Vector*)o)->r)();
}

static  void method_4122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->rho)());
  else   (((const ::CLHEP::Hep3Vector*)o)->rho)();
}

static  void method_4123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getRho)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getRho)();
}

static  void method_4124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->eta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->eta)();
}

static  void method_4125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getEta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getEta)();
}

static  void method_4126( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setR)(*(double*)arg[0]);
}

static  void method_4127( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRho)(*(double*)arg[0]);
}

static  void method_4128( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::CLHEP::Hep3Vector*)o)->compare)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->compare)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4129( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator>)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator>)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4130( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator<)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator<)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4131( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator>=)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator>=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4132( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator<=)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator<=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4133( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->diff2)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->diff2)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::CLHEP::Hep3Vector*)o)->setTolerance)(*(double*)arg[0]));
  else   (((::CLHEP::Hep3Vector*)o)->setTolerance)(*(double*)arg[0]);
}

static  void method_4135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::CLHEP::Hep3Vector*)o)->getTolerance)());
  else   (((::CLHEP::Hep3Vector*)o)->getTolerance)();
}

static  void method_4136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isParallel)(*(const ::CLHEP::Hep3Vector*)arg[0]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isParallel)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isParallel)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isParallel)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_4137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_4138( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->howParallel)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->howParallel)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4139( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->howOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->howOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->beta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->beta)();
}

static  void method_4141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->gamma)());
  else   (((const ::CLHEP::Hep3Vector*)o)->gamma)();
}

static  void method_4142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->coLinearRapidity)());
  else   (((const ::CLHEP::Hep3Vector*)o)->coLinearRapidity)();
}

static  void method_4143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->angle)());
  else   (((const ::CLHEP::Hep3Vector*)o)->angle)();
}

static  void method_4144( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->theta)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->theta)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4145( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->cosTheta)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->cosTheta)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->cos2Theta)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->cos2Theta)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->project)());
  else   (((const ::CLHEP::Hep3Vector*)o)->project)();
}

static  void method_4148( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->project)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->project)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->perpPart)());
  else   (((const ::CLHEP::Hep3Vector*)o)->perpPart)();
}

static  void method_4150( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->perpPart)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->perpPart)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4151( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->rapidity)());
  else   (((const ::CLHEP::Hep3Vector*)o)->rapidity)();
}

static  void method_4152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->rapidity)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->rapidity)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4153( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->eta)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->eta)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4154( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->polarAngle)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->polarAngle)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4155( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->deltaPhi)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->deltaPhi)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4156( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->azimAngle)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->azimAngle)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4157( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->polarAngle)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]));
  else   (((const ::CLHEP::Hep3Vector*)o)->polarAngle)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]);
}

static  void method_4158( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->azimAngle)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]));
  else   (((const ::CLHEP::Hep3Vector*)o)->azimAngle)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]);
}

static  void method_4159( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(double*)arg[1]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(double*)arg[1]);
}

static  void method_4160( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::HepAxisAngle*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::HepAxisAngle*)arg[0]);
}

static  void method_4161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::HepEulerAngles*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::HepEulerAngles*)arg[0]);
}

static  void method_4162( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static void method_newdel_1016( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Hep3Vector -------------------------------
void __CLHEP__Hep3Vector_db_datamem(Reflex::Class*);
void __CLHEP__Hep3Vector_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __CLHEP__Hep3Vector_datamem_bld(&__CLHEP__Hep3Vector_db_datamem);
Reflex::GenreflexMemberBuilder __CLHEP__Hep3Vector_funcmem_bld(&__CLHEP__Hep3Vector_db_funcmem);
void __CLHEP__Hep3Vector_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("CLHEP::Hep3Vector"), typeid(::CLHEP::Hep3Vector), sizeof(::CLHEP::Hep3Vector), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_88"), Reflex::Literal("X=0;Y=1;Z=2;NUM_COORDINATES=3;SIZE=3"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("_89"), Reflex::Literal("ToleranceTicks=100"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Hep3Vector"), constructor_4052, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_391), Reflex::Literal("Hep3Vector"), constructor_4053, 0, "x1", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_391, type_391), Reflex::Literal("Hep3Vector"), constructor_4054, 0, "x1;y1", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_391, type_391, type_391), Reflex::Literal("Hep3Vector"), constructor_4055, 0, "x1;y1;z1", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9830), Reflex::Literal("Hep3Vector"), constructor_4056, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Hep3Vector"), destructor_4057, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1016, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__CLHEP__Hep3Vector_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__CLHEP__Hep3Vector_funcmem_bld);
}

//------Delayed data member builder for class Hep3Vector -------------------
void __CLHEP__Hep3Vector_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_391, Reflex::Literal("dx"), OffsetOf(__shadow__::__CLHEP__Hep3Vector, dx), ::Reflex::PROTECTED)
  .AddDataMember(type_391, Reflex::Literal("dy"), OffsetOf(__shadow__::__CLHEP__Hep3Vector, dy), ::Reflex::PROTECTED)
  .AddDataMember(type_391, Reflex::Literal("dz"), OffsetOf(__shadow__::__CLHEP__Hep3Vector, dz), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Hep3Vector -------------------
void __CLHEP__Hep3Vector_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_45), Reflex::Literal("operator()"), operator_4058, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_45), Reflex::Literal("operator[]"), operator_4059, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5949, type_45), Reflex::Literal("operator()"), operator_4060, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5949, type_45), Reflex::Literal("operator[]"), operator_4061, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("x"), method_4062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("y"), method_4063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("z"), method_4064, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_391), Reflex::Literal("setX"), method_4065, 0, "x1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_391), Reflex::Literal("setY"), method_4066, 0, "y1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_391), Reflex::Literal("setZ"), method_4067, 0, "z1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_391, type_391, type_391), Reflex::Literal("set"), method_4068, 0, "x1;y1;z1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("phi"), method_4069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("theta"), method_4070, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("cosTheta"), method_4071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("cos2Theta"), method_4072, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("mag2"), method_4073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("mag"), method_4074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_391), Reflex::Literal("setPhi"), method_4075, 0, "ph", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_391), Reflex::Literal("setTheta"), method_4076, 0, "th", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_391), Reflex::Literal("setMag"), method_4077, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("perp2"), method_4078, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("perp"), method_4079, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_391), Reflex::Literal("setPerp"), method_4080, 0, "r1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_391), Reflex::Literal("setCylTheta"), method_4081, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830), Reflex::Literal("perp2"), method_4082, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830), Reflex::Literal("perp"), method_4083, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9831, type_9830), Reflex::Literal("operator="), operator_4084, 0, "p", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_9830), Reflex::Literal("operator=="), operator_4085, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_9830), Reflex::Literal("operator!="), operator_4086, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_9830, type_391), Reflex::Literal("isNear"), method_4087, 0, ";epsilon=CLHEP::Hep3Vector::tolerance", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830), Reflex::Literal("howNear"), method_4088, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830), Reflex::Literal("deltaR"), method_4089, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9831, type_9830), Reflex::Literal("operator+="), operator_4090, 0, "p", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9831, type_9830), Reflex::Literal("operator-="), operator_4091, 0, "p", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016), Reflex::Literal("operator-"), operator_4092, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9831, type_391), Reflex::Literal("operator*="), operator_4093, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9831, type_391), Reflex::Literal("operator/="), operator_4094, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016), Reflex::Literal("unit"), method_4095, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016), Reflex::Literal("orthogonal"), method_4096, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830), Reflex::Literal("dot"), method_4097, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016, type_9830), Reflex::Literal("cross"), method_4098, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830), Reflex::Literal("angle"), method_4099, 0, "q", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("pseudoRapidity"), method_4100, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_391), Reflex::Literal("setEta"), method_4101, 0, "p", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_391), Reflex::Literal("setCylEta"), method_4102, 0, "p", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9831, type_391), Reflex::Literal("rotateX"), method_4103, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9831, type_391), Reflex::Literal("rotateY"), method_4104, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9831, type_391), Reflex::Literal("rotateZ"), method_4105, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9831, type_9830), Reflex::Literal("rotateUz"), method_4106, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9831, type_391, type_9830), Reflex::Literal("rotate"), method_4107, 0, ";", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9831, type_9832), Reflex::Literal("operator*="), operator_4108, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9831, type_9832), Reflex::Literal("transform"), method_4109, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_391, type_391, type_391), Reflex::Literal("setRThetaPhi"), method_4110, 0, "r1;theta1;phi1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_391, type_391, type_391), Reflex::Literal("setREtaPhi"), method_4111, 0, "r1;eta1;phi1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_391, type_391, type_391), Reflex::Literal("setRhoPhiZ"), method_4112, 0, "rho1;phi1;z1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_391, type_391, type_391), Reflex::Literal("setRhoPhiTheta"), method_4113, 0, "rho;phi;theta", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_391, type_391, type_391), Reflex::Literal("setRhoPhiEta"), method_4114, 0, "rho;phi;eta", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("getX"), method_4115, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("getY"), method_4116, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("getZ"), method_4117, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("getR"), method_4118, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("getTheta"), method_4119, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("getPhi"), method_4120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("r"), method_4121, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("rho"), method_4122, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("getRho"), method_4123, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("eta"), method_4124, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("getEta"), method_4125, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_391), Reflex::Literal("setR"), method_4126, 0, "r1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_391), Reflex::Literal("setRho"), method_4127, 0, "rho1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45, type_9830), Reflex::Literal("compare"), method_4128, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_9830), Reflex::Literal("operator>"), operator_4129, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_9830), Reflex::Literal("operator<"), operator_4130, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_9830), Reflex::Literal("operator>="), operator_4131, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_9830), Reflex::Literal("operator<="), operator_4132, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830), Reflex::Literal("diff2"), method_4133, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_391), Reflex::Literal("setTolerance"), method_4134, 0, "tol", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("getTolerance"), method_4135, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_9830, type_391), Reflex::Literal("isParallel"), method_4136, 0, "v;epsilon=CLHEP::Hep3Vector::tolerance", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_9830, type_391), Reflex::Literal("isOrthogonal"), method_4137, 0, "v;epsilon=CLHEP::Hep3Vector::tolerance", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830), Reflex::Literal("howParallel"), method_4138, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830), Reflex::Literal("howOrthogonal"), method_4139, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("beta"), method_4140, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("gamma"), method_4141, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("coLinearRapidity"), method_4142, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("angle"), method_4143, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830), Reflex::Literal("theta"), method_4144, 0, "q", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830), Reflex::Literal("cosTheta"), method_4145, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830), Reflex::Literal("cos2Theta"), method_4146, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016), Reflex::Literal("project"), method_4147, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016, type_9830), Reflex::Literal("project"), method_4148, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016), Reflex::Literal("perpPart"), method_4149, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016, type_9830), Reflex::Literal("perpPart"), method_4150, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391), Reflex::Literal("rapidity"), method_4151, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830), Reflex::Literal("rapidity"), method_4152, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830), Reflex::Literal("eta"), method_4153, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830), Reflex::Literal("polarAngle"), method_4154, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830), Reflex::Literal("deltaPhi"), method_4155, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830), Reflex::Literal("azimAngle"), method_4156, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830, type_9830), Reflex::Literal("polarAngle"), method_4157, 0, "v2;ref", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_391, type_9830, type_9830), Reflex::Literal("azimAngle"), method_4158, 0, "v2;ref", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9831, type_9830, type_391), Reflex::Literal("rotate"), method_4159, 0, "axis;delta", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9831, type_9833), Reflex::Literal("rotate"), method_4160, 0, "ax", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9831, type_9834), Reflex::Literal("rotate"), method_4161, 0, "e", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9831, type_391, type_391, type_391), Reflex::Literal("rotate"), method_4162, 0, "phi;theta;psi", ::Reflex::PUBLIC);
}
//------Stub functions for class G4VDigi -------------------------------
static  void operator_4173( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4VDigi*)o)->operator=)(*(const ::G4VDigi*)arg[0]);
  else   (((::G4VDigi*)o)->operator=)(*(const ::G4VDigi*)arg[0]);
}

static void constructor_4174( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4VDigi(*(const ::G4VDigi*)arg[0]);
  else ::new(mem) ::G4VDigi(*(const ::G4VDigi*)arg[0]);
}

static void constructor_4175( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4VDigi();
  else ::new(mem) ::G4VDigi();
}

static void destructor_4176(void*, void * o, const std::vector<void*>&, void *) {
(((::G4VDigi*)o)->::G4VDigi::~G4VDigi)();
}
static  void operator_4177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4int)((((const ::G4VDigi*)o)->operator==)(*(const ::G4VDigi*)arg[0]));
  else   (((const ::G4VDigi*)o)->operator==)(*(const ::G4VDigi*)arg[0]);
}

static  void method_4178( void*, void* o, const std::vector<void*>&, void*)
{
  (((::G4VDigi*)o)->Draw)();
}

static  void method_4179( void*, void* o, const std::vector<void*>&, void*)
{
  (((::G4VDigi*)o)->Print)();
}

static  void method_4180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::G4VDigi*)o)->GetAttDefs)());
  else   (((const ::G4VDigi*)o)->GetAttDefs)();
}

static  void method_4181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::G4VDigi*)o)->CreateAttValues)());
  else   (((const ::G4VDigi*)o)->CreateAttValues)();
}

static void method_newdel_1035( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::G4VDigi >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::G4VDigi >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::G4VDigi >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::G4VDigi >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::G4VDigi >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class G4VDigi -------------------------------
void __G4VDigi_db_datamem(Reflex::Class*);
void __G4VDigi_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __G4VDigi_datamem_bld(&__G4VDigi_db_datamem);
Reflex::GenreflexMemberBuilder __G4VDigi_funcmem_bld(&__G4VDigi_db_funcmem);
void __G4VDigi_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("G4VDigi"), typeid(::G4VDigi), sizeof(::G4VDigi), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9837, type_9838), Reflex::Literal("operator="), operator_4173, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9838), Reflex::Literal("G4VDigi"), constructor_4174, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("G4VDigi"), constructor_4175, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~G4VDigi"), destructor_4176, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1035, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__G4VDigi_funcmem_bld);
}

//------Delayed data member builder for class G4VDigi -------------------
void __G4VDigi_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class G4VDigi -------------------
void __G4VDigi_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231, type_9838), Reflex::Literal("operator=="), operator_4177, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("Draw"), method_4178, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("Print"), method_4179, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9839), Reflex::Literal("GetAttDefs"), method_4180, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9840), Reflex::Literal("CreateAttValues"), method_4181, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class OpNovicePMTHit -------------------------------
static void constructor_4792( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::OpNovicePMTHit();
  else ::new(mem) ::OpNovicePMTHit();
}

static void destructor_4793(void*, void * o, const std::vector<void*>&, void *) {
(((::OpNovicePMTHit*)o)->::OpNovicePMTHit::~OpNovicePMTHit)();
}
static void constructor_4794( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::OpNovicePMTHit(*(const ::OpNovicePMTHit*)arg[0]);
  else ::new(mem) ::OpNovicePMTHit(*(const ::OpNovicePMTHit*)arg[0]);
}

static  void operator_4795( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::OpNovicePMTHit*)o)->operator=)(*(const ::OpNovicePMTHit*)arg[0]);
  else   (((::OpNovicePMTHit*)o)->operator=)(*(const ::OpNovicePMTHit*)arg[0]);
}

static  void operator_4796( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4int)((((const ::OpNovicePMTHit*)o)->operator==)(*(const ::OpNovicePMTHit*)arg[0]));
  else   (((const ::OpNovicePMTHit*)o)->operator==)(*(const ::OpNovicePMTHit*)arg[0]);
}

static  void operator_4797( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNovicePMTHit*)o)->operator new)(*(::size_t*)arg[0]));
  else   (((::OpNovicePMTHit*)o)->operator new)(*(::size_t*)arg[0]);
}

static  void operator_4798( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->operator delete)((void*)arg[0]);
}

static  void method_4799( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNovicePMTHit*)o)->Draw)();
}

static  void method_4800( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNovicePMTHit*)o)->Print)();
}

static  void method_4801( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetDrawit)(*(::G4bool*)arg[0]);
}

static  void method_4802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4bool)((((::OpNovicePMTHit*)o)->GetDrawit)());
  else   (((::OpNovicePMTHit*)o)->GetDrawit)();
}

static  void method_4803( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNovicePMTHit*)o)->IncrementNPhe)();
}

static  void method_4804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNovicePMTHit*)o)->GetPheCount)());
  else   (((::OpNovicePMTHit*)o)->GetPheCount)();
}

static  void method_4805( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetPMTNumber)(*(::G4int*)arg[0]);
}

static  void method_4806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNovicePMTHit*)o)->GetPMTNumber)());
  else   (((::OpNovicePMTHit*)o)->GetPMTNumber)();
}

static  void method_4807( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetNPixels)(*(::G4int*)arg[0]);
}

static  void method_4808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNovicePMTHit*)o)->GetNPixels)());
  else   (((::OpNovicePMTHit*)o)->GetNPixels)();
}

static  void method_4809( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetHitData)(*(::G4double*)arg[0],
    *(::G4double*)arg[1],
    *(::G4double*)arg[2],
    *(::G4double*)arg[3],
    *(::G4int*)arg[4]);
}

static  void method_4810( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4double)((((::OpNovicePMTHit*)o)->GetX)(*(int*)arg[0]));
  else   (((::OpNovicePMTHit*)o)->GetX)(*(int*)arg[0]);
}

static  void method_4811( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4double)((((::OpNovicePMTHit*)o)->GetY)(*(int*)arg[0]));
  else   (((::OpNovicePMTHit*)o)->GetY)(*(int*)arg[0]);
}

static  void method_4812( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4double)((((::OpNovicePMTHit*)o)->GetT)(*(int*)arg[0]));
  else   (((::OpNovicePMTHit*)o)->GetT)(*(int*)arg[0]);
}

static  void method_4813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4double)((((::OpNovicePMTHit*)o)->GetE)(*(int*)arg[0]));
  else   (((::OpNovicePMTHit*)o)->GetE)(*(int*)arg[0]);
}

static  void method_4814( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNovicePMTHit*)o)->GetPixel)(*(int*)arg[0]));
  else   (((::OpNovicePMTHit*)o)->GetPixel)(*(int*)arg[0]);
}

static  void method_4815( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetPMTPhysVol)((::G4VPhysicalVolume*)arg[0]);
}

static  void method_4816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNovicePMTHit*)o)->GetPMTPhysVol)());
  else   (((::OpNovicePMTHit*)o)->GetPMTPhysVol)();
}

static  void method_4817( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetPMTPhysVolMother)((::G4VPhysicalVolume*)arg[0]);
}

static  void method_4818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNovicePMTHit*)o)->GetPMTPhysVolMother)());
  else   (((::OpNovicePMTHit*)o)->GetPMTPhysVolMother)();
}

static  void method_4819( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetDrawScaleMax)(*(::G4int*)arg[0]);
}

static  void method_4820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNovicePMTHit*)o)->GetDrawScaleMax)());
  else   (((::OpNovicePMTHit*)o)->GetDrawScaleMax)();
}

static  void method_4821( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetDrawScaleMin)(*(::G4int*)arg[0]);
}

static  void method_4822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNovicePMTHit*)o)->GetDrawScaleMin)());
  else   (((::OpNovicePMTHit*)o)->GetDrawScaleMin)();
}

static  void method_4823( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetName)(*(::G4String*)arg[0]);
}

static  void method_4824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4String)((((::OpNovicePMTHit*)o)->GetName)());
  else   (((::OpNovicePMTHit*)o)->GetName)();
}

static void method_newdel_1659( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::OpNovicePMTHit >::new_np_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::OpNovicePMTHit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::OpNovicePMTHit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::OpNovicePMTHit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::OpNovicePMTHit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("G4VHit")), ::Reflex::BaseOffset< ::OpNovicePMTHit,::G4VHit >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class OpNovicePMTHit -------------------------------
void __OpNovicePMTHit_db_datamem(Reflex::Class*);
void __OpNovicePMTHit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __OpNovicePMTHit_datamem_bld(&__OpNovicePMTHit_db_datamem);
Reflex::GenreflexMemberBuilder __OpNovicePMTHit_funcmem_bld(&__OpNovicePMTHit_db_funcmem);
void __OpNovicePMTHit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("OpNovicePMTHit"), typeid(::OpNovicePMTHit), sizeof(::OpNovicePMTHit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1760, ::Reflex::BaseOffset< ::OpNovicePMTHit, ::G4VHit >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("OpNovicePMTHit"), constructor_4792, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~OpNovicePMTHit"), destructor_4793, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5271), Reflex::Literal("OpNovicePMTHit"), constructor_4794, 0, "right", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1659, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__OpNovicePMTHit_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__OpNovicePMTHit_funcmem_bld);
}

//------Delayed data member builder for class OpNovicePMTHit -------------------
void __OpNovicePMTHit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_231, Reflex::Literal("fPmtNumber"), OffsetOf(__shadow__::__OpNovicePMTHit, fPmtNumber), ::Reflex::PRIVATE)
  .AddDataMember(type_231, Reflex::Literal("fNPhe"), OffsetOf(__shadow__::__OpNovicePMTHit, fNPhe), ::Reflex::PRIVATE)
  .AddDataMember(type_231, Reflex::Literal("fNPixels"), OffsetOf(__shadow__::__OpNovicePMTHit, fNPixels), ::Reflex::PRIVATE)
  .AddDataMember(type_2224, Reflex::Literal("fName"), OffsetOf(__shadow__::__OpNovicePMTHit, fName), ::Reflex::PRIVATE)
  .AddDataMember(type_2362, Reflex::Literal("fTime"), OffsetOf(__shadow__::__OpNovicePMTHit, fTime), ::Reflex::PRIVATE)
  .AddDataMember(type_2362, Reflex::Literal("fEnergy"), OffsetOf(__shadow__::__OpNovicePMTHit, fEnergy), ::Reflex::PRIVATE)
  .AddDataMember(type_2362, Reflex::Literal("fX"), OffsetOf(__shadow__::__OpNovicePMTHit, fX), ::Reflex::PRIVATE)
  .AddDataMember(type_2362, Reflex::Literal("fY"), OffsetOf(__shadow__::__OpNovicePMTHit, fY), ::Reflex::PRIVATE)
  .AddDataMember(type_2362, Reflex::Literal("fPixel"), OffsetOf(__shadow__::__OpNovicePMTHit, fPixel), ::Reflex::PRIVATE)
  .AddDataMember(type_5845, Reflex::Literal("fPhysVolMother"), OffsetOf(__shadow__::__OpNovicePMTHit, fPhysVolMother), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_5845, Reflex::Literal("fPhysVol"), OffsetOf(__shadow__::__OpNovicePMTHit, fPhysVol), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_1086, Reflex::Literal("fDrawit"), OffsetOf(__shadow__::__OpNovicePMTHit, fDrawit), ::Reflex::PRIVATE)
  .AddDataMember(type_231, Reflex::Literal("fDrawScaleMin"), OffsetOf(__shadow__::__OpNovicePMTHit, fDrawScaleMin), ::Reflex::PRIVATE)
  .AddDataMember(type_231, Reflex::Literal("fDrawScaleMax"), OffsetOf(__shadow__::__OpNovicePMTHit, fDrawScaleMax), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class OpNovicePMTHit -------------------
void __OpNovicePMTHit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5271, type_5271), Reflex::Literal("operator="), operator_4795, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231, type_5271), Reflex::Literal("operator=="), operator_4796, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_1441), Reflex::Literal("operator new"), operator_4797, 0, "", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_613), Reflex::Literal("operator delete"), operator_4798, 0, "aHit", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("Draw"), method_4799, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("Print"), method_4800, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1086), Reflex::Literal("SetDrawit"), method_4801, 0, "b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1086), Reflex::Literal("GetDrawit"), method_4802, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("IncrementNPhe"), method_4803, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231), Reflex::Literal("GetPheCount"), method_4804, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_231), Reflex::Literal("SetPMTNumber"), method_4805, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231), Reflex::Literal("GetPMTNumber"), method_4806, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_231), Reflex::Literal("SetNPixels"), method_4807, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231), Reflex::Literal("GetNPixels"), method_4808, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1847, type_1847, type_1847, type_1847, type_231), Reflex::Literal("SetHitData"), method_4809, 0, "t;e;x;y;pixel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1847, type_45), Reflex::Literal("GetX"), method_4810, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1847, type_45), Reflex::Literal("GetY"), method_4811, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1847, type_45), Reflex::Literal("GetT"), method_4812, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1847, type_45), Reflex::Literal("GetE"), method_4813, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231, type_45), Reflex::Literal("GetPixel"), method_4814, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_5845), Reflex::Literal("SetPMTPhysVol"), method_4815, 0, "physVol", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5845), Reflex::Literal("GetPMTPhysVol"), method_4816, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_5845), Reflex::Literal("SetPMTPhysVolMother"), method_4817, 0, "physVol", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5845), Reflex::Literal("GetPMTPhysVolMother"), method_4818, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_231), Reflex::Literal("SetDrawScaleMax"), method_4819, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231), Reflex::Literal("GetDrawScaleMax"), method_4820, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_231), Reflex::Literal("SetDrawScaleMin"), method_4821, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231), Reflex::Literal("GetDrawScaleMin"), method_4822, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_2224), Reflex::Literal("SetName"), method_4823, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2224), Reflex::Literal("GetName"), method_4824, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class G4VHit -------------------------------
static  void operator_4896( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4VHit*)o)->operator=)(*(const ::G4VHit*)arg[0]);
  else   (((::G4VHit*)o)->operator=)(*(const ::G4VHit*)arg[0]);
}

static void constructor_4897( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4VHit(*(const ::G4VHit*)arg[0]);
  else ::new(mem) ::G4VHit(*(const ::G4VHit*)arg[0]);
}

static void constructor_4898( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4VHit();
  else ::new(mem) ::G4VHit();
}

static void destructor_4899(void*, void * o, const std::vector<void*>&, void *) {
(((::G4VHit*)o)->::G4VHit::~G4VHit)();
}
static  void operator_4900( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4int)((((const ::G4VHit*)o)->operator==)(*(const ::G4VHit*)arg[0]));
  else   (((const ::G4VHit*)o)->operator==)(*(const ::G4VHit*)arg[0]);
}

static  void method_4901( void*, void* o, const std::vector<void*>&, void*)
{
  (((::G4VHit*)o)->Draw)();
}

static  void method_4902( void*, void* o, const std::vector<void*>&, void*)
{
  (((::G4VHit*)o)->Print)();
}

static  void method_4903( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::G4VHit*)o)->GetAttDefs)());
  else   (((const ::G4VHit*)o)->GetAttDefs)();
}

static  void method_4904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::G4VHit*)o)->CreateAttValues)());
  else   (((const ::G4VHit*)o)->CreateAttValues)();
}

static void method_newdel_1760( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::G4VHit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::G4VHit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::G4VHit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::G4VHit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::G4VHit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class G4VHit -------------------------------
void __G4VHit_db_datamem(Reflex::Class*);
void __G4VHit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __G4VHit_datamem_bld(&__G4VHit_db_datamem);
Reflex::GenreflexMemberBuilder __G4VHit_funcmem_bld(&__G4VHit_db_funcmem);
void __G4VHit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("G4VHit"), typeid(::G4VHit), sizeof(::G4VHit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10813, type_10814), Reflex::Literal("operator="), operator_4896, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10814), Reflex::Literal("G4VHit"), constructor_4897, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("G4VHit"), constructor_4898, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~G4VHit"), destructor_4899, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1760, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__G4VHit_funcmem_bld);
}

//------Delayed data member builder for class G4VHit -------------------
void __G4VHit_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class G4VHit -------------------
void __G4VHit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231, type_10814), Reflex::Literal("operator=="), operator_4900, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("Draw"), method_4901, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("Print"), method_4902, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9839), Reflex::Literal("GetAttDefs"), method_4903, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9840), Reflex::Literal("CreateAttValues"), method_4904, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class G4String -------------------------------
static void constructor_5348( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4String();
  else ::new(mem) ::G4String();
}

static void constructor_5349( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4String(*(char*)arg[0]);
  else ::new(mem) ::G4String(*(char*)arg[0]);
}

static void constructor_5350( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4String((const char*)arg[0]);
  else ::new(mem) ::G4String((const char*)arg[0]);
}

static void constructor_5351( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4String((const char*)arg[0],
      *(::str_size*)arg[1]);
  else ::new(mem) ::G4String((const char*)arg[0],
      *(::str_size*)arg[1]);
}

static void constructor_5352( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4String(*(const ::G4String*)arg[0]);
  else ::new(mem) ::G4String(*(const ::G4String*)arg[0]);
}

static void constructor_5353( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4String(*(const ::G4SubString*)arg[0]);
  else ::new(mem) ::G4String(*(const ::G4SubString*)arg[0]);
}

static void constructor_5354( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4String(*(const ::std::string*)arg[0]);
  else ::new(mem) ::G4String(*(const ::std::string*)arg[0]);
}

static void destructor_5355(void*, void * o, const std::vector<void*>&, void *) {
(((::G4String*)o)->::G4String::~G4String)();
}
static  void operator_5356( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->operator=)(*(const ::G4String*)arg[0]);
  else   (((::G4String*)o)->operator=)(*(const ::G4String*)arg[0]);
}

static  void operator_5357( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->operator=)(*(const ::std::string*)arg[0]);
  else   (((::G4String*)o)->operator=)(*(const ::std::string*)arg[0]);
}

static  void operator_5358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->operator=)((const char*)arg[0]);
  else   (((::G4String*)o)->operator=)((const char*)arg[0]);
}

static  void operator_5359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (char)((((const ::G4String*)o)->operator())(*(::str_size*)arg[0]));
  else   (((const ::G4String*)o)->operator())(*(::str_size*)arg[0]);
}

static  void operator_5360( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->operator())(*(::str_size*)arg[0]);
  else   (((::G4String*)o)->operator())(*(::str_size*)arg[0]);
}

static  void operator_5361( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->operator+=)(*(const ::G4SubString*)arg[0]);
  else   (((::G4String*)o)->operator+=)(*(const ::G4SubString*)arg[0]);
}

static  void operator_5362( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->operator+=)((const char*)arg[0]);
  else   (((::G4String*)o)->operator+=)((const char*)arg[0]);
}

static  void operator_5363( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->operator+=)(*(const ::std::string*)arg[0]);
  else   (((::G4String*)o)->operator+=)(*(const ::std::string*)arg[0]);
}

static  void operator_5364( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->operator+=)(*(const char*)arg[0]);
  else   (((::G4String*)o)->operator+=)(*(const char*)arg[0]);
}

static  void operator_5365( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4bool)((((const ::G4String*)o)->operator==)(*(const ::G4String*)arg[0]));
  else   (((const ::G4String*)o)->operator==)(*(const ::G4String*)arg[0]);
}

static  void operator_5366( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4bool)((((const ::G4String*)o)->operator==)((const char*)arg[0]));
  else   (((const ::G4String*)o)->operator==)((const char*)arg[0]);
}

static  void operator_5367( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4bool)((((const ::G4String*)o)->operator!=)(*(const ::G4String*)arg[0]));
  else   (((const ::G4String*)o)->operator!=)(*(const ::G4String*)arg[0]);
}

static  void operator_5368( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4bool)((((const ::G4String*)o)->operator!=)((const char*)arg[0]));
  else   (((const ::G4String*)o)->operator!=)((const char*)arg[0]);
}

static  void converter_5369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::G4String*)o)->operator const char*)());
  else   (((const ::G4String*)o)->operator const char*)();
}

static  void operator_5370( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4SubString)((((::G4String*)o)->operator())(*(::str_size*)arg[0],
    *(::str_size*)arg[1]));
  else   (((::G4String*)o)->operator())(*(::str_size*)arg[0],
    *(::str_size*)arg[1]);
}

static  void method_5371( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (G4int)((((const ::G4String*)o)->compareTo)((const char*)arg[0]));
    else     (((const ::G4String*)o)->compareTo)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (G4int)((((const ::G4String*)o)->compareTo)((const char*)arg[0],
      *(::G4String::caseCompare*)arg[1]));
    else     (((const ::G4String*)o)->compareTo)((const char*)arg[0],
      *(::G4String::caseCompare*)arg[1]);
  }
}

static  void method_5372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (G4int)((((const ::G4String*)o)->compareTo)(*(const ::G4String*)arg[0]));
    else     (((const ::G4String*)o)->compareTo)(*(const ::G4String*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (G4int)((((const ::G4String*)o)->compareTo)(*(const ::G4String*)arg[0],
      *(::G4String::caseCompare*)arg[1]));
    else     (((const ::G4String*)o)->compareTo)(*(const ::G4String*)arg[0],
      *(::G4String::caseCompare*)arg[1]);
  }
}

static  void method_5373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->prepend)((const char*)arg[0]);
  else   (((::G4String*)o)->prepend)((const char*)arg[0]);
}

static  void method_5374( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->append)(*(const ::G4String*)arg[0]);
  else   (((::G4String*)o)->append)(*(const ::G4String*)arg[0]);
}

static  void method_5375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->readLine)(*(::std::istream*)arg[0]);
    else     (((::G4String*)o)->readLine)(*(::std::istream*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->readLine)(*(::std::istream*)arg[0],
      *(::G4bool*)arg[1]);
    else     (((::G4String*)o)->readLine)(*(::std::istream*)arg[0],
      *(::G4bool*)arg[1]);
  }
}

static  void method_5376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->replace)(*(unsigned int*)arg[0],
    *(unsigned int*)arg[1],
    (const char*)arg[2],
    *(unsigned int*)arg[3]);
  else   (((::G4String*)o)->replace)(*(unsigned int*)arg[0],
    *(unsigned int*)arg[1],
    (const char*)arg[2],
    *(unsigned int*)arg[3]);
}

static  void method_5377( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->replace)(*(::str_size*)arg[0],
    *(::str_size*)arg[1],
    (const char*)arg[2]);
  else   (((::G4String*)o)->replace)(*(::str_size*)arg[0],
    *(::str_size*)arg[1],
    (const char*)arg[2]);
}

static  void method_5378( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->remove)(*(::str_size*)arg[0]);
  else   (((::G4String*)o)->remove)(*(::str_size*)arg[0]);
}

static  void method_5379( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->remove)(*(::str_size*)arg[0],
    *(::str_size*)arg[1]);
  else   (((::G4String*)o)->remove)(*(::str_size*)arg[0],
    *(::str_size*)arg[1]);
}

static  void method_5380( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4int)((((const ::G4String*)o)->first)(*(char*)arg[0]));
  else   (((const ::G4String*)o)->first)(*(char*)arg[0]);
}

static  void method_5381( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4int)((((const ::G4String*)o)->last)(*(char*)arg[0]));
  else   (((const ::G4String*)o)->last)(*(char*)arg[0]);
}

static  void method_5382( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4bool)((((const ::G4String*)o)->contains)(*(const ::std::string*)arg[0]));
  else   (((const ::G4String*)o)->contains)(*(const ::std::string*)arg[0]);
}

static  void method_5383( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4bool)((((const ::G4String*)o)->contains)(*(char*)arg[0]));
  else   (((const ::G4String*)o)->contains)(*(char*)arg[0]);
}

static  void method_5384( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (G4String)((((::G4String*)o)->strip)());
    else     (((::G4String*)o)->strip)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (G4String)((((::G4String*)o)->strip)(*(::G4int*)arg[0]));
    else     (((::G4String*)o)->strip)(*(::G4int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (G4String)((((::G4String*)o)->strip)(*(::G4int*)arg[0],
      *(char*)arg[1]));
    else     (((::G4String*)o)->strip)(*(::G4int*)arg[0],
      *(char*)arg[1]);
  }
}

static  void method_5385( void*, void* o, const std::vector<void*>&, void*)
{
  (((::G4String*)o)->toLower)();
}

static  void method_5386( void*, void* o, const std::vector<void*>&, void*)
{
  (((::G4String*)o)->toUpper)();
}

static  void method_5387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4bool)((((const ::G4String*)o)->isNull)());
  else   (((const ::G4String*)o)->isNull)();
}

static  void method_5388( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (str_size)((((const ::G4String*)o)->index)((const char*)arg[0]));
    else     (((const ::G4String*)o)->index)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (str_size)((((const ::G4String*)o)->index)((const char*)arg[0],
      *(::G4int*)arg[1]));
    else     (((const ::G4String*)o)->index)((const char*)arg[0],
      *(::G4int*)arg[1]);
  }
}

static  void method_5389( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (str_size)((((const ::G4String*)o)->index)(*(char*)arg[0]));
    else     (((const ::G4String*)o)->index)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (str_size)((((const ::G4String*)o)->index)(*(char*)arg[0],
      *(::G4int*)arg[1]));
    else     (((const ::G4String*)o)->index)(*(char*)arg[0],
      *(::G4int*)arg[1]);
  }
}

static  void method_5390( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (str_size)((((const ::G4String*)o)->index)(*(const ::G4String*)arg[0],
    *(::str_size*)arg[1],
    *(::str_size*)arg[2],
    *(::G4String::caseCompare*)arg[3]));
  else   (((const ::G4String*)o)->index)(*(const ::G4String*)arg[0],
    *(::str_size*)arg[1],
    *(::str_size*)arg[2],
    *(::G4String::caseCompare*)arg[3]);
}

static  void method_5391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::G4String*)o)->data)());
  else   (((const ::G4String*)o)->data)();
}

static  void method_5392( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4int)((((const ::G4String*)o)->strcasecompare)((const char*)arg[0],
    (const char*)arg[1]));
  else   (((const ::G4String*)o)->strcasecompare)((const char*)arg[0],
    (const char*)arg[1]);
}

static  void method_5393( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (unsigned int)((((const ::G4String*)o)->hash)());
    else     (((const ::G4String*)o)->hash)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (unsigned int)((((const ::G4String*)o)->hash)(*(::G4String::caseCompare*)arg[0]));
    else     (((const ::G4String*)o)->hash)(*(::G4String::caseCompare*)arg[0]);
  }
}

static  void method_5394( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::G4String*)o)->stlhash)());
  else   (((const ::G4String*)o)->stlhash)();
}

static void method_newdel_2224( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::G4String >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::G4String >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::G4String >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::G4String >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::G4String >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>")), ::Reflex::BaseOffset< ::G4String,::std::basic_string<char> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class G4String -------------------------------
void __G4String_db_datamem(Reflex::Class*);
void __G4String_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __G4String_datamem_bld(&__G4String_db_datamem);
Reflex::GenreflexMemberBuilder __G4String_funcmem_bld(&__G4String_db_funcmem);
void __G4String_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("G4String"), typeid(::G4String), sizeof(::G4String), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2384, ::Reflex::BaseOffset< ::G4String, ::std::basic_string<char> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2397, Reflex::Literal("G4String::std_string"))
  .AddEnum(Reflex::Literal("G4String::caseCompare"), Reflex::Literal("exact=0;ignoreCase=1"), &typeid(G4String::caseCompare), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("G4String::stripType"), Reflex::Literal("leading=0;trailing=1;both=2"), &typeid(G4String::stripType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("G4String"), constructor_5348, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_325), Reflex::Literal("G4String"), constructor_5349, 0, "ch", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2830), Reflex::Literal("G4String"), constructor_5350, 0, "astring", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2830, type_2244), Reflex::Literal("G4String"), constructor_5351, 0, "astring;len", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9696), Reflex::Literal("G4String"), constructor_5352, 0, "str", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10810), Reflex::Literal("G4String"), constructor_5353, 0, "str", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7942), Reflex::Literal("G4String"), constructor_5354, 0, "str", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~G4String"), destructor_5355, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2224, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__G4String_funcmem_bld);
}

//------Delayed data member builder for class G4String -------------------
void __G4String_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class G4String -------------------
void __G4String_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10812, type_9696), Reflex::Literal("operator="), operator_5356, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10812, type_7942), Reflex::Literal("operator="), operator_5357, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10812, type_2830), Reflex::Literal("operator="), operator_5358, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_325, type_2244), Reflex::Literal("operator()"), operator_5359, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5925, type_2244), Reflex::Literal("operator()"), operator_5360, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10812, type_10810), Reflex::Literal("operator+="), operator_5361, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10812, type_2830), Reflex::Literal("operator+="), operator_5362, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10812, type_7942), Reflex::Literal("operator+="), operator_5363, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10812, type_6548), Reflex::Literal("operator+="), operator_5364, 0, "ch", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1086, type_9696), Reflex::Literal("operator=="), operator_5365, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1086, type_2830), Reflex::Literal("operator=="), operator_5366, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1086, type_9696), Reflex::Literal("operator!="), operator_5367, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1086, type_2830), Reflex::Literal("operator!="), operator_5368, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2830), Reflex::Literal("operator const char*"), converter_5369, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1751, type_2244, type_2244), Reflex::Literal("operator()"), operator_5370, 0, "start;extent", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231, type_2830, type_5346), Reflex::Literal("compareTo"), method_5371, 0, "str;mode=exact", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231, type_9696, type_5346), Reflex::Literal("compareTo"), method_5372, 0, "str;mode=exact", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10812, type_2830), Reflex::Literal("prepend"), method_5373, 0, "str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10812, type_9696), Reflex::Literal("append"), method_5374, 0, "str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10175, type_10175, type_1086), Reflex::Literal("readLine"), method_5375, 0, "strm;skipWhite=true", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10812, type_147, type_147, type_2830, type_147), Reflex::Literal("replace"), method_5376, 0, "start;nbytes;buff;n2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10812, type_2244, type_2244, type_2830), Reflex::Literal("replace"), method_5377, 0, "pos;n;str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10812, type_2244), Reflex::Literal("remove"), method_5378, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10812, type_2244, type_2244), Reflex::Literal("remove"), method_5379, 0, "pos;N", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231, type_325), Reflex::Literal("first"), method_5380, 0, "ch", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231, type_325), Reflex::Literal("last"), method_5381, 0, "ch", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1086, type_7942), Reflex::Literal("contains"), method_5382, 0, "str", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1086, type_325), Reflex::Literal("contains"), method_5383, 0, "ch", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2224, type_231, type_325), Reflex::Literal("strip"), method_5384, 0, "strip_Type=trailing;ch=' '", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("toLower"), method_5385, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("toUpper"), method_5386, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1086), Reflex::Literal("isNull"), method_5387, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2244, type_2830, type_231), Reflex::Literal("index"), method_5388, 0, "str;pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2244, type_325, type_231), Reflex::Literal("index"), method_5389, 0, "ch;pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2244, type_9696, type_2244, type_2244, type_5346), Reflex::Literal("index"), method_5390, 0, "str;ln;st;", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2830), Reflex::Literal("data"), method_5391, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231, type_2830, type_2830), Reflex::Literal("strcasecompare"), method_5392, 0, "s1;s2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_147, type_5346), Reflex::Literal("hash"), method_5393, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_147), Reflex::Literal("stlhash"), method_5394, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<double,std::allocator<double> > -------------------------------
static void constructor_5960( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>();
  else ::new(mem) ::std::vector<double>();
}

static void constructor_5961( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(const ::std::allocator<double>*)arg[0]);
  else ::new(mem) ::std::vector<double>(*(const ::std::allocator<double>*)arg[0]);
}

static void constructor_5962( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(::size_t*)arg[0]);
  else ::new(mem) ::std::vector<double>(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(::size_t*)arg[0],
      *(const double*)arg[1]);
  else ::new(mem) ::std::vector<double>(*(::size_t*)arg[0],
      *(const double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(::size_t*)arg[0],
      *(const double*)arg[1],
      *(const ::std::allocator<double>*)arg[2]);
  else ::new(mem) ::std::vector<double>(*(::size_t*)arg[0],
      *(const double*)arg[1],
      *(const ::std::allocator<double>*)arg[2]);
  }
}

static void constructor_5963( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(const ::std::vector<double>*)arg[0]);
  else ::new(mem) ::std::vector<double>(*(const ::std::vector<double>*)arg[0]);
}

static void destructor_5964(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<double>*)o)->::std::vector<double>::~vector)();
}
static  void operator_5965( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->operator=)(*(const ::std::vector<double>*)arg[0]);
  else   (((::std::vector<double>*)o)->operator=)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_5966( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->assign)(*(::size_t*)arg[0],
    *(const double*)arg[1]);
}

static  void method_5967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->begin)());
  else   (((::std::vector<double>*)o)->begin)();
}

static  void method_5968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const double*,std::vector<double> >)((((const ::std::vector<double>*)o)->begin)());
  else   (((const ::std::vector<double>*)o)->begin)();
}

static  void method_5969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->end)());
  else   (((::std::vector<double>*)o)->end)();
}

static  void method_5970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const double*,std::vector<double> >)((((const ::std::vector<double>*)o)->end)());
  else   (((const ::std::vector<double>*)o)->end)();
}

static  void method_5975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<double>*)o)->size)());
  else   (((const ::std::vector<double>*)o)->size)();
}

static  void method_5976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<double>*)o)->max_size)());
  else   (((const ::std::vector<double>*)o)->max_size)();
}

static  void method_5977( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<double>*)o)->resize)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<double>*)o)->resize)(*(::size_t*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_5978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<double>*)o)->capacity)());
  else   (((const ::std::vector<double>*)o)->capacity)();
}

static  void method_5979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<double>*)o)->empty)());
  else   (((const ::std::vector<double>*)o)->empty)();
}

static  void method_5980( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void operator_5981( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((::std::vector<double>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void operator_5982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<double>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((const ::std::vector<double>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_5984( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->at)(*(::size_t*)arg[0]);
  else   (((::std::vector<double>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_5985( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<double>*)o)->at)(*(::size_t*)arg[0]);
  else   (((const ::std::vector<double>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_5986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->front)();
  else   (((::std::vector<double>*)o)->front)();
}

static  void method_5987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<double>*)o)->front)();
  else   (((const ::std::vector<double>*)o)->front)();
}

static  void method_5988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->back)();
  else   (((::std::vector<double>*)o)->back)();
}

static  void method_5989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<double>*)o)->back)();
  else   (((const ::std::vector<double>*)o)->back)();
}

static  void method_5990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<double>*)o)->data)());
  else   (((::std::vector<double>*)o)->data)();
}

static  void method_5991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<double>*)o)->data)());
  else   (((const ::std::vector<double>*)o)->data)();
}

static  void method_5992( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->push_back)(*(const double*)arg[0]);
}

static  void method_5993( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<double>*)o)->pop_back)();
}

static  void method_5994( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(const double*)arg[1]));
  else   (((::std::vector<double>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(const double*)arg[1]);
}

static  void method_5995( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(::size_t*)arg[1],
    *(const double*)arg[2]);
}

static  void method_5996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0]));
  else   (((::std::vector<double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0]);
}

static  void method_5997( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[1]));
  else   (((::std::vector<double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[1]);
}

static  void method_5998( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->swap)(*(::std::vector<double>*)arg[0]);
}

static  void method_5999( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<double>*)o)->clear)();
}

static void method_newdel_2362( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<double,std::allocator<double> >")), ::Reflex::BaseOffset< ::std::vector<double>,::std::_Vector_base<double,std::allocator<double> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<double> >::Generate();
  else ::Reflex::Proxy< ::std::vector<double> >::Generate();
}

//------Dictionary for class vector<double,std::allocator<double> > -------------------------------
void __std__vector_double__db_datamem(Reflex::Class*);
void __std__vector_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_double__datamem_bld(&__std__vector_double__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_double__funcmem_bld(&__std__vector_double__db_funcmem);
void __std__vector_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<double>"), typeid(::std::vector<double>), sizeof(::std::vector<double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2686, ::Reflex::BaseOffset< ::std::vector<double>, ::std::_Vector_base<double,std::allocator<double> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_391, Reflex::Literal("std::vector<double>::_Alloc_value_type"))
  .AddTypedef(type_2686, Reflex::Literal("std::vector<double>::_Base"))
  .AddTypedef(type_2486, Reflex::Literal("std::vector<double>::_Tp_alloc_type"))
  .AddTypedef(type_391, Reflex::Literal("std::vector<double>::value_type"))
  .AddTypedef(type_3129, Reflex::Literal("std::vector<double>::pointer"))
  .AddTypedef(type_5947, Reflex::Literal("std::vector<double>::const_pointer"))
  .AddTypedef(type_5949, Reflex::Literal("std::vector<double>::reference"))
  .AddTypedef(type_5951, Reflex::Literal("std::vector<double>::const_reference"))
  .AddTypedef(type_3303, Reflex::Literal("std::vector<double>::iterator"))
  .AddTypedef(type_3304, Reflex::Literal("std::vector<double>::const_iterator"))
  .AddTypedef(type_2589, Reflex::Literal("std::vector<double>::const_reverse_iterator"))
  .AddTypedef(type_2590, Reflex::Literal("std::vector<double>::reverse_iterator"))
  .AddTypedef(type_1441, Reflex::Literal("std::vector<double>::size_type"))
  .AddTypedef(type_1141, Reflex::Literal("std::vector<double>::difference_type"))
  .AddTypedef(type_2486, Reflex::Literal("std::vector<double>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5960, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10994), Reflex::Literal("vector"), constructor_5961, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1441, type_5951, type_10994), Reflex::Literal("vector"), constructor_5962, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10995), Reflex::Literal("vector"), constructor_5963, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5964, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2362, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_double__funcmem_bld);
}

//------Delayed data member builder for class vector<double,std::allocator<double> > -------------------
void __std__vector_double__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<double,std::allocator<double> > -------------------
void __std__vector_double__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10996, type_10995), Reflex::Literal("operator="), operator_5965, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441, type_5951), Reflex::Literal("assign"), method_5966, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3303), Reflex::Literal("begin"), method_5967, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3304), Reflex::Literal("begin"), method_5968, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3303), Reflex::Literal("end"), method_5969, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3304), Reflex::Literal("end"), method_5970, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("size"), method_5975, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("max_size"), method_5976, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441, type_391), Reflex::Literal("resize"), method_5977, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("capacity"), method_5978, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980), Reflex::Literal("empty"), method_5979, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441), Reflex::Literal("reserve"), method_5980, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5949, type_1441), Reflex::Literal("operator[]"), operator_5981, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5951, type_1441), Reflex::Literal("operator[]"), operator_5982, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5949, type_1441), Reflex::Literal("at"), method_5984, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5951, type_1441), Reflex::Literal("at"), method_5985, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5949), Reflex::Literal("front"), method_5986, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5951), Reflex::Literal("front"), method_5987, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5949), Reflex::Literal("back"), method_5988, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5951), Reflex::Literal("back"), method_5989, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3129), Reflex::Literal("data"), method_5990, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5947), Reflex::Literal("data"), method_5991, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_5951), Reflex::Literal("push_back"), method_5992, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("pop_back"), method_5993, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3303, type_3303, type_5951), Reflex::Literal("insert"), method_5994, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_3303, type_1441, type_5951), Reflex::Literal("insert"), method_5995, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3303, type_3303), Reflex::Literal("erase"), method_5996, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3303, type_3303, type_3303), Reflex::Literal("erase"), method_5997, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_10996), Reflex::Literal("swap"), method_5998, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("clear"), method_5999, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<OpNoviceDigi*,std::allocator<OpNoviceDigi*> > -------------------------------
static void constructor_6025( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNoviceDigi*>();
  else ::new(mem) ::std::vector<OpNoviceDigi*>();
}

static void constructor_6026( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNoviceDigi*>(*(const ::std::allocator<OpNoviceDigi*>*)arg[0]);
  else ::new(mem) ::std::vector<OpNoviceDigi*>(*(const ::std::allocator<OpNoviceDigi*>*)arg[0]);
}

static void constructor_6027( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNoviceDigi*>(*(::size_t*)arg[0]);
  else ::new(mem) ::std::vector<OpNoviceDigi*>(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNoviceDigi*>(*(::size_t*)arg[0],
      *(::OpNoviceDigi* const*)arg[1]);
  else ::new(mem) ::std::vector<OpNoviceDigi*>(*(::size_t*)arg[0],
      *(::OpNoviceDigi* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNoviceDigi*>(*(::size_t*)arg[0],
      *(::OpNoviceDigi* const*)arg[1],
      *(const ::std::allocator<OpNoviceDigi*>*)arg[2]);
  else ::new(mem) ::std::vector<OpNoviceDigi*>(*(::size_t*)arg[0],
      *(::OpNoviceDigi* const*)arg[1],
      *(const ::std::allocator<OpNoviceDigi*>*)arg[2]);
  }
}

static void constructor_6028( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNoviceDigi*>(*(const ::std::vector<OpNoviceDigi*>*)arg[0]);
  else ::new(mem) ::std::vector<OpNoviceDigi*>(*(const ::std::vector<OpNoviceDigi*>*)arg[0]);
}

static void destructor_6029(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<OpNoviceDigi*>*)o)->::std::vector<OpNoviceDigi*>::~vector)();
}
static  void operator_6030( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNoviceDigi*>*)o)->operator=)(*(const ::std::vector<OpNoviceDigi*>*)arg[0]);
  else   (((::std::vector<OpNoviceDigi*>*)o)->operator=)(*(const ::std::vector<OpNoviceDigi*>*)arg[0]);
}

static  void method_6031( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNoviceDigi*>*)o)->assign)(*(::size_t*)arg[0],
    *(::OpNoviceDigi* const*)arg[1]);
}

static  void method_6032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >)((((::std::vector<OpNoviceDigi*>*)o)->begin)());
  else   (((::std::vector<OpNoviceDigi*>*)o)->begin)();
}

static  void method_6033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNoviceDigi* const*,std::vector<OpNoviceDigi*> >)((((const ::std::vector<OpNoviceDigi*>*)o)->begin)());
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->begin)();
}

static  void method_6034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >)((((::std::vector<OpNoviceDigi*>*)o)->end)());
  else   (((::std::vector<OpNoviceDigi*>*)o)->end)();
}

static  void method_6035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNoviceDigi* const*,std::vector<OpNoviceDigi*> >)((((const ::std::vector<OpNoviceDigi*>*)o)->end)());
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->end)();
}

static  void method_6040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<OpNoviceDigi*>*)o)->size)());
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->size)();
}

static  void method_6041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<OpNoviceDigi*>*)o)->max_size)());
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->max_size)();
}

static  void method_6042( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<OpNoviceDigi*>*)o)->resize)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<OpNoviceDigi*>*)o)->resize)(*(::size_t*)arg[0],
      (::OpNoviceDigi*)arg[1]);
  }
}

static  void method_6043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<OpNoviceDigi*>*)o)->capacity)());
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->capacity)();
}

static  void method_6044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<OpNoviceDigi*>*)o)->empty)());
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->empty)();
}

static  void method_6045( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNoviceDigi*>*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void operator_6046( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNoviceDigi*>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((::std::vector<OpNoviceDigi*>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void operator_6047( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<OpNoviceDigi*>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_6049( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNoviceDigi*>*)o)->at)(*(::size_t*)arg[0]);
  else   (((::std::vector<OpNoviceDigi*>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_6050( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<OpNoviceDigi*>*)o)->at)(*(::size_t*)arg[0]);
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_6051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNoviceDigi*>*)o)->front)();
  else   (((::std::vector<OpNoviceDigi*>*)o)->front)();
}

static  void method_6052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<OpNoviceDigi*>*)o)->front)();
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->front)();
}

static  void method_6053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNoviceDigi*>*)o)->back)();
  else   (((::std::vector<OpNoviceDigi*>*)o)->back)();
}

static  void method_6054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<OpNoviceDigi*>*)o)->back)();
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->back)();
}

static  void method_6055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<OpNoviceDigi*>*)o)->data)());
  else   (((::std::vector<OpNoviceDigi*>*)o)->data)();
}

static  void method_6056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<OpNoviceDigi*>*)o)->data)());
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->data)();
}

static  void method_6057( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNoviceDigi*>*)o)->push_back)(*(::OpNoviceDigi* const*)arg[0]);
}

static  void method_6058( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<OpNoviceDigi*>*)o)->pop_back)();
}

static  void method_6059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >)((((::std::vector<OpNoviceDigi*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >*)arg[0],
    *(::OpNoviceDigi* const*)arg[1]));
  else   (((::std::vector<OpNoviceDigi*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >*)arg[0],
    *(::OpNoviceDigi* const*)arg[1]);
}

static  void method_6060( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNoviceDigi*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >*)arg[0],
    *(::size_t*)arg[1],
    *(::OpNoviceDigi* const*)arg[2]);
}

static  void method_6061( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >)((((::std::vector<OpNoviceDigi*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >*)arg[0]));
  else   (((::std::vector<OpNoviceDigi*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >*)arg[0]);
}

static  void method_6062( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >)((((::std::vector<OpNoviceDigi*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >*)arg[1]));
  else   (((::std::vector<OpNoviceDigi*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >*)arg[1]);
}

static  void method_6063( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNoviceDigi*>*)o)->swap)(*(::std::vector<OpNoviceDigi*>*)arg[0]);
}

static  void method_6064( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<OpNoviceDigi*>*)o)->clear)();
}

static void method_newdel_2363( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<OpNoviceDigi*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<OpNoviceDigi*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<OpNoviceDigi*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<OpNoviceDigi*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<OpNoviceDigi*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x13( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<OpNoviceDigi*,std::allocator<OpNoviceDigi*> >")), ::Reflex::BaseOffset< ::std::vector<OpNoviceDigi*>,::std::_Vector_base<OpNoviceDigi*,std::allocator<OpNoviceDigi*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<OpNoviceDigi*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<OpNoviceDigi*> >::Generate();
}

//------Dictionary for class vector<OpNoviceDigi*,std::allocator<OpNoviceDigi*> > -------------------------------
void __std__vector_OpNoviceDigip__db_datamem(Reflex::Class*);
void __std__vector_OpNoviceDigip__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_OpNoviceDigip__datamem_bld(&__std__vector_OpNoviceDigip__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_OpNoviceDigip__funcmem_bld(&__std__vector_OpNoviceDigip__db_funcmem);
void __std__vector_OpNoviceDigip__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<OpNoviceDigi*>"), typeid(::std::vector<OpNoviceDigi*>), sizeof(::std::vector<OpNoviceDigi*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2684, ::Reflex::BaseOffset< ::std::vector<OpNoviceDigi*>, ::std::_Vector_base<OpNoviceDigi*,std::allocator<OpNoviceDigi*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_5209, Reflex::Literal("std::vector<OpNoviceDigi*>::_Alloc_value_type"))
  .AddTypedef(type_2684, Reflex::Literal("std::vector<OpNoviceDigi*>::_Base"))
  .AddTypedef(type_2487, Reflex::Literal("std::vector<OpNoviceDigi*>::_Tp_alloc_type"))
  .AddTypedef(type_5209, Reflex::Literal("std::vector<OpNoviceDigi*>::value_type"))
  .AddTypedef(type_6010, Reflex::Literal("std::vector<OpNoviceDigi*>::pointer"))
  .AddTypedef(type_6012, Reflex::Literal("std::vector<OpNoviceDigi*>::const_pointer"))
  .AddTypedef(type_6014, Reflex::Literal("std::vector<OpNoviceDigi*>::reference"))
  .AddTypedef(type_6016, Reflex::Literal("std::vector<OpNoviceDigi*>::const_reference"))
  .AddTypedef(type_3299, Reflex::Literal("std::vector<OpNoviceDigi*>::iterator"))
  .AddTypedef(type_3300, Reflex::Literal("std::vector<OpNoviceDigi*>::const_iterator"))
  .AddTypedef(type_2585, Reflex::Literal("std::vector<OpNoviceDigi*>::const_reverse_iterator"))
  .AddTypedef(type_2586, Reflex::Literal("std::vector<OpNoviceDigi*>::reverse_iterator"))
  .AddTypedef(type_1441, Reflex::Literal("std::vector<OpNoviceDigi*>::size_type"))
  .AddTypedef(type_1141, Reflex::Literal("std::vector<OpNoviceDigi*>::difference_type"))
  .AddTypedef(type_2487, Reflex::Literal("std::vector<OpNoviceDigi*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6025, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10998), Reflex::Literal("vector"), constructor_6026, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1441, type_6016, type_10998), Reflex::Literal("vector"), constructor_6027, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10999), Reflex::Literal("vector"), constructor_6028, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6029, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2363, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_OpNoviceDigip__funcmem_bld);
}

//------Delayed data member builder for class vector<OpNoviceDigi*,std::allocator<OpNoviceDigi*> > -------------------
void __std__vector_OpNoviceDigip__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<OpNoviceDigi*,std::allocator<OpNoviceDigi*> > -------------------
void __std__vector_OpNoviceDigip__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11000, type_10999), Reflex::Literal("operator="), operator_6030, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441, type_6016), Reflex::Literal("assign"), method_6031, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3299), Reflex::Literal("begin"), method_6032, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3300), Reflex::Literal("begin"), method_6033, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3299), Reflex::Literal("end"), method_6034, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3300), Reflex::Literal("end"), method_6035, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("size"), method_6040, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("max_size"), method_6041, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441, type_5209), Reflex::Literal("resize"), method_6042, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("capacity"), method_6043, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980), Reflex::Literal("empty"), method_6044, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441), Reflex::Literal("reserve"), method_6045, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6014, type_1441), Reflex::Literal("operator[]"), operator_6046, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6016, type_1441), Reflex::Literal("operator[]"), operator_6047, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6014, type_1441), Reflex::Literal("at"), method_6049, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6016, type_1441), Reflex::Literal("at"), method_6050, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6014), Reflex::Literal("front"), method_6051, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6016), Reflex::Literal("front"), method_6052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6014), Reflex::Literal("back"), method_6053, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6016), Reflex::Literal("back"), method_6054, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6010), Reflex::Literal("data"), method_6055, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6012), Reflex::Literal("data"), method_6056, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_6016), Reflex::Literal("push_back"), method_6057, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("pop_back"), method_6058, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3299, type_3299, type_6016), Reflex::Literal("insert"), method_6059, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_3299, type_1441, type_6016), Reflex::Literal("insert"), method_6060, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3299, type_3299), Reflex::Literal("erase"), method_6061, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3299, type_3299, type_3299), Reflex::Literal("erase"), method_6062, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_11000), Reflex::Literal("swap"), method_6063, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("clear"), method_6064, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<OpNovicePMTHit*,std::allocator<OpNovicePMTHit*> > -------------------------------
static void constructor_6090( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNovicePMTHit*>();
  else ::new(mem) ::std::vector<OpNovicePMTHit*>();
}

static void constructor_6091( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNovicePMTHit*>(*(const ::std::allocator<OpNovicePMTHit*>*)arg[0]);
  else ::new(mem) ::std::vector<OpNovicePMTHit*>(*(const ::std::allocator<OpNovicePMTHit*>*)arg[0]);
}

static void constructor_6092( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNovicePMTHit*>(*(::size_t*)arg[0]);
  else ::new(mem) ::std::vector<OpNovicePMTHit*>(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNovicePMTHit*>(*(::size_t*)arg[0],
      *(::OpNovicePMTHit* const*)arg[1]);
  else ::new(mem) ::std::vector<OpNovicePMTHit*>(*(::size_t*)arg[0],
      *(::OpNovicePMTHit* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNovicePMTHit*>(*(::size_t*)arg[0],
      *(::OpNovicePMTHit* const*)arg[1],
      *(const ::std::allocator<OpNovicePMTHit*>*)arg[2]);
  else ::new(mem) ::std::vector<OpNovicePMTHit*>(*(::size_t*)arg[0],
      *(::OpNovicePMTHit* const*)arg[1],
      *(const ::std::allocator<OpNovicePMTHit*>*)arg[2]);
  }
}

static void constructor_6093( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNovicePMTHit*>(*(const ::std::vector<OpNovicePMTHit*>*)arg[0]);
  else ::new(mem) ::std::vector<OpNovicePMTHit*>(*(const ::std::vector<OpNovicePMTHit*>*)arg[0]);
}

static void destructor_6094(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<OpNovicePMTHit*>*)o)->::std::vector<OpNovicePMTHit*>::~vector)();
}
static  void operator_6095( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNovicePMTHit*>*)o)->operator=)(*(const ::std::vector<OpNovicePMTHit*>*)arg[0]);
  else   (((::std::vector<OpNovicePMTHit*>*)o)->operator=)(*(const ::std::vector<OpNovicePMTHit*>*)arg[0]);
}

static  void method_6096( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNovicePMTHit*>*)o)->assign)(*(::size_t*)arg[0],
    *(::OpNovicePMTHit* const*)arg[1]);
}

static  void method_6097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >)((((::std::vector<OpNovicePMTHit*>*)o)->begin)());
  else   (((::std::vector<OpNovicePMTHit*>*)o)->begin)();
}

static  void method_6098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNovicePMTHit* const*,std::vector<OpNovicePMTHit*> >)((((const ::std::vector<OpNovicePMTHit*>*)o)->begin)());
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->begin)();
}

static  void method_6099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >)((((::std::vector<OpNovicePMTHit*>*)o)->end)());
  else   (((::std::vector<OpNovicePMTHit*>*)o)->end)();
}

static  void method_6100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNovicePMTHit* const*,std::vector<OpNovicePMTHit*> >)((((const ::std::vector<OpNovicePMTHit*>*)o)->end)());
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->end)();
}

static  void method_6105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<OpNovicePMTHit*>*)o)->size)());
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->size)();
}

static  void method_6106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<OpNovicePMTHit*>*)o)->max_size)());
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->max_size)();
}

static  void method_6107( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<OpNovicePMTHit*>*)o)->resize)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<OpNovicePMTHit*>*)o)->resize)(*(::size_t*)arg[0],
      (::OpNovicePMTHit*)arg[1]);
  }
}

static  void method_6108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<OpNovicePMTHit*>*)o)->capacity)());
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->capacity)();
}

static  void method_6109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<OpNovicePMTHit*>*)o)->empty)());
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->empty)();
}

static  void method_6110( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNovicePMTHit*>*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void operator_6111( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNovicePMTHit*>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((::std::vector<OpNovicePMTHit*>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void operator_6112( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<OpNovicePMTHit*>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_6114( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNovicePMTHit*>*)o)->at)(*(::size_t*)arg[0]);
  else   (((::std::vector<OpNovicePMTHit*>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_6115( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<OpNovicePMTHit*>*)o)->at)(*(::size_t*)arg[0]);
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_6116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNovicePMTHit*>*)o)->front)();
  else   (((::std::vector<OpNovicePMTHit*>*)o)->front)();
}

static  void method_6117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<OpNovicePMTHit*>*)o)->front)();
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->front)();
}

static  void method_6118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNovicePMTHit*>*)o)->back)();
  else   (((::std::vector<OpNovicePMTHit*>*)o)->back)();
}

static  void method_6119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<OpNovicePMTHit*>*)o)->back)();
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->back)();
}

static  void method_6120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<OpNovicePMTHit*>*)o)->data)());
  else   (((::std::vector<OpNovicePMTHit*>*)o)->data)();
}

static  void method_6121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<OpNovicePMTHit*>*)o)->data)());
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->data)();
}

static  void method_6122( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNovicePMTHit*>*)o)->push_back)(*(::OpNovicePMTHit* const*)arg[0]);
}

static  void method_6123( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<OpNovicePMTHit*>*)o)->pop_back)();
}

static  void method_6124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >)((((::std::vector<OpNovicePMTHit*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >*)arg[0],
    *(::OpNovicePMTHit* const*)arg[1]));
  else   (((::std::vector<OpNovicePMTHit*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >*)arg[0],
    *(::OpNovicePMTHit* const*)arg[1]);
}

static  void method_6125( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNovicePMTHit*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >*)arg[0],
    *(::size_t*)arg[1],
    *(::OpNovicePMTHit* const*)arg[2]);
}

static  void method_6126( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >)((((::std::vector<OpNovicePMTHit*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >*)arg[0]));
  else   (((::std::vector<OpNovicePMTHit*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >*)arg[0]);
}

static  void method_6127( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >)((((::std::vector<OpNovicePMTHit*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >*)arg[1]));
  else   (((::std::vector<OpNovicePMTHit*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >*)arg[1]);
}

static  void method_6128( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNovicePMTHit*>*)o)->swap)(*(::std::vector<OpNovicePMTHit*>*)arg[0]);
}

static  void method_6129( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<OpNovicePMTHit*>*)o)->clear)();
}

static void method_newdel_2364( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<OpNovicePMTHit*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<OpNovicePMTHit*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<OpNovicePMTHit*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<OpNovicePMTHit*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<OpNovicePMTHit*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<OpNovicePMTHit*,std::allocator<OpNovicePMTHit*> >")), ::Reflex::BaseOffset< ::std::vector<OpNovicePMTHit*>,::std::_Vector_base<OpNovicePMTHit*,std::allocator<OpNovicePMTHit*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<OpNovicePMTHit*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<OpNovicePMTHit*> >::Generate();
}

//------Dictionary for class vector<OpNovicePMTHit*,std::allocator<OpNovicePMTHit*> > -------------------------------
void __std__vector_OpNovicePMTHitp__db_datamem(Reflex::Class*);
void __std__vector_OpNovicePMTHitp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_OpNovicePMTHitp__datamem_bld(&__std__vector_OpNovicePMTHitp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_OpNovicePMTHitp__funcmem_bld(&__std__vector_OpNovicePMTHitp__db_funcmem);
void __std__vector_OpNovicePMTHitp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<OpNovicePMTHit*>"), typeid(::std::vector<OpNovicePMTHit*>), sizeof(::std::vector<OpNovicePMTHit*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2685, ::Reflex::BaseOffset< ::std::vector<OpNovicePMTHit*>, ::std::_Vector_base<OpNovicePMTHit*,std::allocator<OpNovicePMTHit*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_5265, Reflex::Literal("std::vector<OpNovicePMTHit*>::_Alloc_value_type"))
  .AddTypedef(type_2685, Reflex::Literal("std::vector<OpNovicePMTHit*>::_Base"))
  .AddTypedef(type_2488, Reflex::Literal("std::vector<OpNovicePMTHit*>::_Tp_alloc_type"))
  .AddTypedef(type_5265, Reflex::Literal("std::vector<OpNovicePMTHit*>::value_type"))
  .AddTypedef(type_6075, Reflex::Literal("std::vector<OpNovicePMTHit*>::pointer"))
  .AddTypedef(type_6077, Reflex::Literal("std::vector<OpNovicePMTHit*>::const_pointer"))
  .AddTypedef(type_6079, Reflex::Literal("std::vector<OpNovicePMTHit*>::reference"))
  .AddTypedef(type_6081, Reflex::Literal("std::vector<OpNovicePMTHit*>::const_reference"))
  .AddTypedef(type_3301, Reflex::Literal("std::vector<OpNovicePMTHit*>::iterator"))
  .AddTypedef(type_3302, Reflex::Literal("std::vector<OpNovicePMTHit*>::const_iterator"))
  .AddTypedef(type_2587, Reflex::Literal("std::vector<OpNovicePMTHit*>::const_reverse_iterator"))
  .AddTypedef(type_2588, Reflex::Literal("std::vector<OpNovicePMTHit*>::reverse_iterator"))
  .AddTypedef(type_1441, Reflex::Literal("std::vector<OpNovicePMTHit*>::size_type"))
  .AddTypedef(type_1141, Reflex::Literal("std::vector<OpNovicePMTHit*>::difference_type"))
  .AddTypedef(type_2488, Reflex::Literal("std::vector<OpNovicePMTHit*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6090, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11002), Reflex::Literal("vector"), constructor_6091, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1441, type_6081, type_11002), Reflex::Literal("vector"), constructor_6092, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11003), Reflex::Literal("vector"), constructor_6093, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6094, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2364, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_OpNovicePMTHitp__funcmem_bld);
}

//------Delayed data member builder for class vector<OpNovicePMTHit*,std::allocator<OpNovicePMTHit*> > -------------------
void __std__vector_OpNovicePMTHitp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<OpNovicePMTHit*,std::allocator<OpNovicePMTHit*> > -------------------
void __std__vector_OpNovicePMTHitp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11004, type_11003), Reflex::Literal("operator="), operator_6095, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441, type_6081), Reflex::Literal("assign"), method_6096, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3301), Reflex::Literal("begin"), method_6097, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3302), Reflex::Literal("begin"), method_6098, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3301), Reflex::Literal("end"), method_6099, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3302), Reflex::Literal("end"), method_6100, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("size"), method_6105, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("max_size"), method_6106, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441, type_5265), Reflex::Literal("resize"), method_6107, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("capacity"), method_6108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980), Reflex::Literal("empty"), method_6109, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441), Reflex::Literal("reserve"), method_6110, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6079, type_1441), Reflex::Literal("operator[]"), operator_6111, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6081, type_1441), Reflex::Literal("operator[]"), operator_6112, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6079, type_1441), Reflex::Literal("at"), method_6114, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6081, type_1441), Reflex::Literal("at"), method_6115, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6079), Reflex::Literal("front"), method_6116, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6081), Reflex::Literal("front"), method_6117, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6079), Reflex::Literal("back"), method_6118, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6081), Reflex::Literal("back"), method_6119, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6075), Reflex::Literal("data"), method_6120, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6077), Reflex::Literal("data"), method_6121, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_6081), Reflex::Literal("push_back"), method_6122, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("pop_back"), method_6123, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3301, type_3301, type_6081), Reflex::Literal("insert"), method_6124, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_3301, type_1441, type_6081), Reflex::Literal("insert"), method_6125, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3301, type_3301), Reflex::Literal("erase"), method_6126, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3301, type_3301, type_3301), Reflex::Literal("erase"), method_6127, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_11004), Reflex::Literal("swap"), method_6128, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("clear"), method_6129, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------------------
static void constructor_6580( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>();
  else ::new(mem) ::std::basic_string<char>();
}

static void constructor_6581( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::allocator<char>*)arg[0]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::allocator<char>*)arg[0]);
}

static void constructor_6582( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0]);
}

static void constructor_6583( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1],
      *(::size_t*)arg[2]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1],
      *(::size_t*)arg[2]);
  }
}

static void constructor_6584( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1],
      *(::size_t*)arg[2],
      *(const ::std::allocator<char>*)arg[3]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1],
      *(::size_t*)arg[2],
      *(const ::std::allocator<char>*)arg[3]);
}

static void constructor_6585( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::size_t*)arg[1]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::size_t*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::size_t*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  }
}

static void constructor_6586( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(const ::std::allocator<char>*)arg[1]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(const ::std::allocator<char>*)arg[1]);
  }
}

static void constructor_6587( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(::size_t*)arg[0],
      *(char*)arg[1]);
  else ::new(mem) ::std::basic_string<char>(*(::size_t*)arg[0],
      *(char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(::size_t*)arg[0],
      *(char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  else ::new(mem) ::std::basic_string<char>(*(::size_t*)arg[0],
      *(char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  }
}

static void destructor_6588(void*, void * o, const std::vector<void*>&, void *) {
(((::std::basic_string<char>*)o)->::std::basic_string<char>::~basic_string)();
}
static  void operator_6589( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void operator_6590( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)((const char*)arg[0]);
}

static  void operator_6591( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)(*(char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)(*(char*)arg[0]);
}

static  void method_6592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->begin)());
  else   (((::std::basic_string<char>*)o)->begin)();
}

static  void method_6593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >)((((const ::std::basic_string<char>*)o)->begin)());
  else   (((const ::std::basic_string<char>*)o)->begin)();
}

static  void method_6594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->end)());
  else   (((::std::basic_string<char>*)o)->end)();
}

static  void method_6595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >)((((const ::std::basic_string<char>*)o)->end)());
  else   (((const ::std::basic_string<char>*)o)->end)();
}

static  void method_6600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->size)());
  else   (((const ::std::basic_string<char>*)o)->size)();
}

static  void method_6601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->length)());
  else   (((const ::std::basic_string<char>*)o)->length)();
}

static  void method_6602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->max_size)());
  else   (((const ::std::basic_string<char>*)o)->max_size)();
}

static  void method_6603( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->resize)(*(::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_6604( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->resize)(*(::size_t*)arg[0]);
}

static  void method_6605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->capacity)());
  else   (((const ::std::basic_string<char>*)o)->capacity)();
}

static  void method_6606( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::std::basic_string<char>*)o)->reserve)();
  }
  else if ( arg.size() == 1 ) { 
    (((::std::basic_string<char>*)o)->reserve)(*(::size_t*)arg[0]);
  }
}

static  void method_6607( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::basic_string<char>*)o)->clear)();
}

static  void method_6608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::basic_string<char>*)o)->empty)());
  else   (((const ::std::basic_string<char>*)o)->empty)();
}

static  void operator_6609( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::basic_string<char>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((const ::std::basic_string<char>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void operator_6610( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_6611( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::basic_string<char>*)o)->at)(*(::size_t*)arg[0]);
  else   (((const ::std::basic_string<char>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_6612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->at)(*(::size_t*)arg[0]);
  else   (((::std::basic_string<char>*)o)->at)(*(::size_t*)arg[0]);
}

static  void operator_6613( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void operator_6614( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)((const char*)arg[0]);
}

static  void operator_6615( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)(*(char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)(*(char*)arg[0]);
}

static  void method_6616( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_6617( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_6618( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)((const char*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::std::basic_string<char>*)o)->append)((const char*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_6619( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->append)((const char*)arg[0]);
}

static  void method_6620( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(::size_t*)arg[0],
    *(char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->append)(*(::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_6621( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->push_back)(*(char*)arg[0]);
}

static  void method_6622( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_6623( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_6624( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)((const char*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::std::basic_string<char>*)o)->assign)((const char*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_6625( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->assign)((const char*)arg[0]);
}

static  void method_6626( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(::size_t*)arg[0],
    *(char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->assign)(*(::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_6627( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::size_t*)arg[1],
    *(char*)arg[2]);
}

static  void method_6628( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_6629( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1],
    *(::size_t*)arg[2],
    *(::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1],
    *(::size_t*)arg[2],
    *(::size_t*)arg[3]);
}

static  void method_6630( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    (const char*)arg[1],
    *(::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    (const char*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_6631( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    (const char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_6632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(char*)arg[2]);
}

static  void method_6633( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(char*)arg[1]));
  else   (((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(char*)arg[1]);
}

static  void method_6634( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)();
    else     (((::std::basic_string<char>*)o)->erase)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)(*(::size_t*)arg[0]);
    else     (((::std::basic_string<char>*)o)->erase)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)(*(::size_t*)arg[0],
      *(::size_t*)arg[1]);
    else     (((::std::basic_string<char>*)o)->erase)(*(::size_t*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6635( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0]));
  else   (((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0]);
}

static  void method_6636( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1]));
  else   (((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1]);
}

static  void method_6637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_6638( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::size_t*)arg[3],
    *(::size_t*)arg[4]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::size_t*)arg[3],
    *(::size_t*)arg[4]);
}

static  void method_6639( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2],
    *(::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2],
    *(::size_t*)arg[3]);
}

static  void method_6640( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2]);
}

static  void method_6641( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2],
    *(char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2],
    *(char*)arg[3]);
}

static  void method_6642( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_6643( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    *(::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    *(::size_t*)arg[3]);
}

static  void method_6644( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2]);
}

static  void method_6645( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::size_t*)arg[2],
    *(char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::size_t*)arg[2],
    *(char*)arg[3]);
}

static  void method_6646( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (char*)arg[2],
    (char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (char*)arg[2],
    (char*)arg[3]);
}

static  void method_6647( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    (const char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    (const char*)arg[3]);
}

static  void method_6648( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[3]);
}

static  void method_6649( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[3]);
}

static  void method_6653( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::size_t*)arg[1],
      *(::size_t*)arg[2]));
    else     (((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::size_t*)arg[1],
      *(::size_t*)arg[2]);
  }
}

static  void method_6654( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->swap)(*(::std::basic_string<char>*)arg[0]);
}

static  void method_6655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::basic_string<char>*)o)->c_str)());
  else   (((const ::std::basic_string<char>*)o)->c_str)();
}

static  void method_6656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::basic_string<char>*)o)->data)());
  else   (((const ::std::basic_string<char>*)o)->data)();
}

static  void method_6657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<char>)((((const ::std::basic_string<char>*)o)->get_allocator)());
  else   (((const ::std::basic_string<char>*)o)->get_allocator)();
}

static  void method_6658( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_6659( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6662( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6663( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_6664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6667( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_6668( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6669( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6670( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6671( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_6672( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6673( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6674( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6675( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_6676( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6677( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6678( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6679( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_6680( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6681( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6682( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)());
    else     (((const ::std::basic_string<char>*)o)->substr)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)(*(::size_t*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->substr)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)(*(::size_t*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->substr)(*(::size_t*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6683( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_6684( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_6685( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::size_t*)arg[3],
    *(::size_t*)arg[4]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::size_t*)arg[3],
    *(::size_t*)arg[4]);
}

static  void method_6686( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)((const char*)arg[0]));
  else   (((const ::std::basic_string<char>*)o)->compare)((const char*)arg[0]);
}

static  void method_6687( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2]);
}

static  void method_6688( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2],
    *(::size_t*)arg[3]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2],
    *(::size_t*)arg[3]);
}

static void method_newdel_2384( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------------------
void __std__basic_string_char__db_datamem(Reflex::Class*);
void __std__basic_string_char__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__basic_string_char__datamem_bld(&__std__basic_string_char__db_datamem);
Reflex::GenreflexMemberBuilder __std__basic_string_char__funcmem_bld(&__std__basic_string_char__db_funcmem);
void __std__basic_string_char__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::basic_string<char>"), typeid(::std::basic_string<char>), sizeof(::std::basic_string<char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_2494, Reflex::Literal("std::basic_string<char>::_CharT_alloc_type"))
  .AddTypedef(type_2544, Reflex::Literal("std::basic_string<char>::traits_type"))
  .AddTypedef(type_325, Reflex::Literal("std::basic_string<char>::value_type"))
  .AddTypedef(type_2494, Reflex::Literal("std::basic_string<char>::allocator_type"))
  .AddTypedef(type_1441, Reflex::Literal("std::basic_string<char>::size_type"))
  .AddTypedef(type_1141, Reflex::Literal("std::basic_string<char>::difference_type"))
  .AddTypedef(type_5925, Reflex::Literal("std::basic_string<char>::reference"))
  .AddTypedef(type_6548, Reflex::Literal("std::basic_string<char>::const_reference"))
  .AddTypedef(type_1888, Reflex::Literal("std::basic_string<char>::pointer"))
  .AddTypedef(type_2830, Reflex::Literal("std::basic_string<char>::const_pointer"))
  .AddTypedef(type_3315, Reflex::Literal("std::basic_string<char>::iterator"))
  .AddTypedef(type_3318, Reflex::Literal("std::basic_string<char>::const_iterator"))
  .AddTypedef(type_2607, Reflex::Literal("std::basic_string<char>::const_reverse_iterator"))
  .AddTypedef(type_2608, Reflex::Literal("std::basic_string<char>::reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("basic_string"), constructor_6580, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11070), Reflex::Literal("basic_string"), constructor_6581, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8034), Reflex::Literal("basic_string"), constructor_6582, 0, "__str", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8034, type_1441, type_1441), Reflex::Literal("basic_string"), constructor_6583, 0, "__str;__pos;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8034, type_1441, type_1441, type_11070), Reflex::Literal("basic_string"), constructor_6584, 0, "__str;__pos;__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2830, type_1441, type_11070), Reflex::Literal("basic_string"), constructor_6585, 0, "__s;__n;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2830, type_11070), Reflex::Literal("basic_string"), constructor_6586, 0, "__s;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1441, type_325, type_11070), Reflex::Literal("basic_string"), constructor_6587, 0, "__n;__c;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~basic_string"), destructor_6588, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2384, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__basic_string_char__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__basic_string_char__funcmem_bld);
}

//------Delayed data member builder for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------
void __std__basic_string_char__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6558, Reflex::Literal("_M_dataplus"), OffsetOf(__shadow__::__std__basic_string_char_, _M_dataplus), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------
void __std__basic_string_char__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_8034), Reflex::Literal("operator="), operator_6589, 0, "__str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_2830), Reflex::Literal("operator="), operator_6590, 0, "__s", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_325), Reflex::Literal("operator="), operator_6591, 0, "__c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3315), Reflex::Literal("begin"), method_6592, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3318), Reflex::Literal("begin"), method_6593, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3315), Reflex::Literal("end"), method_6594, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3318), Reflex::Literal("end"), method_6595, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("size"), method_6600, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("length"), method_6601, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("max_size"), method_6602, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441, type_325), Reflex::Literal("resize"), method_6603, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441), Reflex::Literal("resize"), method_6604, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("capacity"), method_6605, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441), Reflex::Literal("reserve"), method_6606, 0, "__res=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("clear"), method_6607, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980), Reflex::Literal("empty"), method_6608, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6548, type_1441), Reflex::Literal("operator[]"), operator_6609, 0, "__pos", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5925, type_1441), Reflex::Literal("operator[]"), operator_6610, 0, "__pos", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6548, type_1441), Reflex::Literal("at"), method_6611, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5925, type_1441), Reflex::Literal("at"), method_6612, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_8034), Reflex::Literal("operator+="), operator_6613, 0, "__str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_2830), Reflex::Literal("operator+="), operator_6614, 0, "__s", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_325), Reflex::Literal("operator+="), operator_6615, 0, "__c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_8034), Reflex::Literal("append"), method_6616, 0, "__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_8034, type_1441, type_1441), Reflex::Literal("append"), method_6617, 0, "__str;__pos;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_2830, type_1441), Reflex::Literal("append"), method_6618, 0, "__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_2830), Reflex::Literal("append"), method_6619, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_1441, type_325), Reflex::Literal("append"), method_6620, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_325), Reflex::Literal("push_back"), method_6621, 0, "__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_8034), Reflex::Literal("assign"), method_6622, 0, "__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_8034, type_1441, type_1441), Reflex::Literal("assign"), method_6623, 0, "__str;__pos;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_2830, type_1441), Reflex::Literal("assign"), method_6624, 0, "__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_2830), Reflex::Literal("assign"), method_6625, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_1441, type_325), Reflex::Literal("assign"), method_6626, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_3315, type_1441, type_325), Reflex::Literal("insert"), method_6627, 0, "__p;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_1441, type_8034), Reflex::Literal("insert"), method_6628, 0, "__pos1;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_1441, type_8034, type_1441, type_1441), Reflex::Literal("insert"), method_6629, 0, "__pos1;__str;__pos2;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_1441, type_2830, type_1441), Reflex::Literal("insert"), method_6630, 0, "__pos;__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_1441, type_2830), Reflex::Literal("insert"), method_6631, 0, "__pos;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_1441, type_1441, type_325), Reflex::Literal("insert"), method_6632, 0, "__pos;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3315, type_3315, type_325), Reflex::Literal("insert"), method_6633, 0, "__p;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_1441, type_1441), Reflex::Literal("erase"), method_6634, 0, "__pos=0;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3315, type_3315), Reflex::Literal("erase"), method_6635, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3315, type_3315, type_3315), Reflex::Literal("erase"), method_6636, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_1441, type_1441, type_8034), Reflex::Literal("replace"), method_6637, 0, "__pos;__n;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_1441, type_1441, type_8034, type_1441, type_1441), Reflex::Literal("replace"), method_6638, 0, "__pos1;__n1;__str;__pos2;__n2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_1441, type_1441, type_2830, type_1441), Reflex::Literal("replace"), method_6639, 0, "__pos;__n1;__s;__n2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_1441, type_1441, type_2830), Reflex::Literal("replace"), method_6640, 0, "__pos;__n1;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_1441, type_1441, type_1441, type_325), Reflex::Literal("replace"), method_6641, 0, "__pos;__n1;__n2;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_3315, type_3315, type_8034), Reflex::Literal("replace"), method_6642, 0, "__i1;__i2;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_3315, type_3315, type_2830, type_1441), Reflex::Literal("replace"), method_6643, 0, "__i1;__i2;__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_3315, type_3315, type_2830), Reflex::Literal("replace"), method_6644, 0, "__i1;__i2;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_3315, type_3315, type_1441, type_325), Reflex::Literal("replace"), method_6645, 0, "__i1;__i2;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_3315, type_3315, type_1888, type_1888), Reflex::Literal("replace"), method_6646, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_3315, type_3315, type_2830, type_2830), Reflex::Literal("replace"), method_6647, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_3315, type_3315, type_3315, type_3315), Reflex::Literal("replace"), method_6648, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7949, type_3315, type_3315, type_3318, type_3318), Reflex::Literal("replace"), method_6649, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_1888, type_1441, type_1441), Reflex::Literal("copy"), method_6653, 0, "__s;__n;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_7949), Reflex::Literal("swap"), method_6654, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2830), Reflex::Literal("c_str"), method_6655, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2830), Reflex::Literal("data"), method_6656, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2494), Reflex::Literal("get_allocator"), method_6657, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2830, type_1441, type_1441), Reflex::Literal("find"), method_6658, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_8034, type_1441), Reflex::Literal("find"), method_6659, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2830, type_1441), Reflex::Literal("find"), method_6660, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_325, type_1441), Reflex::Literal("find"), method_6661, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_8034, type_1441), Reflex::Literal("rfind"), method_6662, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2830, type_1441, type_1441), Reflex::Literal("rfind"), method_6663, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2830, type_1441), Reflex::Literal("rfind"), method_6664, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_325, type_1441), Reflex::Literal("rfind"), method_6665, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_8034, type_1441), Reflex::Literal("find_first_of"), method_6666, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2830, type_1441, type_1441), Reflex::Literal("find_first_of"), method_6667, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2830, type_1441), Reflex::Literal("find_first_of"), method_6668, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_325, type_1441), Reflex::Literal("find_first_of"), method_6669, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_8034, type_1441), Reflex::Literal("find_last_of"), method_6670, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2830, type_1441, type_1441), Reflex::Literal("find_last_of"), method_6671, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2830, type_1441), Reflex::Literal("find_last_of"), method_6672, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_325, type_1441), Reflex::Literal("find_last_of"), method_6673, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_8034, type_1441), Reflex::Literal("find_first_not_of"), method_6674, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2830, type_1441, type_1441), Reflex::Literal("find_first_not_of"), method_6675, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2830, type_1441), Reflex::Literal("find_first_not_of"), method_6676, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_325, type_1441), Reflex::Literal("find_first_not_of"), method_6677, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_8034, type_1441), Reflex::Literal("find_last_not_of"), method_6678, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2830, type_1441, type_1441), Reflex::Literal("find_last_not_of"), method_6679, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2830, type_1441), Reflex::Literal("find_last_not_of"), method_6680, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_325, type_1441), Reflex::Literal("find_last_not_of"), method_6681, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2384, type_1441, type_1441), Reflex::Literal("substr"), method_6682, 0, "__pos=0;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45, type_8034), Reflex::Literal("compare"), method_6683, 0, "__str", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45, type_1441, type_1441, type_8034), Reflex::Literal("compare"), method_6684, 0, "__pos;__n;__str", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45, type_1441, type_1441, type_8034, type_1441, type_1441), Reflex::Literal("compare"), method_6685, 0, "__pos1;__n1;__str;__pos2;__n2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45, type_2830), Reflex::Literal("compare"), method_6686, 0, "__s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45, type_1441, type_1441, type_2830), Reflex::Literal("compare"), method_6687, 0, "__pos;__n1;__s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45, type_1441, type_1441, type_2830, type_1441), Reflex::Literal("compare"), method_6688, 0, "__pos;__n1;__s;__n2", ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __OpNoviceDigi_dict(); 
      __CLHEP__Hep3Vector_dict(); 
      __G4VDigi_dict(); 
      __OpNovicePMTHit_dict(); 
      __G4VHit_dict(); 
      __G4String_dict(); 
      __std__vector_double__dict(); 
      __std__vector_OpNoviceDigip__dict(); 
      __std__vector_OpNovicePMTHitp__dict(); 
      __std__basic_string_char__dict(); 
    }
    ~Dictionaries() {
      type_487.Unload(); // class OpNoviceDigi 
      type_1016.Unload(); // class CLHEP::Hep3Vector 
      type_1035.Unload(); // class G4VDigi 
      type_1659.Unload(); // class OpNovicePMTHit 
      type_1760.Unload(); // class G4VHit 
      type_2224.Unload(); // class G4String 
      type_2362.Unload(); // class std::vector<double> 
      type_2363.Unload(); // class std::vector<OpNoviceDigi*> 
      type_2364.Unload(); // class std::vector<OpNovicePMTHit*> 
      type_2384.Unload(); // class std::basic_string<char> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
