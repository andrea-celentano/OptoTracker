// Generated at Thu Mar  3 22:03:26 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/usr/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/usr/bin/c++"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic "
  GCCXML_EXECUTABLE="/usr/bin/gccxml_cc1plus"
  GCCXML_CPP="/usr/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__FLT_MIN__='1.17549435e-38F' -D__CHAR_BIT__='8' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='4.9406564584124654e-324' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__LP64__='1' -D__GNUC_PATCHLEVEL__='7' -D__DEC64_MAX_EXP__='385' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__unix='1' -D__LDBL_MAX_EXP__='16384' -D__linux__='1' -D__SCHAR_MAX__='127' -D__DBL_DIG__='15' -D_FORTIFY_SOURCE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209290e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__SIZEOF_LONG__='8' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='1.7976931348623157e+308' -D__DBL_HAS_INFINITY__='1' -D__DEC32_MIN_EXP__='(-94)' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__DBL_MIN__='2.2250738585072014e-308' -D__FLT_MIN_10_EXP__='(-37)' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__DBL_HAS_DENORM__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.4.7 20120313 (Red Hat 4.4.7-16)"' -D__DEC64_EPSILON__='1E-15DD' -D__DEC128_MIN_EXP__='(-6142)' -Dunix='1' -D__SIZE_TYPE__='long unsigned int' -D__ELF__='1' -D__FLT_RADIX__='2' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__GNUC_RH_RELEASE__='16' -D__k8='1' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__DEC64_MANT_DIG__='16' -D__DEC32_MAX_EXP__='97' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__k8__='1' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__DEC64_MIN_EXP__='(-382)' -D__FLT_DIG__='6' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__FLT_MAX_EXP__='128' -D__DBL_MANT_DIG__='53' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__SSP__='1' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='2.2204460492503131e-16' -D_LP64='1' -D__SIZEOF_WCHAR_T__='4' -D__DEC_EVAL_METHOD__='2' -D__INTMAX_MAX__='9223372036854775807L' -D__FLT_DENORM_MIN__='1.40129846e-45F' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282347e+38F' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='4' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__GNUC_GNU_INLINE__='1' -D_GNU_SOURCE='1' -iwrapper"/usr/share/gccxml-0.9/GCC/4.4" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/backward" -isystem"/usr/local/include" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/usr/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.4.7 20120313 (Red Hat 4.4.7-16)
Copyright (C) 2010 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/work/OptoTracker/packages/Maroc/include/MarocClasses.hh"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::Type type_47 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_177 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_952 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1628 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_283 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_361 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_349 = ::Reflex::TypeBuilder(Reflex::Literal("TClass"));
  ::Reflex::Type type_978 = ::Reflex::TypeBuilder(Reflex::Literal("TObject"));
  ::Reflex::Type type_1289 = ::Reflex::TypeBuilder(Reflex::Literal("TBuffer"));
  ::Reflex::Type type_2209 = ::Reflex::TypeBuilder(Reflex::Literal("TMarocHit"));
  ::Reflex::Type type_677 = ::Reflex::TypeBuilder(Reflex::Literal("TEventHeader"));
  ::Reflex::Type type_115 = ::Reflex::TypeBuilder(Reflex::Literal("TMemberInspector"));
  ::Reflex::Type type_902 = ::Reflex::TypeBuilder(Reflex::Literal("TRealSetupHandler"));
  ::Reflex::Type type_2556 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,int>"));
  ::Reflex::Type type_1768 = ::Reflex::TypeBuilder(Reflex::Literal("TMarocEventHeader"));
  ::Reflex::Type type_1243 = ::Reflex::TypeBuilder(Reflex::Literal("TMarocSetupHandler"));
  ::Reflex::Type type_2377 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_9118 = ::Reflex::ReferenceBuilder(type_1243);
  ::Reflex::Type type_1243c = ::Reflex::ConstBuilder(type_1243);
  ::Reflex::Type type_9119 = ::Reflex::ReferenceBuilder(type_1243c);
  ::Reflex::Type type_2390 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2377);
  ::Reflex::Type type_820 = ::Reflex::PointerBuilder(type_349);
  ::Reflex::Type type_1628c = ::Reflex::ConstBuilder(type_1628);
  ::Reflex::Type type_2794 = ::Reflex::PointerBuilder(type_1628c);
  ::Reflex::Type type_1691 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Version_t"), type_283);
  ::Reflex::Type type_8925 = ::Reflex::ReferenceBuilder(type_115);
  ::Reflex::Type type_4279 = ::Reflex::ReferenceBuilder(type_1289);
  ::Reflex::Type type_9182 = ::Reflex::ReferenceBuilder(type_1768);
  ::Reflex::Type type_1768c = ::Reflex::ConstBuilder(type_1768);
  ::Reflex::Type type_9183 = ::Reflex::ReferenceBuilder(type_1768c);
  ::Reflex::Type type_9257 = ::Reflex::ReferenceBuilder(type_2209);
  ::Reflex::Type type_2209c = ::Reflex::ConstBuilder(type_2209);
  ::Reflex::Type type_9258 = ::Reflex::ReferenceBuilder(type_2209c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __TMarocSetupHandler
#undef __TMarocSetupHandler
#endif
class __TMarocSetupHandler : public ::TRealSetupHandler {
  public:
  __TMarocSetupHandler();
  virtual ~__TMarocSetupHandler() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::std::map<int,int> m_MarocToH8500;
  ::std::map<int,int> m_H8500ToMaroc;
};
#ifdef __TMarocEventHeader
#undef __TMarocEventHeader
#endif
class __TMarocEventHeader : public ::TEventHeader {
  public:
  __TMarocEventHeader();
  virtual ~__TMarocEventHeader() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  int m_multiplicity;
};
#ifdef __TMarocHit
#undef __TMarocHit
#endif
class __TMarocHit : public ::TObject {
  public:
  __TMarocHit();
  virtual ~__TMarocHit() throw();
  int marocID;
  int charge;
  bool isHit;
};
}


#endif // __CINT__
namespace {
} // unnamed namespace

#ifndef G__DICTIONARY
# define G__DICTIONARY
#endif
#include "TClass.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "RtypesImp.h"
#include "TIsAProxy.h"
atomic_TClass_ptr TMarocSetupHandler::fgIsA(0);
TClass* ::TMarocSetupHandler::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TMarocSetupHandler");
   }
   return fgIsA;
}
const char * ::TMarocSetupHandler::Class_Name() {return "TMarocSetupHandler";}
void ::TMarocSetupHandler::Dictionary() {}
const char *::TMarocSetupHandler::ImplFileName() {return "";}
int ::TMarocSetupHandler::ImplFileLine() {return 1;}
void ::TMarocSetupHandler::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TMarocSetupHandler::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_MarocToH8500", &m_MarocToH8500);
   R__insp.InspectMember("std::map<int,int>", (void*)&m_MarocToH8500, "m_MarocToH8500.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_H8500ToMaroc", &m_H8500ToMaroc);
   R__insp.InspectMember("std::map<int,int>", (void*)&m_H8500ToMaroc, "m_H8500ToMaroc.", false);
   TRealSetupHandler::ShowMembers(R__insp);
}
void ::TMarocSetupHandler::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TMarocSetupHandler::Class(),this);
   } else {
      b.WriteClassBuffer(::TMarocSetupHandler::Class(),this);
   }
}

atomic_TClass_ptr TMarocEventHeader::fgIsA(0);
TClass* ::TMarocEventHeader::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TMarocEventHeader");
   }
   return fgIsA;
}
const char * ::TMarocEventHeader::Class_Name() {return "TMarocEventHeader";}
void ::TMarocEventHeader::Dictionary() {}
const char *::TMarocEventHeader::ImplFileName() {return "";}
int ::TMarocEventHeader::ImplFileLine() {return 1;}
void ::TMarocEventHeader::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TMarocEventHeader::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_multiplicity", &m_multiplicity);
   TEventHeader::ShowMembers(R__insp);
}
void ::TMarocEventHeader::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TMarocEventHeader::Class(),this);
   } else {
      b.WriteClassBuffer(::TMarocEventHeader::Class(),this);
   }
}

atomic_TClass_ptr TMarocHit::fgIsA(0);
TClass* ::TMarocHit::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TMarocHit");
   }
   return fgIsA;
}
const char * ::TMarocHit::Class_Name() {return "TMarocHit";}
void ::TMarocHit::Dictionary() {}
const char *::TMarocHit::ImplFileName() {return "";}
int ::TMarocHit::ImplFileLine() {return 1;}
void ::TMarocHit::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TMarocHit::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "marocID", &marocID);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "charge", &charge);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "isHit", &isHit);
   TObject::ShowMembers(R__insp);
}
void ::TMarocHit::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TMarocHit::Class(),this);
   } else {
      b.WriteClassBuffer(::TMarocHit::Class(),this);
   }
}


namespace {
//------Stub functions for class TMarocSetupHandler -------------------------------
static  void operator_3921( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TMarocSetupHandler*)o)->operator=)(*(const ::TMarocSetupHandler*)arg[0]);
  else   (((::TMarocSetupHandler*)o)->operator=)(*(const ::TMarocSetupHandler*)arg[0]);
}

static void constructor_3922( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMarocSetupHandler(*(const ::TMarocSetupHandler*)arg[0]);
  else ::new(mem) ::TMarocSetupHandler(*(const ::TMarocSetupHandler*)arg[0]);
}

static void constructor_3925( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMarocSetupHandler();
  else ::new(mem) ::TMarocSetupHandler();
}

static void constructor_3926( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMarocSetupHandler(*(::std::string*)arg[0]);
  else ::new(mem) ::TMarocSetupHandler(*(::std::string*)arg[0]);
}

static void destructor_3927(void*, void * o, const std::vector<void*>&, void *) {
((::TMarocSetupHandler*)o)->::TMarocSetupHandler::~TMarocSetupHandler();
}
static  void method_3928( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocSetupHandler*)o)->getMarocCard)(*(int*)arg[0]));
  else   (((::TMarocSetupHandler*)o)->getMarocCard)(*(int*)arg[0]);
}

static  void method_3929( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocSetupHandler*)o)->getMarocChannelFromGlobal)(*(int*)arg[0]));
  else   (((::TMarocSetupHandler*)o)->getMarocChannelFromGlobal)(*(int*)arg[0]);
}

static  void method_3930( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocSetupHandler*)o)->getMarocChannelFromH8500)(*(int*)arg[0]));
  else   (((::TMarocSetupHandler*)o)->getMarocChannelFromH8500)(*(int*)arg[0]);
}

static  void method_3931( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocSetupHandler*)o)->getH8500IdFromGlobal)(*(int*)arg[0]));
  else   (((::TMarocSetupHandler*)o)->getH8500IdFromGlobal)(*(int*)arg[0]);
}

static  void method_3932( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocSetupHandler*)o)->getH8500IdFromMaroc)(*(int*)arg[0]));
  else   (((::TMarocSetupHandler*)o)->getH8500IdFromMaroc)(*(int*)arg[0]);
}

static  void method_3933( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocSetupHandler*)o)->getPixelReconId)(*(int*)arg[0]));
  else   (((::TMarocSetupHandler*)o)->getPixelReconId)(*(int*)arg[0]);
}

static  void method_3934( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocSetupHandler*)o)->getPixelReconId)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((::TMarocSetupHandler*)o)->getPixelReconId)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3935( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (double)((((::TMarocSetupHandler*)o)->getPixelGainFromGlobal)(*(int*)arg[0]));
    else     (((::TMarocSetupHandler*)o)->getPixelGainFromGlobal)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (double)((((::TMarocSetupHandler*)o)->getPixelGainFromGlobal)(*(int*)arg[0],
      *(int*)arg[1]));
    else     (((::TMarocSetupHandler*)o)->getPixelGainFromGlobal)(*(int*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_3936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocSetupHandler*)o)->Class)());
  else   (((::TMarocSetupHandler*)o)->Class)();
}

static  void method_3937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocSetupHandler*)o)->Class_Name)());
  else   (((::TMarocSetupHandler*)o)->Class_Name)();
}

static  void method_3938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TMarocSetupHandler*)o)->Class_Version)());
  else   (((::TMarocSetupHandler*)o)->Class_Version)();
}

static  void method_3939( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TMarocSetupHandler*)o)->Dictionary)();
}

static  void method_3940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMarocSetupHandler*)o)->IsA)());
  else   (((const ::TMarocSetupHandler*)o)->IsA)();
}

static  void method_3941( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocSetupHandler*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_3942( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocSetupHandler*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_3943( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocSetupHandler*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_3944( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocSetupHandler*)o)->DeclFileName)());
  else   (((::TMarocSetupHandler*)o)->DeclFileName)();
}

static  void method_3945( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocSetupHandler*)o)->ImplFileLine)());
  else   (((::TMarocSetupHandler*)o)->ImplFileLine)();
}

static  void method_3946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocSetupHandler*)o)->ImplFileName)());
  else   (((::TMarocSetupHandler*)o)->ImplFileName)();
}

static  void method_3947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocSetupHandler*)o)->DeclFileLine)());
  else   (((::TMarocSetupHandler*)o)->DeclFileLine)();
}

static void method_newdel_1243( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TMarocSetupHandler >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TMarocSetupHandler >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TMarocSetupHandler >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TMarocSetupHandler >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TMarocSetupHandler >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TRealSetupHandler")), ::Reflex::BaseOffset< ::TMarocSetupHandler,::TRealSetupHandler >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TMarocSetupHandler,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TMarocSetupHandler -------------------------------
void __TMarocSetupHandler_db_datamem(Reflex::Class*);
void __TMarocSetupHandler_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TMarocSetupHandler_datamem_bld(&__TMarocSetupHandler_db_datamem);
Reflex::GenreflexMemberBuilder __TMarocSetupHandler_funcmem_bld(&__TMarocSetupHandler_db_funcmem);
void __TMarocSetupHandler_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TMarocSetupHandler"), typeid(::TMarocSetupHandler), sizeof(::TMarocSetupHandler), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TMarocSetupHandler::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_902, ::Reflex::BaseOffset< ::TMarocSetupHandler, ::TRealSetupHandler >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9118, type_9119), Reflex::Literal("operator="), operator_3921, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9119), Reflex::Literal("TMarocSetupHandler"), constructor_3922, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TMarocSetupHandler"), constructor_3925, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2390), Reflex::Literal("TMarocSetupHandler"), constructor_3926, 0, "fname", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TMarocSetupHandler"), destructor_3927, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1243, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TMarocSetupHandler_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TMarocSetupHandler_funcmem_bld);
}

//------Delayed data member builder for class TMarocSetupHandler -------------------
void __TMarocSetupHandler_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2556, Reflex::Literal("m_MarocToH8500"), OffsetOf(__shadow__::__TMarocSetupHandler, m_MarocToH8500), ::Reflex::PRIVATE)
  .AddDataMember(type_2556, Reflex::Literal("m_H8500ToMaroc"), OffsetOf(__shadow__::__TMarocSetupHandler, m_H8500ToMaroc), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TMarocSetupHandler -------------------
void __TMarocSetupHandler_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47, type_47), Reflex::Literal("getMarocCard"), method_3928, 0, "globalID", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47, type_47), Reflex::Literal("getMarocChannelFromGlobal"), method_3929, 0, "globalID", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47, type_47), Reflex::Literal("getMarocChannelFromH8500"), method_3930, 0, "H8500ID", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47, type_47), Reflex::Literal("getH8500IdFromGlobal"), method_3931, 0, "globalID", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47, type_47), Reflex::Literal("getH8500IdFromMaroc"), method_3932, 0, "globalID", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47, type_47), Reflex::Literal("getPixelReconId"), method_3933, 0, "globalID", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47, type_47, type_47), Reflex::Literal("getPixelReconId"), method_3934, 0, "iRealDet;iRealPixel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_361, type_47, type_47), Reflex::Literal("getPixelGainFromGlobal"), method_3935, 0, "globalID;igain=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_820), Reflex::Literal("Class"), method_3936, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2794), Reflex::Literal("Class_Name"), method_3937, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1691), Reflex::Literal("Class_Version"), method_3938, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_177), Reflex::Literal("Dictionary"), method_3939, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_820), Reflex::Literal("IsA"), method_3940, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_177, type_8925), Reflex::Literal("ShowMembers"), method_3941, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_177, type_4279), Reflex::Literal("Streamer"), method_3942, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_177, type_4279), Reflex::Literal("StreamerNVirtual"), method_3943, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2794), Reflex::Literal("DeclFileName"), method_3944, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47), Reflex::Literal("ImplFileLine"), method_3945, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2794), Reflex::Literal("ImplFileName"), method_3946, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47), Reflex::Literal("DeclFileLine"), method_3947, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TMarocEventHeader -------------------------------
static  void operator_4288( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TMarocEventHeader*)o)->operator=)(*(const ::TMarocEventHeader*)arg[0]);
  else   (((::TMarocEventHeader*)o)->operator=)(*(const ::TMarocEventHeader*)arg[0]);
}

static void constructor_4289( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMarocEventHeader(*(const ::TMarocEventHeader*)arg[0]);
  else ::new(mem) ::TMarocEventHeader(*(const ::TMarocEventHeader*)arg[0]);
}

static void constructor_4290( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMarocEventHeader();
  else ::new(mem) ::TMarocEventHeader();
}

static void destructor_4291(void*, void * o, const std::vector<void*>&, void *) {
((::TMarocEventHeader*)o)->::TMarocEventHeader::~TMarocEventHeader();
}
static  void method_4292( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TMarocEventHeader*)o)->getMultiplicity)());
  else   (((const ::TMarocEventHeader*)o)->getMultiplicity)();
}

static  void method_4293( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocEventHeader*)o)->setMultiplicity)(*(int*)arg[0]);
}

static  void method_4294( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocEventHeader*)o)->Class)());
  else   (((::TMarocEventHeader*)o)->Class)();
}

static  void method_4295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocEventHeader*)o)->Class_Name)());
  else   (((::TMarocEventHeader*)o)->Class_Name)();
}

static  void method_4296( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TMarocEventHeader*)o)->Class_Version)());
  else   (((::TMarocEventHeader*)o)->Class_Version)();
}

static  void method_4297( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TMarocEventHeader*)o)->Dictionary)();
}

static  void method_4298( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMarocEventHeader*)o)->IsA)());
  else   (((const ::TMarocEventHeader*)o)->IsA)();
}

static  void method_4299( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocEventHeader*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4300( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocEventHeader*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4301( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocEventHeader*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4302( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocEventHeader*)o)->DeclFileName)());
  else   (((::TMarocEventHeader*)o)->DeclFileName)();
}

static  void method_4303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocEventHeader*)o)->ImplFileLine)());
  else   (((::TMarocEventHeader*)o)->ImplFileLine)();
}

static  void method_4304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocEventHeader*)o)->ImplFileName)());
  else   (((::TMarocEventHeader*)o)->ImplFileName)();
}

static  void method_4305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocEventHeader*)o)->DeclFileLine)());
  else   (((::TMarocEventHeader*)o)->DeclFileLine)();
}

static void method_newdel_1768( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TMarocEventHeader >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TMarocEventHeader >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TMarocEventHeader >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TMarocEventHeader >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TMarocEventHeader >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TEventHeader")), ::Reflex::BaseOffset< ::TMarocEventHeader,::TEventHeader >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TMarocEventHeader,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TMarocEventHeader -------------------------------
void __TMarocEventHeader_db_datamem(Reflex::Class*);
void __TMarocEventHeader_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TMarocEventHeader_datamem_bld(&__TMarocEventHeader_db_datamem);
Reflex::GenreflexMemberBuilder __TMarocEventHeader_funcmem_bld(&__TMarocEventHeader_db_funcmem);
void __TMarocEventHeader_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TMarocEventHeader"), typeid(::TMarocEventHeader), sizeof(::TMarocEventHeader), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TMarocEventHeader::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_677, ::Reflex::BaseOffset< ::TMarocEventHeader, ::TEventHeader >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9182, type_9183), Reflex::Literal("operator="), operator_4288, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9183), Reflex::Literal("TMarocEventHeader"), constructor_4289, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TMarocEventHeader"), constructor_4290, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TMarocEventHeader"), destructor_4291, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1768, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TMarocEventHeader_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TMarocEventHeader_funcmem_bld);
}

//------Delayed data member builder for class TMarocEventHeader -------------------
void __TMarocEventHeader_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_47, Reflex::Literal("m_multiplicity"), OffsetOf(__shadow__::__TMarocEventHeader, m_multiplicity), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TMarocEventHeader -------------------
void __TMarocEventHeader_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47), Reflex::Literal("getMultiplicity"), method_4292, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_177, type_47), Reflex::Literal("setMultiplicity"), method_4293, 0, "multiplicity", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_820), Reflex::Literal("Class"), method_4294, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2794), Reflex::Literal("Class_Name"), method_4295, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1691), Reflex::Literal("Class_Version"), method_4296, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_177), Reflex::Literal("Dictionary"), method_4297, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_820), Reflex::Literal("IsA"), method_4298, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_177, type_8925), Reflex::Literal("ShowMembers"), method_4299, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_177, type_4279), Reflex::Literal("Streamer"), method_4300, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_177, type_4279), Reflex::Literal("StreamerNVirtual"), method_4301, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2794), Reflex::Literal("DeclFileName"), method_4302, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47), Reflex::Literal("ImplFileLine"), method_4303, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2794), Reflex::Literal("ImplFileName"), method_4304, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47), Reflex::Literal("DeclFileLine"), method_4305, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TMarocHit -------------------------------
static  void operator_4679( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TMarocHit*)o)->operator=)(*(const ::TMarocHit*)arg[0]);
  else   (((::TMarocHit*)o)->operator=)(*(const ::TMarocHit*)arg[0]);
}

static void constructor_4680( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMarocHit(*(const ::TMarocHit*)arg[0]);
  else ::new(mem) ::TMarocHit(*(const ::TMarocHit*)arg[0]);
}

static void constructor_4681( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMarocHit();
  else ::new(mem) ::TMarocHit();
}

static void destructor_4682(void*, void * o, const std::vector<void*>&, void *) {
((::TMarocHit*)o)->::TMarocHit::~TMarocHit();
}
static  void method_4683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TMarocHit*)o)->getCharge)());
  else   (((const ::TMarocHit*)o)->getCharge)();
}

static  void method_4684( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocHit*)o)->setCharge)(*(int*)arg[0]);
}

static  void method_4685( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::TMarocHit*)o)->isIsHit)());
  else   (((const ::TMarocHit*)o)->isIsHit)();
}

static  void method_4686( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocHit*)o)->setIsHit)(*(bool*)arg[0]);
}

static  void method_4687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TMarocHit*)o)->getMarocId)());
  else   (((const ::TMarocHit*)o)->getMarocId)();
}

static  void method_4688( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocHit*)o)->setMarocId)(*(int*)arg[0]);
}

static  void method_4689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocHit*)o)->Class)());
  else   (((::TMarocHit*)o)->Class)();
}

static  void method_4690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocHit*)o)->Class_Name)());
  else   (((::TMarocHit*)o)->Class_Name)();
}

static  void method_4691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TMarocHit*)o)->Class_Version)());
  else   (((::TMarocHit*)o)->Class_Version)();
}

static  void method_4692( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TMarocHit*)o)->Dictionary)();
}

static  void method_4693( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMarocHit*)o)->IsA)());
  else   (((const ::TMarocHit*)o)->IsA)();
}

static  void method_4694( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocHit*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4695( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocHit*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4696( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocHit*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocHit*)o)->DeclFileName)());
  else   (((::TMarocHit*)o)->DeclFileName)();
}

static  void method_4698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocHit*)o)->ImplFileLine)());
  else   (((::TMarocHit*)o)->ImplFileLine)();
}

static  void method_4699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocHit*)o)->ImplFileName)());
  else   (((::TMarocHit*)o)->ImplFileName)();
}

static  void method_4700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocHit*)o)->DeclFileLine)());
  else   (((::TMarocHit*)o)->DeclFileLine)();
}

static void method_newdel_2209( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TMarocHit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TMarocHit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TMarocHit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TMarocHit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TMarocHit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TMarocHit,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TMarocHit -------------------------------
void __TMarocHit_db_datamem(Reflex::Class*);
void __TMarocHit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TMarocHit_datamem_bld(&__TMarocHit_db_datamem);
Reflex::GenreflexMemberBuilder __TMarocHit_funcmem_bld(&__TMarocHit_db_funcmem);
void __TMarocHit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TMarocHit"), typeid(::TMarocHit), sizeof(::TMarocHit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TMarocHit::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_978, ::Reflex::BaseOffset< ::TMarocHit, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9257, type_9258), Reflex::Literal("operator="), operator_4679, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9258), Reflex::Literal("TMarocHit"), constructor_4680, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TMarocHit"), constructor_4681, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TMarocHit"), destructor_4682, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2209, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TMarocHit_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TMarocHit_funcmem_bld);
}

//------Delayed data member builder for class TMarocHit -------------------
void __TMarocHit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_47, Reflex::Literal("marocID"), OffsetOf(__shadow__::__TMarocHit, marocID), ::Reflex::PRIVATE)
  .AddDataMember(type_47, Reflex::Literal("charge"), OffsetOf(__shadow__::__TMarocHit, charge), ::Reflex::PRIVATE)
  .AddDataMember(type_952, Reflex::Literal("isHit"), OffsetOf(__shadow__::__TMarocHit, isHit), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TMarocHit -------------------
void __TMarocHit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47), Reflex::Literal("getCharge"), method_4683, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_177, type_47), Reflex::Literal("setCharge"), method_4684, 0, "charge", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_952), Reflex::Literal("isIsHit"), method_4685, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_177, type_952), Reflex::Literal("setIsHit"), method_4686, 0, "isHit", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47), Reflex::Literal("getMarocId"), method_4687, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_177, type_47), Reflex::Literal("setMarocId"), method_4688, 0, "marocId", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_820), Reflex::Literal("Class"), method_4689, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2794), Reflex::Literal("Class_Name"), method_4690, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1691), Reflex::Literal("Class_Version"), method_4691, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_177), Reflex::Literal("Dictionary"), method_4692, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_820), Reflex::Literal("IsA"), method_4693, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_177, type_8925), Reflex::Literal("ShowMembers"), method_4694, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_177, type_4279), Reflex::Literal("Streamer"), method_4695, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_177, type_4279), Reflex::Literal("StreamerNVirtual"), method_4696, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2794), Reflex::Literal("DeclFileName"), method_4697, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47), Reflex::Literal("ImplFileLine"), method_4698, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2794), Reflex::Literal("ImplFileName"), method_4699, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47), Reflex::Literal("DeclFileLine"), method_4700, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __TMarocSetupHandler_dict(); 
      __TMarocEventHeader_dict(); 
      __TMarocHit_dict(); 
    }
    ~Dictionaries() {
      type_1243.Unload(); // class TMarocSetupHandler 
      type_1768.Unload(); // class TMarocEventHeader 
      type_2209.Unload(); // class TMarocHit 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
