// Generated at Wed Dec  9 15:37:11 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/usr/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/usr/bin/c++"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic "
  GCCXML_EXECUTABLE="/usr/bin/gccxml_cc1plus"
  GCCXML_CPP="/usr/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__FLT_MIN__='1.17549435e-38F' -D__CHAR_BIT__='8' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='4.9406564584124654e-324' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__LP64__='1' -D__GNUC_PATCHLEVEL__='7' -D__DEC64_MAX_EXP__='385' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__unix='1' -D__LDBL_MAX_EXP__='16384' -D__linux__='1' -D__SCHAR_MAX__='127' -D__DBL_DIG__='15' -D_FORTIFY_SOURCE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209290e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__SIZEOF_LONG__='8' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='1.7976931348623157e+308' -D__DBL_HAS_INFINITY__='1' -D__DEC32_MIN_EXP__='(-94)' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__DBL_MIN__='2.2250738585072014e-308' -D__FLT_MIN_10_EXP__='(-37)' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__DBL_HAS_DENORM__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.4.7 20120313 (Red Hat 4.4.7-16)"' -D__DEC64_EPSILON__='1E-15DD' -D__DEC128_MIN_EXP__='(-6142)' -Dunix='1' -D__SIZE_TYPE__='long unsigned int' -D__ELF__='1' -D__FLT_RADIX__='2' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__GNUC_RH_RELEASE__='16' -D__k8='1' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__DEC64_MANT_DIG__='16' -D__DEC32_MAX_EXP__='97' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__k8__='1' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__DEC64_MIN_EXP__='(-382)' -D__FLT_DIG__='6' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__FLT_MAX_EXP__='128' -D__DBL_MANT_DIG__='53' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__SSP__='1' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='2.2204460492503131e-16' -D_LP64='1' -D__SIZEOF_WCHAR_T__='4' -D__DEC_EVAL_METHOD__='2' -D__INTMAX_MAX__='9223372036854775807L' -D__FLT_DENORM_MIN__='1.40129846e-45F' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282347e+38F' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='4' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__GNUC_GNU_INLINE__='1' -D_GNU_SOURCE='1' -iwrapper"/usr/share/gccxml-0.9/GCC/4.4" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/backward" -isystem"/usr/local/include" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/usr/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.4.7 20120313 (Red Hat 4.4.7-16)
Copyright (C) 2010 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/project/Gruppo3/fiber5/celentano/OptoTracker/packages/Tofpet/include/TofpetClasses.hh"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::Type type_30 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_109 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_566 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_167 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_105 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_537 = ::Reflex::TypeBuilder(Reflex::Literal("TClass"));
  ::Reflex::Type type_228 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_825 = ::Reflex::TypeBuilder(Reflex::Literal("TObject"));
  ::Reflex::Type type_1290 = ::Reflex::TypeBuilder(Reflex::Literal("TBuffer"));
  ::Reflex::Type type_508 = ::Reflex::TypeBuilder(Reflex::Literal("long long"));
  ::Reflex::Type type_1329 = ::Reflex::TypeBuilder(Reflex::Literal("TTofpetHit"));
  ::Reflex::Type type_184 = ::Reflex::TypeBuilder(Reflex::Literal("TTofpetSetup"));
  ::Reflex::Type type_1130 = ::Reflex::TypeBuilder(Reflex::Literal("TEventHeader"));
  ::Reflex::Type type_49 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_377 = ::Reflex::TypeBuilder(Reflex::Literal("TMemberInspector"));
  ::Reflex::Type type_1357 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<int,int>"));
  ::Reflex::Type type_1103 = ::Reflex::TypeBuilder(Reflex::Literal("TTofpetEventHeader"));
  ::Reflex::Type type_1387 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<int,int> >"));
  ::Reflex::Type type_3743 = ::Reflex::ReferenceBuilder(type_184);
  ::Reflex::Type type_184c = ::Reflex::ConstBuilder(type_184);
  ::Reflex::Type type_3744 = ::Reflex::ReferenceBuilder(type_184c);
  ::Reflex::Type type_497 = ::Reflex::PointerBuilder(type_537);
  ::Reflex::Type type_566c = ::Reflex::ConstBuilder(type_566);
  ::Reflex::Type type_1551 = ::Reflex::PointerBuilder(type_566c);
  ::Reflex::Type type_1011 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Version_t"), type_167);
  ::Reflex::Type type_3745 = ::Reflex::ReferenceBuilder(type_377);
  ::Reflex::Type type_2168 = ::Reflex::ReferenceBuilder(type_1290);
  ::Reflex::Type type_4193 = ::Reflex::ReferenceBuilder(type_1103);
  ::Reflex::Type type_1103c = ::Reflex::ConstBuilder(type_1103);
  ::Reflex::Type type_4194 = ::Reflex::ReferenceBuilder(type_1103c);
  ::Reflex::Type type_4247 = ::Reflex::ReferenceBuilder(type_1329);
  ::Reflex::Type type_1329c = ::Reflex::ConstBuilder(type_1329);
  ::Reflex::Type type_4248 = ::Reflex::ReferenceBuilder(type_1329c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __TTofpetSetup
#undef __TTofpetSetup
#endif
class __TTofpetSetup : public ::TObject {
  public:
  __TTofpetSetup();
  virtual ~__TTofpetSetup() throw();
  int m_Nsteps1;
  int m_Nsteps2;
  ::std::vector<std::pair<int,int> > m_pairs;
};
#ifdef __TTofpetEventHeader
#undef __TTofpetEventHeader
#endif
class __TTofpetEventHeader : public ::TEventHeader {
  public:
  __TTofpetEventHeader();
  virtual ~__TTofpetEventHeader() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  int m_step1;
  int m_step2;
};
#ifdef __TTofpetHit
#undef __TTofpetHit
#endif
class __TTofpetHit : public ::TObject {
  public:
  __TTofpetHit();
  virtual ~__TTofpetHit() throw();
  short m_channel;
  short m_xi;
  short m_yi;
  short m_detector;
  unsigned short m_tac;
  double m_channelIdleTime;
  double m_tacIdleTime;
  float m_energy;
  float m_ToT;
  float m_TQT;
  float m_TQE;
  long long m_time;
};
}


#endif // __CINT__
namespace {
} // unnamed namespace

#ifndef G__DICTIONARY
# define G__DICTIONARY
#endif
#include "TClass.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "RtypesImp.h"
#include "TIsAProxy.h"
atomic_TClass_ptr TTofpetSetup::fgIsA(0);
TClass* ::TTofpetSetup::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TTofpetSetup");
   }
   return fgIsA;
}
const char * ::TTofpetSetup::Class_Name() {return "TTofpetSetup";}
void ::TTofpetSetup::Dictionary() {}
const char *::TTofpetSetup::ImplFileName() {return "";}
int ::TTofpetSetup::ImplFileLine() {return 1;}
void ::TTofpetSetup::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TTofpetSetup::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Nsteps1", &m_Nsteps1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Nsteps2", &m_Nsteps2);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_pairs", &m_pairs);
   R__insp.InspectMember("std::vector<std::pair<int,int> >", (void*)&m_pairs, "m_pairs.", false);
   TObject::ShowMembers(R__insp);
}
void ::TTofpetSetup::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TTofpetSetup::Class(),this);
   } else {
      b.WriteClassBuffer(::TTofpetSetup::Class(),this);
   }
}

atomic_TClass_ptr TTofpetEventHeader::fgIsA(0);
TClass* ::TTofpetEventHeader::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TTofpetEventHeader");
   }
   return fgIsA;
}
const char * ::TTofpetEventHeader::Class_Name() {return "TTofpetEventHeader";}
void ::TTofpetEventHeader::Dictionary() {}
const char *::TTofpetEventHeader::ImplFileName() {return "";}
int ::TTofpetEventHeader::ImplFileLine() {return 1;}
void ::TTofpetEventHeader::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TTofpetEventHeader::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_step1", &m_step1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_step2", &m_step2);
   TEventHeader::ShowMembers(R__insp);
}
void ::TTofpetEventHeader::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TTofpetEventHeader::Class(),this);
   } else {
      b.WriteClassBuffer(::TTofpetEventHeader::Class(),this);
   }
}

atomic_TClass_ptr TTofpetHit::fgIsA(0);
TClass* ::TTofpetHit::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TTofpetHit");
   }
   return fgIsA;
}
const char * ::TTofpetHit::Class_Name() {return "TTofpetHit";}
void ::TTofpetHit::Dictionary() {}
const char *::TTofpetHit::ImplFileName() {return "";}
int ::TTofpetHit::ImplFileLine() {return 1;}
void ::TTofpetHit::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TTofpetHit::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_channel", &m_channel);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_xi", &m_xi);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_yi", &m_yi);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_detector", &m_detector);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_tac", &m_tac);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_channelIdleTime", &m_channelIdleTime);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_tacIdleTime", &m_tacIdleTime);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_energy", &m_energy);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_ToT", &m_ToT);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_TQT", &m_TQT);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_TQE", &m_TQE);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_time", &m_time);
   TObject::ShowMembers(R__insp);
}
void ::TTofpetHit::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TTofpetHit::Class(),this);
   } else {
      b.WriteClassBuffer(::TTofpetHit::Class(),this);
   }
}


namespace {
//------Stub functions for class TTofpetSetup -------------------------------
static  void operator_1685( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TTofpetSetup*)o)->operator=)(*(const ::TTofpetSetup*)arg[0]);
  else   (((::TTofpetSetup*)o)->operator=)(*(const ::TTofpetSetup*)arg[0]);
}

static void constructor_1686( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetSetup(*(const ::TTofpetSetup*)arg[0]);
  else ::new(mem) ::TTofpetSetup(*(const ::TTofpetSetup*)arg[0]);
}

static void constructor_1687( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetSetup();
  else ::new(mem) ::TTofpetSetup();
}

static  void method_1688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetSetup*)o)->getNsteps)());
  else   (((const ::TTofpetSetup*)o)->getNsteps)();
}

static  void method_1689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetSetup*)o)->getNsteps1)());
  else   (((const ::TTofpetSetup*)o)->getNsteps1)();
}

static  void method_1690( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetSetup*)o)->setNsteps1)(*(int*)arg[0]);
}

static  void method_1691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetSetup*)o)->getNsteps2)());
  else   (((const ::TTofpetSetup*)o)->getNsteps2)();
}

static  void method_1692( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetSetup*)o)->setNsteps2)(*(int*)arg[0]);
}

static  void method_1693( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetSetup*)o)->addPair)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_1694( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<int,int>)((((const ::TTofpetSetup*)o)->getPair)(*(int*)arg[0]));
  else   (((const ::TTofpetSetup*)o)->getPair)(*(int*)arg[0]);
}

static  void method_1695( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetSetup*)o)->getStep1)(*(int*)arg[0]));
  else   (((const ::TTofpetSetup*)o)->getStep1)(*(int*)arg[0]);
}

static  void method_1696( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetSetup*)o)->getStep2)(*(int*)arg[0]));
  else   (((const ::TTofpetSetup*)o)->getStep2)(*(int*)arg[0]);
}

static  void method_1697( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetSetup*)o)->getStepID)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TTofpetSetup*)o)->getStepID)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_1698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetSetup*)o)->Class)());
  else   (((::TTofpetSetup*)o)->Class)();
}

static  void method_1699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetSetup*)o)->Class_Name)());
  else   (((::TTofpetSetup*)o)->Class_Name)();
}

static  void method_1700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TTofpetSetup*)o)->Class_Version)());
  else   (((::TTofpetSetup*)o)->Class_Version)();
}

static  void method_1701( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetSetup*)o)->Dictionary)();
}

static  void method_1702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetSetup*)o)->IsA)());
  else   (((const ::TTofpetSetup*)o)->IsA)();
}

static  void method_1703( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetSetup*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_1704( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetSetup*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_1705( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetSetup*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_1706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetSetup*)o)->DeclFileName)());
  else   (((::TTofpetSetup*)o)->DeclFileName)();
}

static  void method_1707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetSetup*)o)->ImplFileLine)());
  else   (((::TTofpetSetup*)o)->ImplFileLine)();
}

static  void method_1708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetSetup*)o)->ImplFileName)());
  else   (((::TTofpetSetup*)o)->ImplFileName)();
}

static  void method_1709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetSetup*)o)->DeclFileLine)());
  else   (((::TTofpetSetup*)o)->DeclFileLine)();
}

static void destructor_1710(void*, void * o, const std::vector<void*>&, void *) {
(((::TTofpetSetup*)o)->::TTofpetSetup::~TTofpetSetup)();
}
static void method_newdel_184( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TTofpetSetup >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TTofpetSetup >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TTofpetSetup >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TTofpetSetup >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TTofpetSetup >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TTofpetSetup,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TTofpetSetup -------------------------------
void __TTofpetSetup_db_datamem(Reflex::Class*);
void __TTofpetSetup_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TTofpetSetup_datamem_bld(&__TTofpetSetup_db_datamem);
Reflex::GenreflexMemberBuilder __TTofpetSetup_funcmem_bld(&__TTofpetSetup_db_funcmem);
void __TTofpetSetup_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TTofpetSetup"), typeid(::TTofpetSetup), sizeof(::TTofpetSetup), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TTofpetSetup::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_825, ::Reflex::BaseOffset< ::TTofpetSetup, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3743, type_3744), Reflex::Literal("operator="), operator_1685, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3744), Reflex::Literal("TTofpetSetup"), constructor_1686, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TTofpetSetup"), constructor_1687, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TTofpetSetup"), destructor_1710, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_184, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TTofpetSetup_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TTofpetSetup_funcmem_bld);
}

//------Delayed data member builder for class TTofpetSetup -------------------
void __TTofpetSetup_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_30, Reflex::Literal("m_Nsteps1"), OffsetOf(__shadow__::__TTofpetSetup, m_Nsteps1), ::Reflex::PRIVATE)
  .AddDataMember(type_30, Reflex::Literal("m_Nsteps2"), OffsetOf(__shadow__::__TTofpetSetup, m_Nsteps2), ::Reflex::PRIVATE)
  .AddDataMember(type_1387, Reflex::Literal("m_pairs"), OffsetOf(__shadow__::__TTofpetSetup, m_pairs), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TTofpetSetup -------------------
void __TTofpetSetup_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("getNsteps"), method_1688, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("getNsteps1"), method_1689, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_30), Reflex::Literal("setNsteps1"), method_1690, 0, "nsteps1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("getNsteps2"), method_1691, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_30), Reflex::Literal("setNsteps2"), method_1692, 0, "nsteps2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_30, type_30), Reflex::Literal("addPair"), method_1693, 0, "step1;step2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1357, type_30), Reflex::Literal("getPair"), method_1694, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30, type_30), Reflex::Literal("getStep1"), method_1695, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30, type_30), Reflex::Literal("getStep2"), method_1696, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30, type_30, type_30), Reflex::Literal("getStepID"), method_1697, 0, "step1;step2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_497), Reflex::Literal("Class"), method_1698, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1551), Reflex::Literal("Class_Name"), method_1699, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1011), Reflex::Literal("Class_Version"), method_1700, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109), Reflex::Literal("Dictionary"), method_1701, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_497), Reflex::Literal("IsA"), method_1702, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_3745), Reflex::Literal("ShowMembers"), method_1703, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_2168), Reflex::Literal("Streamer"), method_1704, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_2168), Reflex::Literal("StreamerNVirtual"), method_1705, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1551), Reflex::Literal("DeclFileName"), method_1706, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("ImplFileLine"), method_1707, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1551), Reflex::Literal("ImplFileName"), method_1708, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("DeclFileLine"), method_1709, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TTofpetEventHeader -------------------------------
static  void operator_2223( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TTofpetEventHeader*)o)->operator=)(*(const ::TTofpetEventHeader*)arg[0]);
  else   (((::TTofpetEventHeader*)o)->operator=)(*(const ::TTofpetEventHeader*)arg[0]);
}

static void constructor_2224( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetEventHeader(*(const ::TTofpetEventHeader*)arg[0]);
  else ::new(mem) ::TTofpetEventHeader(*(const ::TTofpetEventHeader*)arg[0]);
}

static void constructor_2225( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetEventHeader();
  else ::new(mem) ::TTofpetEventHeader();
}

static void destructor_2226(void*, void * o, const std::vector<void*>&, void *) {
(((::TTofpetEventHeader*)o)->::TTofpetEventHeader::~TTofpetEventHeader)();
}
static  void method_2227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetEventHeader*)o)->getStep1)());
  else   (((const ::TTofpetEventHeader*)o)->getStep1)();
}

static  void method_2228( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetEventHeader*)o)->setStep1)(*(int*)arg[0]);
}

static  void method_2229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetEventHeader*)o)->getStep2)());
  else   (((const ::TTofpetEventHeader*)o)->getStep2)();
}

static  void method_2230( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetEventHeader*)o)->setStep2)(*(int*)arg[0]);
}

static  void method_2231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetEventHeader*)o)->Class)());
  else   (((::TTofpetEventHeader*)o)->Class)();
}

static  void method_2232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetEventHeader*)o)->Class_Name)());
  else   (((::TTofpetEventHeader*)o)->Class_Name)();
}

static  void method_2233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TTofpetEventHeader*)o)->Class_Version)());
  else   (((::TTofpetEventHeader*)o)->Class_Version)();
}

static  void method_2234( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetEventHeader*)o)->Dictionary)();
}

static  void method_2235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetEventHeader*)o)->IsA)());
  else   (((const ::TTofpetEventHeader*)o)->IsA)();
}

static  void method_2236( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetEventHeader*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_2237( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetEventHeader*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_2238( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetEventHeader*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_2239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetEventHeader*)o)->DeclFileName)());
  else   (((::TTofpetEventHeader*)o)->DeclFileName)();
}

static  void method_2240( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetEventHeader*)o)->ImplFileLine)());
  else   (((::TTofpetEventHeader*)o)->ImplFileLine)();
}

static  void method_2241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetEventHeader*)o)->ImplFileName)());
  else   (((::TTofpetEventHeader*)o)->ImplFileName)();
}

static  void method_2242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetEventHeader*)o)->DeclFileLine)());
  else   (((::TTofpetEventHeader*)o)->DeclFileLine)();
}

static void method_newdel_1103( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TTofpetEventHeader >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TTofpetEventHeader >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TTofpetEventHeader >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TTofpetEventHeader >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TTofpetEventHeader >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TEventHeader")), ::Reflex::BaseOffset< ::TTofpetEventHeader,::TEventHeader >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TTofpetEventHeader,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TTofpetEventHeader -------------------------------
void __TTofpetEventHeader_db_datamem(Reflex::Class*);
void __TTofpetEventHeader_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TTofpetEventHeader_datamem_bld(&__TTofpetEventHeader_db_datamem);
Reflex::GenreflexMemberBuilder __TTofpetEventHeader_funcmem_bld(&__TTofpetEventHeader_db_funcmem);
void __TTofpetEventHeader_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TTofpetEventHeader"), typeid(::TTofpetEventHeader), sizeof(::TTofpetEventHeader), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TTofpetEventHeader::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1130, ::Reflex::BaseOffset< ::TTofpetEventHeader, ::TEventHeader >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4193, type_4194), Reflex::Literal("operator="), operator_2223, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4194), Reflex::Literal("TTofpetEventHeader"), constructor_2224, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TTofpetEventHeader"), constructor_2225, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TTofpetEventHeader"), destructor_2226, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1103, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TTofpetEventHeader_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TTofpetEventHeader_funcmem_bld);
}

//------Delayed data member builder for class TTofpetEventHeader -------------------
void __TTofpetEventHeader_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_30, Reflex::Literal("m_step1"), OffsetOf(__shadow__::__TTofpetEventHeader, m_step1), ::Reflex::PRIVATE)
  .AddDataMember(type_30, Reflex::Literal("m_step2"), OffsetOf(__shadow__::__TTofpetEventHeader, m_step2), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TTofpetEventHeader -------------------
void __TTofpetEventHeader_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("getStep1"), method_2227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_30), Reflex::Literal("setStep1"), method_2228, 0, "step1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("getStep2"), method_2229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_30), Reflex::Literal("setStep2"), method_2230, 0, "step2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_497), Reflex::Literal("Class"), method_2231, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1551), Reflex::Literal("Class_Name"), method_2232, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1011), Reflex::Literal("Class_Version"), method_2233, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109), Reflex::Literal("Dictionary"), method_2234, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_497), Reflex::Literal("IsA"), method_2235, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_3745), Reflex::Literal("ShowMembers"), method_2236, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_2168), Reflex::Literal("Streamer"), method_2237, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_2168), Reflex::Literal("StreamerNVirtual"), method_2238, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1551), Reflex::Literal("DeclFileName"), method_2239, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("ImplFileLine"), method_2240, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1551), Reflex::Literal("ImplFileName"), method_2241, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("DeclFileLine"), method_2242, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TTofpetHit -------------------------------
static  void operator_2546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TTofpetHit*)o)->operator=)(*(const ::TTofpetHit*)arg[0]);
  else   (((::TTofpetHit*)o)->operator=)(*(const ::TTofpetHit*)arg[0]);
}

static void constructor_2547( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetHit(*(const ::TTofpetHit*)arg[0]);
  else ::new(mem) ::TTofpetHit(*(const ::TTofpetHit*)arg[0]);
}

static void constructor_2548( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetHit();
  else ::new(mem) ::TTofpetHit();
}

static void destructor_2549(void*, void * o, const std::vector<void*>&, void *) {
(((::TTofpetHit*)o)->::TTofpetHit::~TTofpetHit)();
}
static  void method_2550( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::TTofpetHit*)o)->getChannel)());
  else   (((const ::TTofpetHit*)o)->getChannel)();
}

static  void method_2551( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setChannel)(*(short*)arg[0]);
}

static  void method_2552( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TTofpetHit*)o)->getChannelIdleTime)());
  else   (((const ::TTofpetHit*)o)->getChannelIdleTime)();
}

static  void method_2553( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setChannelIdleTime)(*(double*)arg[0]);
}

static  void method_2554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::TTofpetHit*)o)->getDetector)());
  else   (((const ::TTofpetHit*)o)->getDetector)();
}

static  void method_2555( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setDetector)(*(short*)arg[0]);
}

static  void method_2556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::TTofpetHit*)o)->getEnergy)());
  else   (((const ::TTofpetHit*)o)->getEnergy)();
}

static  void method_2557( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setEnergy)(*(float*)arg[0]);
}

static  void method_2558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::TTofpetHit*)o)->getToT)());
  else   (((const ::TTofpetHit*)o)->getToT)();
}

static  void method_2559( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setTot)(*(float*)arg[0]);
}

static  void method_2560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TTofpetHit*)o)->getTacIdleTime)());
  else   (((const ::TTofpetHit*)o)->getTacIdleTime)();
}

static  void method_2561( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setTacIdleTime)(*(double*)arg[0]);
}

static  void method_2562( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::TTofpetHit*)o)->getTqe)());
  else   (((const ::TTofpetHit*)o)->getTqe)();
}

static  void method_2563( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setTqe)(*(float*)arg[0]);
}

static  void method_2564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::TTofpetHit*)o)->getTqt)());
  else   (((const ::TTofpetHit*)o)->getTqt)();
}

static  void method_2565( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setTqt)(*(float*)arg[0]);
}

static  void method_2566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::TTofpetHit*)o)->getXi)());
  else   (((const ::TTofpetHit*)o)->getXi)();
}

static  void method_2567( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setXi)(*(short*)arg[0]);
}

static  void method_2568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::TTofpetHit*)o)->getYi)());
  else   (((const ::TTofpetHit*)o)->getYi)();
}

static  void method_2569( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setYi)(*(short*)arg[0]);
}

static  void method_2570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::TTofpetHit*)o)->getTime)());
  else   (((const ::TTofpetHit*)o)->getTime)();
}

static  void method_2571( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setTime)(*(long long*)arg[0]);
}

static  void method_2572( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setTac)(*(unsigned short*)arg[0]);
}

static  void method_2573( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((::TTofpetHit*)o)->getTac)());
  else   (((::TTofpetHit*)o)->getTac)();
}

static  void method_2574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetHit*)o)->Class)());
  else   (((::TTofpetHit*)o)->Class)();
}

static  void method_2575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetHit*)o)->Class_Name)());
  else   (((::TTofpetHit*)o)->Class_Name)();
}

static  void method_2576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TTofpetHit*)o)->Class_Version)());
  else   (((::TTofpetHit*)o)->Class_Version)();
}

static  void method_2577( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetHit*)o)->Dictionary)();
}

static  void method_2578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetHit*)o)->IsA)());
  else   (((const ::TTofpetHit*)o)->IsA)();
}

static  void method_2579( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_2580( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_2581( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_2582( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetHit*)o)->DeclFileName)());
  else   (((::TTofpetHit*)o)->DeclFileName)();
}

static  void method_2583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetHit*)o)->ImplFileLine)());
  else   (((::TTofpetHit*)o)->ImplFileLine)();
}

static  void method_2584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetHit*)o)->ImplFileName)());
  else   (((::TTofpetHit*)o)->ImplFileName)();
}

static  void method_2585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetHit*)o)->DeclFileLine)());
  else   (((::TTofpetHit*)o)->DeclFileLine)();
}

static void method_newdel_1329( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TTofpetHit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TTofpetHit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TTofpetHit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TTofpetHit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TTofpetHit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TTofpetHit,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TTofpetHit -------------------------------
void __TTofpetHit_db_datamem(Reflex::Class*);
void __TTofpetHit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TTofpetHit_datamem_bld(&__TTofpetHit_db_datamem);
Reflex::GenreflexMemberBuilder __TTofpetHit_funcmem_bld(&__TTofpetHit_db_funcmem);
void __TTofpetHit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TTofpetHit"), typeid(::TTofpetHit), sizeof(::TTofpetHit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TTofpetHit::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_825, ::Reflex::BaseOffset< ::TTofpetHit, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4247, type_4248), Reflex::Literal("operator="), operator_2546, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4248), Reflex::Literal("TTofpetHit"), constructor_2547, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TTofpetHit"), constructor_2548, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TTofpetHit"), destructor_2549, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1329, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TTofpetHit_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TTofpetHit_funcmem_bld);
}

//------Delayed data member builder for class TTofpetHit -------------------
void __TTofpetHit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_167, Reflex::Literal("m_channel"), OffsetOf(__shadow__::__TTofpetHit, m_channel), ::Reflex::PRIVATE)
  .AddDataMember(type_167, Reflex::Literal("m_xi"), OffsetOf(__shadow__::__TTofpetHit, m_xi), ::Reflex::PRIVATE)
  .AddDataMember(type_167, Reflex::Literal("m_yi"), OffsetOf(__shadow__::__TTofpetHit, m_yi), ::Reflex::PRIVATE)
  .AddDataMember(type_167, Reflex::Literal("m_detector"), OffsetOf(__shadow__::__TTofpetHit, m_detector), ::Reflex::PRIVATE)
  .AddDataMember(type_49, Reflex::Literal("m_tac"), OffsetOf(__shadow__::__TTofpetHit, m_tac), ::Reflex::PRIVATE)
  .AddDataMember(type_228, Reflex::Literal("m_channelIdleTime"), OffsetOf(__shadow__::__TTofpetHit, m_channelIdleTime), ::Reflex::PRIVATE)
  .AddDataMember(type_228, Reflex::Literal("m_tacIdleTime"), OffsetOf(__shadow__::__TTofpetHit, m_tacIdleTime), ::Reflex::PRIVATE)
  .AddDataMember(type_105, Reflex::Literal("m_energy"), OffsetOf(__shadow__::__TTofpetHit, m_energy), ::Reflex::PRIVATE)
  .AddDataMember(type_105, Reflex::Literal("m_ToT"), OffsetOf(__shadow__::__TTofpetHit, m_ToT), ::Reflex::PRIVATE)
  .AddDataMember(type_105, Reflex::Literal("m_TQT"), OffsetOf(__shadow__::__TTofpetHit, m_TQT), ::Reflex::PRIVATE)
  .AddDataMember(type_105, Reflex::Literal("m_TQE"), OffsetOf(__shadow__::__TTofpetHit, m_TQE), ::Reflex::PRIVATE)
  .AddDataMember(type_508, Reflex::Literal("m_time"), OffsetOf(__shadow__::__TTofpetHit, m_time), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TTofpetHit -------------------
void __TTofpetHit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_167), Reflex::Literal("getChannel"), method_2550, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_167), Reflex::Literal("setChannel"), method_2551, 0, "channel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_228), Reflex::Literal("getChannelIdleTime"), method_2552, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_228), Reflex::Literal("setChannelIdleTime"), method_2553, 0, "channelIdleTime", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_167), Reflex::Literal("getDetector"), method_2554, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_167), Reflex::Literal("setDetector"), method_2555, 0, "detector", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_105), Reflex::Literal("getEnergy"), method_2556, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_105), Reflex::Literal("setEnergy"), method_2557, 0, "eventEnergy", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_105), Reflex::Literal("getToT"), method_2558, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_105), Reflex::Literal("setTot"), method_2559, 0, "eventTot", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_228), Reflex::Literal("getTacIdleTime"), method_2560, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_228), Reflex::Literal("setTacIdleTime"), method_2561, 0, "tacIdleTime", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_105), Reflex::Literal("getTqe"), method_2562, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_105), Reflex::Literal("setTqe"), method_2563, 0, "tqe", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_105), Reflex::Literal("getTqt"), method_2564, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_105), Reflex::Literal("setTqt"), method_2565, 0, "tqt", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_167), Reflex::Literal("getXi"), method_2566, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_167), Reflex::Literal("setXi"), method_2567, 0, "xi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_167), Reflex::Literal("getYi"), method_2568, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_167), Reflex::Literal("setYi"), method_2569, 0, "yi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_508), Reflex::Literal("getTime"), method_2570, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_508), Reflex::Literal("setTime"), method_2571, 0, "time", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_49), Reflex::Literal("setTac"), method_2572, 0, "tac", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_49), Reflex::Literal("getTac"), method_2573, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_497), Reflex::Literal("Class"), method_2574, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1551), Reflex::Literal("Class_Name"), method_2575, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1011), Reflex::Literal("Class_Version"), method_2576, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109), Reflex::Literal("Dictionary"), method_2577, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_497), Reflex::Literal("IsA"), method_2578, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_3745), Reflex::Literal("ShowMembers"), method_2579, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_2168), Reflex::Literal("Streamer"), method_2580, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_109, type_2168), Reflex::Literal("StreamerNVirtual"), method_2581, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1551), Reflex::Literal("DeclFileName"), method_2582, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("ImplFileLine"), method_2583, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1551), Reflex::Literal("ImplFileName"), method_2584, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("DeclFileLine"), method_2585, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __TTofpetSetup_dict(); 
      __TTofpetEventHeader_dict(); 
      __TTofpetHit_dict(); 
    }
    ~Dictionaries() {
      type_184.Unload(); // class TTofpetSetup 
      type_1103.Unload(); // class TTofpetEventHeader 
      type_1329.Unload(); // class TTofpetHit 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
