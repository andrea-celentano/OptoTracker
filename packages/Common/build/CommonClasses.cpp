// Generated at Wed Oct  7 16:37:58 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/usr/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/usr/bin/c++"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic "
  GCCXML_EXECUTABLE="/usr/bin/gccxml_cc1plus"
  GCCXML_CPP="/usr/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__FLT_MIN__='1.17549435e-38F' -D__CHAR_BIT__='8' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='4.9406564584124654e-324' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__LP64__='1' -D__GNUC_PATCHLEVEL__='7' -D__DEC64_MAX_EXP__='385' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__unix='1' -D__LDBL_MAX_EXP__='16384' -D__linux__='1' -D__SCHAR_MAX__='127' -D__DBL_DIG__='15' -D_FORTIFY_SOURCE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209290e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__SIZEOF_LONG__='8' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='1.7976931348623157e+308' -D__DBL_HAS_INFINITY__='1' -D__DEC32_MIN_EXP__='(-94)' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__DBL_MIN__='2.2250738585072014e-308' -D__FLT_MIN_10_EXP__='(-37)' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__DBL_HAS_DENORM__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.4.7 20120313 (Red Hat 4.4.7-16)"' -D__DEC64_EPSILON__='1E-15DD' -D__DEC128_MIN_EXP__='(-6142)' -Dunix='1' -D__SIZE_TYPE__='long unsigned int' -D__ELF__='1' -D__FLT_RADIX__='2' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__GNUC_RH_RELEASE__='16' -D__k8='1' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__DEC64_MANT_DIG__='16' -D__DEC32_MAX_EXP__='97' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__k8__='1' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__DEC64_MIN_EXP__='(-382)' -D__FLT_DIG__='6' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__FLT_MAX_EXP__='128' -D__DBL_MANT_DIG__='53' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__SSP__='1' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='2.2204460492503131e-16' -D_LP64='1' -D__SIZEOF_WCHAR_T__='4' -D__DEC_EVAL_METHOD__='2' -D__INTMAX_MAX__='9223372036854775807L' -D__FLT_DENORM_MIN__='1.40129846e-45F' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282347e+38F' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='4' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__GNUC_GNU_INLINE__='1' -D_GNU_SOURCE='1' -iwrapper"/usr/share/gccxml-0.9/GCC/4.4" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/backward" -isystem"/usr/local/include" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/usr/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.4.7 20120313 (Red Hat 4.4.7-16)
Copyright (C) 2010 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/project/Gruppo3/fiber5/celentano/OptoTracker/packages/Common/include/CommonClasses.hh"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::Type type_52 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_46 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1122 = ::Reflex::TypeBuilder(Reflex::Literal("TF1"));
  ::Reflex::Type type_958 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_300 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_382 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_916 = ::Reflex::TypeBuilder(Reflex::Literal("TClass"));
  ::Reflex::Type type_198 = ::Reflex::TypeBuilder(Reflex::Literal("TNamed"));
  ::Reflex::Type type_1521 = ::Reflex::TypeBuilder(Reflex::Literal("TEvent"));
  ::Reflex::Type type_1386 = ::Reflex::TypeBuilder(Reflex::Literal("TObject"));
  ::Reflex::Type type_2244 = ::Reflex::TypeBuilder(Reflex::Literal("TBuffer"));
  ::Reflex::Type type_318 = ::Reflex::TypeBuilder(Reflex::Literal("TMCTruth"));
  ::Reflex::Type type_1067 = ::Reflex::TypeBuilder(Reflex::Literal("TVector3"));
  ::Reflex::Type type_136 = ::Reflex::TypeBuilder(Reflex::Literal("TXMLEngine"));
  ::Reflex::Type type_1640 = ::Reflex::TypeBuilder(Reflex::Literal("TObjArray"));
  ::Reflex::Type type_122 = ::Reflex::TypeBuilder(Reflex::Literal("TXMLHandler"));
  ::Reflex::Type type_514 = ::Reflex::TypeBuilder(Reflex::Literal("TMCParticle"));
  ::Reflex::Type type_404 = ::Reflex::TypeBuilder(Reflex::Literal("reconControl"));
  ::Reflex::Type type_16 = ::Reflex::TypeBuilder(Reflex::Literal("TDetectorUtils"));
  ::Reflex::Type type_1326 = ::Reflex::TypeBuilder(Reflex::Literal("TClonesArray"));
  ::Reflex::Type type_448 = ::Reflex::TypeBuilder(Reflex::Literal("TDetectorLight"));
  ::Reflex::Type type_163 = ::Reflex::TypeBuilder(Reflex::Literal("TLorentzVector"));
  ::Reflex::Type type_647 = ::Reflex::TypeBuilder(Reflex::Literal("TMemberInspector"));
  ::Reflex::Type type_2262 = ::Reflex::TypeBuilder(Reflex::Literal("TNamedContainer"));
  ::Reflex::Type type_2431 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<driver>"));
  ::Reflex::Type type_2434 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_2474 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_2433 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<TClonesArray*>"));
  ::Reflex::Type type_9018 = ::Reflex::PointerBuilder(type_448);
  ::Reflex::Type type_9019 = ::Reflex::PointerBuilder(type_1122);
  ::Reflex::Type type_9020 = ::Reflex::ReferenceBuilder(type_16);
  ::Reflex::Type type_16c = ::Reflex::ConstBuilder(type_16);
  ::Reflex::Type type_9021 = ::Reflex::ReferenceBuilder(type_16c);
  ::Reflex::Type type_1067c = ::Reflex::ConstBuilder(type_1067);
  ::Reflex::Type type_4807 = ::Reflex::ReferenceBuilder(type_1067c);
  ::Reflex::Type type_859 = ::Reflex::PointerBuilder(type_916);
  ::Reflex::Type type_958c = ::Reflex::ConstBuilder(type_958);
  ::Reflex::Type type_2847 = ::Reflex::PointerBuilder(type_958c);
  ::Reflex::Type type_1776 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Version_t"), type_300);
  ::Reflex::Type type_9022 = ::Reflex::ReferenceBuilder(type_647);
  ::Reflex::Type type_5205 = ::Reflex::ReferenceBuilder(type_2244);
  ::Reflex::Type type_9038 = ::Reflex::PointerBuilder(type_136);
  ::Reflex::Type type_2488 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2474);
  ::Reflex::Type type_114 = ::Reflex::PointerBuilder(type_46);
  ::Reflex::Type type_115 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("XMLDocPointer_t"), type_114);
  ::Reflex::Type type_2260 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("XMLNodePointer_t"), type_114);
  ::Reflex::Type type_9039 = ::Reflex::ReferenceBuilder(type_122);
  ::Reflex::Type type_122c = ::Reflex::ConstBuilder(type_122);
  ::Reflex::Type type_9040 = ::Reflex::ReferenceBuilder(type_122c);
  ::Reflex::Type type_405 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reconControl_struct"), type_404);
  ::Reflex::Type type_1394 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Int_t"), type_52);
  ::Reflex::Type type_9120 = ::Reflex::PointerBuilder(type_163);
  ::Reflex::Type type_9121 = ::Reflex::ReferenceBuilder(type_318);
  ::Reflex::Type type_318c = ::Reflex::ConstBuilder(type_318);
  ::Reflex::Type type_9122 = ::Reflex::ReferenceBuilder(type_318c);
  ::Reflex::Type type_9139 = ::Reflex::ArrayBuilder(type_52, 6);
  ::Reflex::Type type_10460 = ::Reflex::ArrayBuilder(type_52, 256);
  ::Reflex::Type type_9140 = ::Reflex::ArrayBuilder(type_10460, 6);
  ::Reflex::Type type_10461 = ::Reflex::ArrayBuilder(type_2488, 256);
  ::Reflex::Type type_9141 = ::Reflex::ArrayBuilder(type_10461, 6);
  ::Reflex::Type type_10462 = ::Reflex::ArrayBuilder(type_382, 256);
  ::Reflex::Type type_9142 = ::Reflex::ArrayBuilder(type_10462, 6);
  ::Reflex::Type type_9143 = ::Reflex::ArrayBuilder(type_382, 6);
  ::Reflex::Type type_10463 = ::Reflex::ArrayBuilder(type_2434, 256);
  ::Reflex::Type type_9144 = ::Reflex::ArrayBuilder(type_10463, 6);
  ::Reflex::Type type_9145 = ::Reflex::ReferenceBuilder(type_448);
  ::Reflex::Type type_448c = ::Reflex::ConstBuilder(type_448);
  ::Reflex::Type type_9146 = ::Reflex::ReferenceBuilder(type_448c);
  ::Reflex::Type type_9090 = ::Reflex::ReferenceBuilder(type_52);
  ::Reflex::Type type_2321 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Option_t"), type_958c);
  ::Reflex::Type type_9061 = ::Reflex::PointerBuilder(type_2321);
  ::Reflex::Type type_9476 = ::Reflex::ReferenceBuilder(type_514);
  ::Reflex::Type type_514c = ::Reflex::ConstBuilder(type_514);
  ::Reflex::Type type_9477 = ::Reflex::ReferenceBuilder(type_514c);
  ::Reflex::Type type_9788 = ::Reflex::ReferenceBuilder(type_1521);
  ::Reflex::Type type_1521c = ::Reflex::ConstBuilder(type_1521);
  ::Reflex::Type type_9789 = ::Reflex::ReferenceBuilder(type_1521c);
  ::Reflex::Type type_7910 = ::Reflex::PointerBuilder(type_1386);
  ::Reflex::Type type_7034 = ::Reflex::PointerBuilder(type_1326);
  ::Reflex::Type type_9897 = ::Reflex::ReferenceBuilder(type_2262);
  ::Reflex::Type type_2262c = ::Reflex::ConstBuilder(type_2262);
  ::Reflex::Type type_9898 = ::Reflex::ReferenceBuilder(type_2262c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __TDetectorUtils
#undef __TDetectorUtils
#endif
class __TDetectorUtils : public ::TObject {
  public:
  __TDetectorUtils();
  virtual ~__TDetectorUtils() throw();
  void* m_detector;
  void* m_SinglePhotonTimeProbKernel;
  void* m_TrackChargeKernel;
};
#ifdef __TXMLHandler
#undef __TXMLHandler
#endif
class __TXMLHandler : public ::TObject {
  public:
  __TXMLHandler();
  virtual ~__TXMLHandler() throw();
  void* m_xml;
  ::std::string m_xmlFile;
  void* m_xmldoc;
  void* m_mainnode;
};
#ifdef __TMCTruth
#undef __TMCTruth
#endif
class __TMCTruth : public ::TNamed {
  public:
  __TMCTruth();
  virtual ~__TMCTruth() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  int m_pid;
  void* m_P0;
  void* m_x0;
  void* m_xin;
  void* m_xout;
  double m_edep;
  double m_edepVis;
  double m_pathLength;
};
#ifdef __TDetectorLight
#undef __TDetectorLight
#endif
class __TDetectorLight : public ::TObject {
  public:
  __TDetectorLight();
  virtual ~__TDetectorLight() throw();
  double LY;
  double fastScintTime;
  double rIndex;
  double scintSizeX;
  double scintSizeY;
  double scintSizeZ;
  int Ndet[6];
  int detPresent[6][256];
  ::std::string detName[6][256];
  double detSizeX[6][256];
  double detSizeY[6][256];
  double detPixelSizeX[6][256];
  double detPixelSizeY[6][256];
  int detNpixelsX[6][256];
  int detNpixelsY[6][256];
  double detQE[6][256];
  double detReflectivity[6][256];
  double detTimeRes[6][256];
  double detCenterX[6][256];
  double detCenterY[6][256];
  double detRotation[6][256];
  double detCouplingRIndex[6][256];
  double detCouplingThickness[6][256];
  double faceReflectivity[6];
  ::std::vector<double> posPixelX[6][256];
  ::std::vector<double> posPixelY[6][256];
  ::std::vector<double> posPixelZ[6][256];
  ::std::string m_name;
  int m_totPixels;
  int m_totDetectors;
};
#ifdef __TMCParticle
#undef __TMCParticle
#endif
class __TMCParticle : public ::TObject {
  public:
  __TMCParticle();
  virtual ~__TMCParticle() throw();
  int m_pid;
  int m_id;
  int m_parentId;
  double m_edep;
  double m_edepVis;
  void* m_x0;
  void* m_P0;
};
#ifdef __TEvent
#undef __TEvent
#endif
class __TEvent : public ::TObject {
  public:
  __TEvent();
  virtual ~__TEvent() throw();
  ::TObjArray m_objects;
  ::std::vector<TClonesArray*> m_collections;
};
#ifdef __TNamedContainer
#undef __TNamedContainer
#endif
class __TNamedContainer : public ::TNamed {
  public:
  __TNamedContainer();
  virtual ~__TNamedContainer() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  void* m_object;
};
}


#endif // __CINT__
namespace {
} // unnamed namespace

#ifndef G__DICTIONARY
# define G__DICTIONARY
#endif
#include "TClass.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "RtypesImp.h"
#include "TIsAProxy.h"
atomic_TClass_ptr TDetectorUtils::fgIsA(0);
TClass* ::TDetectorUtils::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TDetectorUtils");
   }
   return fgIsA;
}
const char * ::TDetectorUtils::Class_Name() {return "TDetectorUtils";}
void ::TDetectorUtils::Dictionary() {}
const char *::TDetectorUtils::ImplFileName() {return "";}
int ::TDetectorUtils::ImplFileLine() {return 1;}
void ::TDetectorUtils::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TDetectorUtils::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_detector", &m_detector);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_SinglePhotonTimeProbKernel", &m_SinglePhotonTimeProbKernel);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_TrackChargeKernel", &m_TrackChargeKernel);
   TObject::ShowMembers(R__insp);
}
void ::TDetectorUtils::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TDetectorUtils::Class(),this);
   } else {
      b.WriteClassBuffer(::TDetectorUtils::Class(),this);
   }
}

atomic_TClass_ptr TXMLHandler::fgIsA(0);
TClass* ::TXMLHandler::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TXMLHandler");
   }
   return fgIsA;
}
const char * ::TXMLHandler::Class_Name() {return "TXMLHandler";}
void ::TXMLHandler::Dictionary() {}
const char *::TXMLHandler::ImplFileName() {return "";}
int ::TXMLHandler::ImplFileLine() {return 1;}
void ::TXMLHandler::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TXMLHandler::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_xml", &m_xml);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_xmlFile", &m_xmlFile);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_xmldoc", &m_xmldoc);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_mainnode", &m_mainnode);
   TObject::ShowMembers(R__insp);
}
void ::TXMLHandler::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TXMLHandler::Class(),this);
   } else {
      b.WriteClassBuffer(::TXMLHandler::Class(),this);
   }
}

atomic_TClass_ptr TMCTruth::fgIsA(0);
TClass* ::TMCTruth::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TMCTruth");
   }
   return fgIsA;
}
const char * ::TMCTruth::Class_Name() {return "TMCTruth";}
void ::TMCTruth::Dictionary() {}
const char *::TMCTruth::ImplFileName() {return "";}
int ::TMCTruth::ImplFileLine() {return 1;}
void ::TMCTruth::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TMCTruth::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_pid", &m_pid);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_P0", &m_P0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_x0", &m_x0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_xin", &m_xin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_xout", &m_xout);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_edep", &m_edep);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_edepVis", &m_edepVis);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_pathLength", &m_pathLength);
   TNamed::ShowMembers(R__insp);
}
void ::TMCTruth::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TMCTruth::Class(),this);
   } else {
      b.WriteClassBuffer(::TMCTruth::Class(),this);
   }
}

atomic_TClass_ptr TDetectorLight::fgIsA(0);
TClass* ::TDetectorLight::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TDetectorLight");
   }
   return fgIsA;
}
const char * ::TDetectorLight::Class_Name() {return "TDetectorLight";}
void ::TDetectorLight::Dictionary() {}
const char *::TDetectorLight::ImplFileName() {return "";}
int ::TDetectorLight::ImplFileLine() {return 1;}
void ::TDetectorLight::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TDetectorLight::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "LY", &LY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fastScintTime", &fastScintTime);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "rIndex", &rIndex);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "scintSizeX", &scintSizeX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "scintSizeY", &scintSizeY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "scintSizeZ", &scintSizeZ);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "Ndet[6]", &Ndet);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detPresent[6][256]", &detPresent);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detName[6][256]", &detName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detSizeX[6][256]", &detSizeX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detSizeY[6][256]", &detSizeY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detPixelSizeX[6][256]", &detPixelSizeX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detPixelSizeY[6][256]", &detPixelSizeY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detNpixelsX[6][256]", &detNpixelsX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detNpixelsY[6][256]", &detNpixelsY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detQE[6][256]", &detQE);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detReflectivity[6][256]", &detReflectivity);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detTimeRes[6][256]", &detTimeRes);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detCenterX[6][256]", &detCenterX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detCenterY[6][256]", &detCenterY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detRotation[6][256]", &detRotation);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detCouplingRIndex[6][256]", &detCouplingRIndex);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detCouplingThickness[6][256]", &detCouplingThickness);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "faceReflectivity[6]", &faceReflectivity);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "posPixelX[6][256]", &posPixelX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "posPixelY[6][256]", &posPixelY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "posPixelZ[6][256]", &posPixelZ);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_name", &m_name);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_totPixels", &m_totPixels);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_totDetectors", &m_totDetectors);
   TObject::ShowMembers(R__insp);
}
void ::TDetectorLight::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TDetectorLight::Class(),this);
   } else {
      b.WriteClassBuffer(::TDetectorLight::Class(),this);
   }
}

atomic_TClass_ptr TMCParticle::fgIsA(0);
TClass* ::TMCParticle::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TMCParticle");
   }
   return fgIsA;
}
const char * ::TMCParticle::Class_Name() {return "TMCParticle";}
void ::TMCParticle::Dictionary() {}
const char *::TMCParticle::ImplFileName() {return "";}
int ::TMCParticle::ImplFileLine() {return 1;}
void ::TMCParticle::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TMCParticle::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_pid", &m_pid);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_id", &m_id);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_parentId", &m_parentId);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_edep", &m_edep);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_edepVis", &m_edepVis);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_x0", &m_x0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_P0", &m_P0);
   TObject::ShowMembers(R__insp);
}
void ::TMCParticle::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TMCParticle::Class(),this);
   } else {
      b.WriteClassBuffer(::TMCParticle::Class(),this);
   }
}

atomic_TClass_ptr TEvent::fgIsA(0);
TClass* ::TEvent::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TEvent");
   }
   return fgIsA;
}
const char * ::TEvent::Class_Name() {return "TEvent";}
void ::TEvent::Dictionary() {}
const char *::TEvent::ImplFileName() {return "";}
int ::TEvent::ImplFileLine() {return 1;}
void ::TEvent::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TEvent::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_objects", &m_objects);
   R__insp.InspectMember(m_objects, "m_objects.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_collections", &m_collections);
   R__insp.InspectMember("std::vector<TClonesArray*>", (void*)&m_collections, "m_collections.", false);
   TObject::ShowMembers(R__insp);
}
void ::TEvent::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TEvent::Class(),this);
   } else {
      b.WriteClassBuffer(::TEvent::Class(),this);
   }
}

atomic_TClass_ptr TNamedContainer::fgIsA(0);
TClass* ::TNamedContainer::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TNamedContainer");
   }
   return fgIsA;
}
const char * ::TNamedContainer::Class_Name() {return "TNamedContainer";}
void ::TNamedContainer::Dictionary() {}
const char *::TNamedContainer::ImplFileName() {return "";}
int ::TNamedContainer::ImplFileLine() {return 1;}
void ::TNamedContainer::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TNamedContainer::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_object", &m_object);
   TNamed::ShowMembers(R__insp);
}
void ::TNamedContainer::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TNamedContainer::Class(),this);
   } else {
      b.WriteClassBuffer(::TNamedContainer::Class(),this);
   }
}


namespace {
//------Stub functions for class TDetectorUtils -------------------------------
static  void operator_2857( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TDetectorUtils*)o)->operator=)(*(const ::TDetectorUtils*)arg[0]);
  else   (((::TDetectorUtils*)o)->operator=)(*(const ::TDetectorUtils*)arg[0]);
}

static void constructor_2858( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TDetectorUtils(*(const ::TDetectorUtils*)arg[0]);
  else ::new(mem) ::TDetectorUtils(*(const ::TDetectorUtils*)arg[0]);
}

static void constructor_2864( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TDetectorUtils();
  else ::new(mem) ::TDetectorUtils();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TDetectorUtils((::TDetectorLight*)arg[0]);
  else ::new(mem) ::TDetectorUtils((::TDetectorLight*)arg[0]);
  }
}

static void destructor_2865(void*, void * o, const std::vector<void*>&, void *) {
(((::TDetectorUtils*)o)->::TDetectorUtils::~TDetectorUtils)();
}
static  void method_2866( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorUtils*)o)->SinglePhotonTimeProb)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]));
  else   (((const ::TDetectorUtils*)o)->SinglePhotonTimeProb)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_2867( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorUtils*)o)->SinglePhotonIntegratedTimeProb)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]));
  else   (((const ::TDetectorUtils*)o)->SinglePhotonIntegratedTimeProb)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_2868( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorUtils*)o)->SinglePixelAverageCharge)(*(const ::TVector3*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    *(int*)arg[3]));
  else   (((const ::TDetectorUtils*)o)->SinglePixelAverageCharge)(*(const ::TVector3*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    *(int*)arg[3]);
}

static  void method_2869( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorUtils*)o)->GetSolidAngle)(*(const ::TVector3*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    *(int*)arg[3]));
  else   (((const ::TDetectorUtils*)o)->GetSolidAngle)(*(const ::TVector3*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    *(int*)arg[3]);
}

static  void method_2870( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorUtils*)o)->TrackAverageCharge)(*(const ::TVector3*)arg[0],
    *(const ::TVector3*)arg[1],
    *(int*)arg[2],
    *(int*)arg[3],
    *(int*)arg[4]));
  else   (((const ::TDetectorUtils*)o)->TrackAverageCharge)(*(const ::TVector3*)arg[0],
    *(const ::TVector3*)arg[1],
    *(int*)arg[2],
    *(int*)arg[3],
    *(int*)arg[4]);
}

static  void method_2871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorUtils*)o)->GetMinimalDelay)(*(const ::TVector3*)arg[0],
    *(const ::TVector3*)arg[1],
    *(double*)arg[2],
    *(int*)arg[3],
    *(int*)arg[4],
    *(int*)arg[5]));
  else   (((const ::TDetectorUtils*)o)->GetMinimalDelay)(*(const ::TVector3*)arg[0],
    *(const ::TVector3*)arg[1],
    *(double*)arg[2],
    *(int*)arg[3],
    *(int*)arg[4],
    *(int*)arg[5]);
}

static  void method_2872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDetectorUtils*)o)->Class)());
  else   (((::TDetectorUtils*)o)->Class)();
}

static  void method_2873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDetectorUtils*)o)->Class_Name)());
  else   (((::TDetectorUtils*)o)->Class_Name)();
}

static  void method_2874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TDetectorUtils*)o)->Class_Version)());
  else   (((::TDetectorUtils*)o)->Class_Version)();
}

static  void method_2875( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TDetectorUtils*)o)->Dictionary)();
}

static  void method_2876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TDetectorUtils*)o)->IsA)());
  else   (((const ::TDetectorUtils*)o)->IsA)();
}

static  void method_2877( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorUtils*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_2878( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorUtils*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_2879( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorUtils*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_2880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDetectorUtils*)o)->DeclFileName)());
  else   (((::TDetectorUtils*)o)->DeclFileName)();
}

static  void method_2881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDetectorUtils*)o)->ImplFileLine)());
  else   (((::TDetectorUtils*)o)->ImplFileLine)();
}

static  void method_2882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDetectorUtils*)o)->ImplFileName)());
  else   (((::TDetectorUtils*)o)->ImplFileName)();
}

static  void method_2883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDetectorUtils*)o)->DeclFileLine)());
  else   (((::TDetectorUtils*)o)->DeclFileLine)();
}

static void constructor_x0( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TDetectorUtils();
  else ::new(mem) ::TDetectorUtils();
}

static void method_newdel_16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TDetectorUtils >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TDetectorUtils >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TDetectorUtils >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TDetectorUtils >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TDetectorUtils >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x2( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TDetectorUtils,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TDetectorUtils -------------------------------
void __TDetectorUtils_db_datamem(Reflex::Class*);
void __TDetectorUtils_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TDetectorUtils_datamem_bld(&__TDetectorUtils_db_datamem);
Reflex::GenreflexMemberBuilder __TDetectorUtils_funcmem_bld(&__TDetectorUtils_db_funcmem);
void __TDetectorUtils_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TDetectorUtils"), typeid(::TDetectorUtils), sizeof(::TDetectorUtils), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TDetectorUtils::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1386, ::Reflex::BaseOffset< ::TDetectorUtils, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9020, type_9021), Reflex::Literal("operator="), operator_2857, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9021), Reflex::Literal("TDetectorUtils"), constructor_2858, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9018), Reflex::Literal("TDetectorUtils"), constructor_2864, 0, "det=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TDetectorUtils"), destructor_2865, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TDetectorUtils"), constructor_x0, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TDetectorUtils_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TDetectorUtils_funcmem_bld);
}

//------Delayed data member builder for class TDetectorUtils -------------------
void __TDetectorUtils_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9018, Reflex::Literal("m_detector"), OffsetOf(__shadow__::__TDetectorUtils, m_detector), ::Reflex::PRIVATE)
  .AddDataMember(type_9019, Reflex::Literal("m_SinglePhotonTimeProbKernel"), OffsetOf(__shadow__::__TDetectorUtils, m_SinglePhotonTimeProbKernel), ::Reflex::PRIVATE)
  .AddDataMember(type_9019, Reflex::Literal("m_TrackChargeKernel"), OffsetOf(__shadow__::__TDetectorUtils, m_TrackChargeKernel), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TDetectorUtils -------------------
void __TDetectorUtils_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_382, type_382, type_382), Reflex::Literal("SinglePhotonTimeProb"), method_2866, 0, "t;tau;sigma", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_382, type_382, type_382), Reflex::Literal("SinglePhotonIntegratedTimeProb"), method_2867, 0, "t;tau;sigma", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_4807, type_52, type_52, type_52), Reflex::Literal("SinglePixelAverageCharge"), method_2868, 0, "x0;iface;idetector;id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_4807, type_52, type_52, type_52), Reflex::Literal("GetSolidAngle"), method_2869, 0, "x0;iface;idetector;id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_4807, type_4807, type_52, type_52, type_52), Reflex::Literal("TrackAverageCharge"), method_2870, 0, "x0;x1;iface;idetector;id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_4807, type_4807, type_382, type_52, type_52, type_52), Reflex::Literal("GetMinimalDelay"), method_2871, 0, "x0;x1;beta;iface;idetector;id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859), Reflex::Literal("Class"), method_2872, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("Class_Name"), method_2873, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1776), Reflex::Literal("Class_Version"), method_2874, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46), Reflex::Literal("Dictionary"), method_2875, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859), Reflex::Literal("IsA"), method_2876, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_9022), Reflex::Literal("ShowMembers"), method_2877, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_5205), Reflex::Literal("Streamer"), method_2878, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_5205), Reflex::Literal("StreamerNVirtual"), method_2879, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("DeclFileName"), method_2880, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("ImplFileLine"), method_2881, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("ImplFileName"), method_2882, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("DeclFileLine"), method_2883, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TXMLHandler -------------------------------
static  void operator_2973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TXMLHandler*)o)->operator=)(*(const ::TXMLHandler*)arg[0]);
  else   (((::TXMLHandler*)o)->operator=)(*(const ::TXMLHandler*)arg[0]);
}

static void constructor_2974( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TXMLHandler(*(const ::TXMLHandler*)arg[0]);
  else ::new(mem) ::TXMLHandler(*(const ::TXMLHandler*)arg[0]);
}

static void constructor_2976( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TXMLHandler();
  else ::new(mem) ::TXMLHandler();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TXMLHandler(*(::std::string*)arg[0]);
  else ::new(mem) ::TXMLHandler(*(::std::string*)arg[0]);
  }
}

static void destructor_2977(void*, void * o, const std::vector<void*>&, void *) {
(((::TXMLHandler*)o)->::TXMLHandler::~TXMLHandler)();
}
static  void method_2978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<driver>)((((::TXMLHandler*)o)->GetDrivers)());
  else   (((::TXMLHandler*)o)->GetDrivers)();
}

static  void method_2979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reconControl_struct)((((::TXMLHandler*)o)->GetReconControl)());
  else   (((::TXMLHandler*)o)->GetReconControl)();
}

static  void method_2980( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TXMLHandler*)o)->DisplayNodes)(*(::XMLNodePointer_t*)arg[0],
    *(::Int_t*)arg[1]);
}

static  void method_2981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TXMLHandler*)o)->Class)());
  else   (((::TXMLHandler*)o)->Class)();
}

static  void method_2982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TXMLHandler*)o)->Class_Name)());
  else   (((::TXMLHandler*)o)->Class_Name)();
}

static  void method_2983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TXMLHandler*)o)->Class_Version)());
  else   (((::TXMLHandler*)o)->Class_Version)();
}

static  void method_2984( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TXMLHandler*)o)->Dictionary)();
}

static  void method_2985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TXMLHandler*)o)->IsA)());
  else   (((const ::TXMLHandler*)o)->IsA)();
}

static  void method_2986( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TXMLHandler*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_2987( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TXMLHandler*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_2988( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TXMLHandler*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_2989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TXMLHandler*)o)->DeclFileName)());
  else   (((::TXMLHandler*)o)->DeclFileName)();
}

static  void method_2990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TXMLHandler*)o)->ImplFileLine)());
  else   (((::TXMLHandler*)o)->ImplFileLine)();
}

static  void method_2991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TXMLHandler*)o)->ImplFileName)());
  else   (((::TXMLHandler*)o)->ImplFileName)();
}

static  void method_2992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TXMLHandler*)o)->DeclFileLine)());
  else   (((::TXMLHandler*)o)->DeclFileLine)();
}

static void constructor_x3( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TXMLHandler();
  else ::new(mem) ::TXMLHandler();
}

static void method_newdel_122( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TXMLHandler >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TXMLHandler >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TXMLHandler >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TXMLHandler >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TXMLHandler >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TXMLHandler,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TXMLHandler -------------------------------
void __TXMLHandler_db_datamem(Reflex::Class*);
void __TXMLHandler_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TXMLHandler_datamem_bld(&__TXMLHandler_db_datamem);
Reflex::GenreflexMemberBuilder __TXMLHandler_funcmem_bld(&__TXMLHandler_db_funcmem);
void __TXMLHandler_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TXMLHandler"), typeid(::TXMLHandler), sizeof(::TXMLHandler), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TXMLHandler::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1386, ::Reflex::BaseOffset< ::TXMLHandler, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9039, type_9040), Reflex::Literal("operator="), operator_2973, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9040), Reflex::Literal("TXMLHandler"), constructor_2974, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2488), Reflex::Literal("TXMLHandler"), constructor_2976, 0, "fname=\"\"", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TXMLHandler"), destructor_2977, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TXMLHandler"), constructor_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_122, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TXMLHandler_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TXMLHandler_funcmem_bld);
}

//------Delayed data member builder for class TXMLHandler -------------------
void __TXMLHandler_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9038, Reflex::Literal("m_xml"), OffsetOf(__shadow__::__TXMLHandler, m_xml), ::Reflex::PRIVATE)
  .AddDataMember(type_2488, Reflex::Literal("m_xmlFile"), OffsetOf(__shadow__::__TXMLHandler, m_xmlFile), ::Reflex::PRIVATE)
  .AddDataMember(type_115, Reflex::Literal("m_xmldoc"), OffsetOf(__shadow__::__TXMLHandler, m_xmldoc), ::Reflex::PRIVATE)
  .AddDataMember(type_2260, Reflex::Literal("m_mainnode"), OffsetOf(__shadow__::__TXMLHandler, m_mainnode), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TXMLHandler -------------------
void __TXMLHandler_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2431), Reflex::Literal("GetDrivers"), method_2978, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_405), Reflex::Literal("GetReconControl"), method_2979, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_2260, type_1394), Reflex::Literal("DisplayNodes"), method_2980, 0, "node;level", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859), Reflex::Literal("Class"), method_2981, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("Class_Name"), method_2982, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1776), Reflex::Literal("Class_Version"), method_2983, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46), Reflex::Literal("Dictionary"), method_2984, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859), Reflex::Literal("IsA"), method_2985, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_9022), Reflex::Literal("ShowMembers"), method_2986, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_5205), Reflex::Literal("Streamer"), method_2987, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_5205), Reflex::Literal("StreamerNVirtual"), method_2988, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("DeclFileName"), method_2989, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("ImplFileLine"), method_2990, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("ImplFileName"), method_2991, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("DeclFileLine"), method_2992, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TMCTruth -------------------------------
static  void operator_3343( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TMCTruth*)o)->operator=)(*(const ::TMCTruth*)arg[0]);
  else   (((::TMCTruth*)o)->operator=)(*(const ::TMCTruth*)arg[0]);
}

static void constructor_3344( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMCTruth(*(const ::TMCTruth*)arg[0]);
  else ::new(mem) ::TMCTruth(*(const ::TMCTruth*)arg[0]);
}

static void constructor_3345( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMCTruth();
  else ::new(mem) ::TMCTruth();
}

static void destructor_3346(void*, void * o, const std::vector<void*>&, void *) {
(((::TMCTruth*)o)->::TMCTruth::~TMCTruth)();
}
static  void method_3347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TMCTruth*)o)->getEdep)());
  else   (((const ::TMCTruth*)o)->getEdep)();
}

static  void method_3348( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->setEdep)(*(double*)arg[0]);
}

static  void method_3349( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->addEdep)(*(double*)arg[0]);
}

static  void method_3350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TMCTruth*)o)->getEdepVis)());
  else   (((const ::TMCTruth*)o)->getEdepVis)();
}

static  void method_3351( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->setEdepVis)(*(double*)arg[0]);
}

static  void method_3352( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->addEdepVis)(*(double*)arg[0]);
}

static  void method_3353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMCTruth*)o)->getP0)());
  else   (((const ::TMCTruth*)o)->getP0)();
}

static  void method_3354( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->setP0)((::TLorentzVector*)arg[0]);
}

static  void method_3355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TMCTruth*)o)->getPid)());
  else   (((const ::TMCTruth*)o)->getPid)();
}

static  void method_3356( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->setPid)(*(int*)arg[0]);
}

static  void method_3357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMCTruth*)o)->getX0)());
  else   (((const ::TMCTruth*)o)->getX0)();
}

static  void method_3358( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->setX0)((::TLorentzVector*)arg[0]);
}

static  void method_3359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMCTruth*)o)->getXin)());
  else   (((const ::TMCTruth*)o)->getXin)();
}

static  void method_3360( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->setXin)((::TLorentzVector*)arg[0]);
}

static  void method_3361( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMCTruth*)o)->getXout)());
  else   (((const ::TMCTruth*)o)->getXout)();
}

static  void method_3362( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->setXout)((::TLorentzVector*)arg[0]);
}

static  void method_3363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TMCTruth*)o)->getPathLength)());
  else   (((const ::TMCTruth*)o)->getPathLength)();
}

static  void method_3364( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->setPathLength)(*(double*)arg[0]);
}

static  void method_3365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCTruth*)o)->Class)());
  else   (((::TMCTruth*)o)->Class)();
}

static  void method_3366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCTruth*)o)->Class_Name)());
  else   (((::TMCTruth*)o)->Class_Name)();
}

static  void method_3367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TMCTruth*)o)->Class_Version)());
  else   (((::TMCTruth*)o)->Class_Version)();
}

static  void method_3368( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TMCTruth*)o)->Dictionary)();
}

static  void method_3369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMCTruth*)o)->IsA)());
  else   (((const ::TMCTruth*)o)->IsA)();
}

static  void method_3370( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_3371( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_3372( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_3373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCTruth*)o)->DeclFileName)());
  else   (((::TMCTruth*)o)->DeclFileName)();
}

static  void method_3374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMCTruth*)o)->ImplFileLine)());
  else   (((::TMCTruth*)o)->ImplFileLine)();
}

static  void method_3375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCTruth*)o)->ImplFileName)());
  else   (((::TMCTruth*)o)->ImplFileName)();
}

static  void method_3376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMCTruth*)o)->DeclFileLine)());
  else   (((::TMCTruth*)o)->DeclFileLine)();
}

static void method_newdel_318( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TMCTruth >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TMCTruth >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TMCTruth >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TMCTruth >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TMCTruth >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::TMCTruth,::TNamed >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TMCTruth,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TMCTruth -------------------------------
void __TMCTruth_db_datamem(Reflex::Class*);
void __TMCTruth_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TMCTruth_datamem_bld(&__TMCTruth_db_datamem);
Reflex::GenreflexMemberBuilder __TMCTruth_funcmem_bld(&__TMCTruth_db_funcmem);
void __TMCTruth_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TMCTruth"), typeid(::TMCTruth), sizeof(::TMCTruth), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TMCTruth::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_198, ::Reflex::BaseOffset< ::TMCTruth, ::TNamed >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9121, type_9122), Reflex::Literal("operator="), operator_3343, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9122), Reflex::Literal("TMCTruth"), constructor_3344, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TMCTruth"), constructor_3345, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TMCTruth"), destructor_3346, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_318, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TMCTruth_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TMCTruth_funcmem_bld);
}

//------Delayed data member builder for class TMCTruth -------------------
void __TMCTruth_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_52, Reflex::Literal("m_pid"), OffsetOf(__shadow__::__TMCTruth, m_pid), ::Reflex::PRIVATE)
  .AddDataMember(type_9120, Reflex::Literal("m_P0"), OffsetOf(__shadow__::__TMCTruth, m_P0), ::Reflex::PRIVATE)
  .AddDataMember(type_9120, Reflex::Literal("m_x0"), OffsetOf(__shadow__::__TMCTruth, m_x0), ::Reflex::PRIVATE)
  .AddDataMember(type_9120, Reflex::Literal("m_xin"), OffsetOf(__shadow__::__TMCTruth, m_xin), ::Reflex::PRIVATE)
  .AddDataMember(type_9120, Reflex::Literal("m_xout"), OffsetOf(__shadow__::__TMCTruth, m_xout), ::Reflex::PRIVATE)
  .AddDataMember(type_382, Reflex::Literal("m_edep"), OffsetOf(__shadow__::__TMCTruth, m_edep), ::Reflex::PRIVATE)
  .AddDataMember(type_382, Reflex::Literal("m_edepVis"), OffsetOf(__shadow__::__TMCTruth, m_edepVis), ::Reflex::PRIVATE)
  .AddDataMember(type_382, Reflex::Literal("m_pathLength"), OffsetOf(__shadow__::__TMCTruth, m_pathLength), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TMCTruth -------------------
void __TMCTruth_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382), Reflex::Literal("getEdep"), method_3347, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_382), Reflex::Literal("setEdep"), method_3348, 0, "edep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_382), Reflex::Literal("addEdep"), method_3349, 0, "edep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382), Reflex::Literal("getEdepVis"), method_3350, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_382), Reflex::Literal("setEdepVis"), method_3351, 0, "edepVis", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_382), Reflex::Literal("addEdepVis"), method_3352, 0, "edep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9120), Reflex::Literal("getP0"), method_3353, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_9120), Reflex::Literal("setP0"), method_3354, 0, "p0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("getPid"), method_3355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52), Reflex::Literal("setPid"), method_3356, 0, "pid", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9120), Reflex::Literal("getX0"), method_3357, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_9120), Reflex::Literal("setX0"), method_3358, 0, "x0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9120), Reflex::Literal("getXin"), method_3359, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_9120), Reflex::Literal("setXin"), method_3360, 0, "xin", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9120), Reflex::Literal("getXout"), method_3361, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_9120), Reflex::Literal("setXout"), method_3362, 0, "xout", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382), Reflex::Literal("getPathLength"), method_3363, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_382), Reflex::Literal("setPathLength"), method_3364, 0, "pathLength", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859), Reflex::Literal("Class"), method_3365, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("Class_Name"), method_3366, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1776), Reflex::Literal("Class_Version"), method_3367, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46), Reflex::Literal("Dictionary"), method_3368, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859), Reflex::Literal("IsA"), method_3369, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_9022), Reflex::Literal("ShowMembers"), method_3370, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_5205), Reflex::Literal("Streamer"), method_3371, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_5205), Reflex::Literal("StreamerNVirtual"), method_3372, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("DeclFileName"), method_3373, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("ImplFileLine"), method_3374, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("ImplFileName"), method_3375, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("DeclFileLine"), method_3376, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TDetectorLight -------------------------------
static  void operator_3529( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TDetectorLight*)o)->operator=)(*(const ::TDetectorLight*)arg[0]);
  else   (((::TDetectorLight*)o)->operator=)(*(const ::TDetectorLight*)arg[0]);
}

static void constructor_3530( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TDetectorLight(*(const ::TDetectorLight*)arg[0]);
  else ::new(mem) ::TDetectorLight(*(const ::TDetectorLight*)arg[0]);
}

static void constructor_3531( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TDetectorLight();
  else ::new(mem) ::TDetectorLight();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TDetectorLight(*(::std::string*)arg[0]);
  else ::new(mem) ::TDetectorLight(*(::std::string*)arg[0]);
  }
}

static void destructor_3532(void*, void * o, const std::vector<void*>&, void *) {
(((::TDetectorLight*)o)->::TDetectorLight::~TDetectorLight)();
}
static  void method_3533( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setScintSizeX)(*(double*)arg[0]);
}

static  void method_3534( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setScintSizeY)(*(double*)arg[0]);
}

static  void method_3535( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setScintSizeZ)(*(double*)arg[0]);
}

static  void method_3536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getScintSizeX)());
  else   (((const ::TDetectorLight*)o)->getScintSizeX)();
}

static  void method_3537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getScintSizeY)());
  else   (((const ::TDetectorLight*)o)->getScintSizeY)();
}

static  void method_3538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getScintSizeZ)());
  else   (((const ::TDetectorLight*)o)->getScintSizeZ)();
}

static  void method_3539( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setLY)(*(double*)arg[0]);
}

static  void method_3540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getLY)());
  else   (((const ::TDetectorLight*)o)->getLY)();
}

static  void method_3541( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setFastScintTime)(*(double*)arg[0]);
}

static  void method_3542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getFastScintTime)());
  else   (((const ::TDetectorLight*)o)->getFastScintTime)();
}

static  void method_3543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getRindex)());
  else   (((const ::TDetectorLight*)o)->getRindex)();
}

static  void method_3544( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setRindex)(*(double*)arg[0]);
}

static  void method_3545( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getFaceReflectivity)(*(int*)arg[0]));
  else   (((const ::TDetectorLight*)o)->getFaceReflectivity)(*(int*)arg[0]);
}

static  void method_3546( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setFaceReflectivity)(*(int*)arg[0],
    *(double*)arg[1]);
}

static  void method_3547( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setNdet)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3548( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDetectorLight*)o)->getNdet)(*(int*)arg[0]));
  else   (((const ::TDetectorLight*)o)->getNdet)(*(int*)arg[0]);
}

static  void method_3549( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDetectorLight*)o)->getDetGlobalID)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getDetGlobalID)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3550( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TDetectorLight*)o)->getFaceDetIDfromGlobal)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]);
}

static  void method_3551( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDetectorLight*)o)->getPixelGlobalID)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]));
  else   (((const ::TDetectorLight*)o)->getPixelGlobalID)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]);
}

static  void method_3552( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TDetectorLight*)o)->getFaceDetPixelIDfromGlobal)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    *(int*)arg[3]);
}

static  void method_3553( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDetectorLight*)o)->getTotDetectors)());
  else   (((::TDetectorLight*)o)->getTotDetectors)();
}

static  void method_3554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDetectorLight*)o)->getTotPixels)());
  else   (((::TDetectorLight*)o)->getTotPixels)();
}

static  void method_3555( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setDetSizeX)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_3556( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setDetSizeY)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_3557( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getDetSizeX)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getDetSizeX)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3558( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getDetSizeY)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getDetSizeY)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3559( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getDetCenterX)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getDetCenterX)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getDetCenterY)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getDetCenterY)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3561( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getDetRotation)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getDetRotation)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3562( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setDetCenterX)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_3563( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setDetCenterY)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_3564( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setDetRotation)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_3565( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setDetName)(*(int*)arg[0],
    *(int*)arg[1],
    *(::std::string*)arg[2]);
}

static  void method_3566( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::TDetectorLight*)o)->getDetName)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((::TDetectorLight*)o)->getDetName)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3567( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setNPixelsX)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]);
}

static  void method_3568( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setNPixelsY)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]);
}

static  void method_3569( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDetectorLight*)o)->getNPixelsX)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getNPixelsX)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3570( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDetectorLight*)o)->getNPixelsY)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getNPixelsY)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3571( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDetectorLight*)o)->getNPixels)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getNPixels)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3572( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getPixelSizeX)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getPixelSizeX)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3573( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getPixelSizeY)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getPixelSizeY)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3574( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getCouplingThickness)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getCouplingThickness)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getCouplingRIndex)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getCouplingRIndex)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3576( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setDetTimeRes)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_3577( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getDetTimeRes)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getDetTimeRes)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3578( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getDetQE)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getDetQE)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3579( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setDetQE)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_3580( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorLight*)o)->getDetReflectivity)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getDetReflectivity)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3581( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setDetReflectivity)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_3582( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDetectorLight*)o)->isDetPresent)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->isDetPresent)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3583( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->setName)(*(::std::string*)arg[0]);
}

static  void method_3584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::TDetectorLight*)o)->getName)());
  else   (((::TDetectorLight*)o)->getName)();
}

static  void method_3585( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::TDetectorLight*)o)->getPosPixel)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]));
  else   (((const ::TDetectorLight*)o)->getPosPixel)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]);
}

static  void method_3586( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::TDetectorLight*)o)->getFaceNormal)(*(int*)arg[0]));
  else   (((const ::TDetectorLight*)o)->getFaceNormal)(*(int*)arg[0]);
}

static  void method_3587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::TDetectorLight*)o)->getFaceT1)(*(int*)arg[0]));
  else   (((const ::TDetectorLight*)o)->getFaceT1)(*(int*)arg[0]);
}

static  void method_3588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::TDetectorLight*)o)->getFaceT2)(*(int*)arg[0]));
  else   (((const ::TDetectorLight*)o)->getFaceT2)(*(int*)arg[0]);
}

static  void method_3589( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::TDetectorLight*)o)->getDetectorNormal)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getDetectorNormal)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3590( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::TDetectorLight*)o)->getDetectorT1)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getDetectorT1)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3591( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::TDetectorLight*)o)->getDetectorT2)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetectorLight*)o)->getDetectorT2)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3592( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TDetectorLight*)o)->init)();
}

static  void method_3593( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::TDetectorLight*)o)->PrintPixels)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::TDetectorLight*)o)->PrintPixels)((::Option_t*)arg[0]);
  }
}

static  void method_3594( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::TDetectorLight*)o)->Print)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::TDetectorLight*)o)->Print)((::Option_t*)arg[0]);
  }
}

static  void method_3595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDetectorLight*)o)->Class)());
  else   (((::TDetectorLight*)o)->Class)();
}

static  void method_3596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDetectorLight*)o)->Class_Name)());
  else   (((::TDetectorLight*)o)->Class_Name)();
}

static  void method_3597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TDetectorLight*)o)->Class_Version)());
  else   (((::TDetectorLight*)o)->Class_Version)();
}

static  void method_3598( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TDetectorLight*)o)->Dictionary)();
}

static  void method_3599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TDetectorLight*)o)->IsA)());
  else   (((const ::TDetectorLight*)o)->IsA)();
}

static  void method_3600( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_3601( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_3602( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorLight*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_3603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDetectorLight*)o)->DeclFileName)());
  else   (((::TDetectorLight*)o)->DeclFileName)();
}

static  void method_3604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDetectorLight*)o)->ImplFileLine)());
  else   (((::TDetectorLight*)o)->ImplFileLine)();
}

static  void method_3605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDetectorLight*)o)->ImplFileName)());
  else   (((::TDetectorLight*)o)->ImplFileName)();
}

static  void method_3606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDetectorLight*)o)->DeclFileLine)());
  else   (((::TDetectorLight*)o)->DeclFileLine)();
}

static void constructor_x8( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TDetectorLight();
  else ::new(mem) ::TDetectorLight();
}

static void method_newdel_448( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TDetectorLight >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TDetectorLight >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TDetectorLight >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TDetectorLight >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TDetectorLight >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TDetectorLight,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TDetectorLight -------------------------------
void __TDetectorLight_db_datamem(Reflex::Class*);
void __TDetectorLight_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TDetectorLight_datamem_bld(&__TDetectorLight_db_datamem);
Reflex::GenreflexMemberBuilder __TDetectorLight_funcmem_bld(&__TDetectorLight_db_funcmem);
void __TDetectorLight_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TDetectorLight"), typeid(::TDetectorLight), sizeof(::TDetectorLight), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TDetectorLight::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1386, ::Reflex::BaseOffset< ::TDetectorLight, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9145, type_9146), Reflex::Literal("operator="), operator_3529, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9146), Reflex::Literal("TDetectorLight"), constructor_3530, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2488), Reflex::Literal("TDetectorLight"), constructor_3531, 0, "fname=\"\"", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TDetectorLight"), destructor_3532, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TDetectorLight"), constructor_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_448, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TDetectorLight_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TDetectorLight_funcmem_bld);
}

//------Delayed data member builder for class TDetectorLight -------------------
void __TDetectorLight_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_382, Reflex::Literal("LY"), OffsetOf(__shadow__::__TDetectorLight, LY), ::Reflex::PRIVATE)
  .AddDataMember(type_382, Reflex::Literal("fastScintTime"), OffsetOf(__shadow__::__TDetectorLight, fastScintTime), ::Reflex::PRIVATE)
  .AddDataMember(type_382, Reflex::Literal("rIndex"), OffsetOf(__shadow__::__TDetectorLight, rIndex), ::Reflex::PRIVATE)
  .AddDataMember(type_382, Reflex::Literal("scintSizeX"), OffsetOf(__shadow__::__TDetectorLight, scintSizeX), ::Reflex::PRIVATE)
  .AddDataMember(type_382, Reflex::Literal("scintSizeY"), OffsetOf(__shadow__::__TDetectorLight, scintSizeY), ::Reflex::PRIVATE)
  .AddDataMember(type_382, Reflex::Literal("scintSizeZ"), OffsetOf(__shadow__::__TDetectorLight, scintSizeZ), ::Reflex::PRIVATE)
  .AddDataMember(type_9139, Reflex::Literal("Ndet"), OffsetOf(__shadow__::__TDetectorLight, Ndet), ::Reflex::PRIVATE)
  .AddDataMember(type_9140, Reflex::Literal("detPresent"), OffsetOf(__shadow__::__TDetectorLight, detPresent), ::Reflex::PRIVATE)
  .AddDataMember(type_9141, Reflex::Literal("detName"), OffsetOf(__shadow__::__TDetectorLight, detName), ::Reflex::PRIVATE)
  .AddDataMember(type_9142, Reflex::Literal("detSizeX"), OffsetOf(__shadow__::__TDetectorLight, detSizeX), ::Reflex::PRIVATE)
  .AddDataMember(type_9142, Reflex::Literal("detSizeY"), OffsetOf(__shadow__::__TDetectorLight, detSizeY), ::Reflex::PRIVATE)
  .AddDataMember(type_9142, Reflex::Literal("detPixelSizeX"), OffsetOf(__shadow__::__TDetectorLight, detPixelSizeX), ::Reflex::PRIVATE)
  .AddDataMember(type_9142, Reflex::Literal("detPixelSizeY"), OffsetOf(__shadow__::__TDetectorLight, detPixelSizeY), ::Reflex::PRIVATE)
  .AddDataMember(type_9140, Reflex::Literal("detNpixelsX"), OffsetOf(__shadow__::__TDetectorLight, detNpixelsX), ::Reflex::PRIVATE)
  .AddDataMember(type_9140, Reflex::Literal("detNpixelsY"), OffsetOf(__shadow__::__TDetectorLight, detNpixelsY), ::Reflex::PRIVATE)
  .AddDataMember(type_9142, Reflex::Literal("detQE"), OffsetOf(__shadow__::__TDetectorLight, detQE), ::Reflex::PRIVATE)
  .AddDataMember(type_9142, Reflex::Literal("detReflectivity"), OffsetOf(__shadow__::__TDetectorLight, detReflectivity), ::Reflex::PRIVATE)
  .AddDataMember(type_9142, Reflex::Literal("detTimeRes"), OffsetOf(__shadow__::__TDetectorLight, detTimeRes), ::Reflex::PRIVATE)
  .AddDataMember(type_9142, Reflex::Literal("detCenterX"), OffsetOf(__shadow__::__TDetectorLight, detCenterX), ::Reflex::PRIVATE)
  .AddDataMember(type_9142, Reflex::Literal("detCenterY"), OffsetOf(__shadow__::__TDetectorLight, detCenterY), ::Reflex::PRIVATE)
  .AddDataMember(type_9142, Reflex::Literal("detRotation"), OffsetOf(__shadow__::__TDetectorLight, detRotation), ::Reflex::PRIVATE)
  .AddDataMember(type_9142, Reflex::Literal("detCouplingRIndex"), OffsetOf(__shadow__::__TDetectorLight, detCouplingRIndex), ::Reflex::PRIVATE)
  .AddDataMember(type_9142, Reflex::Literal("detCouplingThickness"), OffsetOf(__shadow__::__TDetectorLight, detCouplingThickness), ::Reflex::PRIVATE)
  .AddDataMember(type_9143, Reflex::Literal("faceReflectivity"), OffsetOf(__shadow__::__TDetectorLight, faceReflectivity), ::Reflex::PRIVATE)
  .AddDataMember(type_9144, Reflex::Literal("posPixelX"), OffsetOf(__shadow__::__TDetectorLight, posPixelX), ::Reflex::PRIVATE)
  .AddDataMember(type_9144, Reflex::Literal("posPixelY"), OffsetOf(__shadow__::__TDetectorLight, posPixelY), ::Reflex::PRIVATE)
  .AddDataMember(type_9144, Reflex::Literal("posPixelZ"), OffsetOf(__shadow__::__TDetectorLight, posPixelZ), ::Reflex::PRIVATE)
  .AddDataMember(type_2488, Reflex::Literal("m_name"), OffsetOf(__shadow__::__TDetectorLight, m_name), ::Reflex::PRIVATE)
  .AddDataMember(type_52, Reflex::Literal("m_totPixels"), OffsetOf(__shadow__::__TDetectorLight, m_totPixels), ::Reflex::PRIVATE)
  .AddDataMember(type_52, Reflex::Literal("m_totDetectors"), OffsetOf(__shadow__::__TDetectorLight, m_totDetectors), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TDetectorLight -------------------
void __TDetectorLight_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_382), Reflex::Literal("setScintSizeX"), method_3533, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_382), Reflex::Literal("setScintSizeY"), method_3534, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_382), Reflex::Literal("setScintSizeZ"), method_3535, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382), Reflex::Literal("getScintSizeX"), method_3536, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382), Reflex::Literal("getScintSizeY"), method_3537, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382), Reflex::Literal("getScintSizeZ"), method_3538, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_382), Reflex::Literal("setLY"), method_3539, 0, "l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382), Reflex::Literal("getLY"), method_3540, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_382), Reflex::Literal("setFastScintTime"), method_3541, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382), Reflex::Literal("getFastScintTime"), method_3542, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382), Reflex::Literal("getRindex"), method_3543, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_382), Reflex::Literal("setRindex"), method_3544, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_52), Reflex::Literal("getFaceReflectivity"), method_3545, 0, "ii", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52, type_382), Reflex::Literal("setFaceReflectivity"), method_3546, 0, "ii;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52, type_52), Reflex::Literal("setNdet"), method_3547, 0, "iface;N", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52, type_52), Reflex::Literal("getNdet"), method_3548, 0, "iface", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52, type_52, type_52), Reflex::Literal("getDetGlobalID"), method_3549, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52, type_9090, type_9090), Reflex::Literal("getFaceDetIDfromGlobal"), method_3550, 0, "global;iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52, type_52, type_52, type_52), Reflex::Literal("getPixelGlobalID"), method_3551, 0, "iface;idetector;ipixel", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52, type_9090, type_9090, type_9090), Reflex::Literal("getFaceDetPixelIDfromGlobal"), method_3552, 0, "global;iface;idetector;ipixel", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("getTotDetectors"), method_3553, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("getTotPixels"), method_3554, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52, type_52, type_382), Reflex::Literal("setDetSizeX"), method_3555, 0, "iface;idetector;s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52, type_52, type_382), Reflex::Literal("setDetSizeY"), method_3556, 0, "iface;idetector;s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_52, type_52), Reflex::Literal("getDetSizeX"), method_3557, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_52, type_52), Reflex::Literal("getDetSizeY"), method_3558, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_52, type_52), Reflex::Literal("getDetCenterX"), method_3559, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_52, type_52), Reflex::Literal("getDetCenterY"), method_3560, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_52, type_52), Reflex::Literal("getDetRotation"), method_3561, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52, type_52, type_382), Reflex::Literal("setDetCenterX"), method_3562, 0, "iface;idetector;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52, type_52, type_382), Reflex::Literal("setDetCenterY"), method_3563, 0, "iface;idetector;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52, type_52, type_382), Reflex::Literal("setDetRotation"), method_3564, 0, "iface;idetector;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52, type_52, type_2488), Reflex::Literal("setDetName"), method_3565, 0, "iface;idetector;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2488, type_52, type_52), Reflex::Literal("getDetName"), method_3566, 0, "iface;idetector", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52, type_52, type_52), Reflex::Literal("setNPixelsX"), method_3567, 0, "iface;idetector;N", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52, type_52, type_52), Reflex::Literal("setNPixelsY"), method_3568, 0, "iface;idetector;N", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52, type_52, type_52), Reflex::Literal("getNPixelsX"), method_3569, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52, type_52, type_52), Reflex::Literal("getNPixelsY"), method_3570, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52, type_52, type_52), Reflex::Literal("getNPixels"), method_3571, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_52, type_52), Reflex::Literal("getPixelSizeX"), method_3572, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_52, type_52), Reflex::Literal("getPixelSizeY"), method_3573, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_52, type_52), Reflex::Literal("getCouplingThickness"), method_3574, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_52, type_52), Reflex::Literal("getCouplingRIndex"), method_3575, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52, type_52, type_382), Reflex::Literal("setDetTimeRes"), method_3576, 0, "iface;idetector;t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_52, type_52), Reflex::Literal("getDetTimeRes"), method_3577, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_52, type_52), Reflex::Literal("getDetQE"), method_3578, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52, type_52, type_382), Reflex::Literal("setDetQE"), method_3579, 0, "iface;idetector;QE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382, type_52, type_52), Reflex::Literal("getDetReflectivity"), method_3580, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52, type_52, type_382), Reflex::Literal("setDetReflectivity"), method_3581, 0, "iface;idetector;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52, type_52, type_52), Reflex::Literal("isDetPresent"), method_3582, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_2488), Reflex::Literal("setName"), method_3583, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2488), Reflex::Literal("getName"), method_3584, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1067, type_52, type_52, type_52), Reflex::Literal("getPosPixel"), method_3585, 0, "iface;idetector;ipixel", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1067, type_52), Reflex::Literal("getFaceNormal"), method_3586, 0, "iface", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1067, type_52), Reflex::Literal("getFaceT1"), method_3587, 0, "iface", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1067, type_52), Reflex::Literal("getFaceT2"), method_3588, 0, "iface", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1067, type_52, type_52), Reflex::Literal("getDetectorNormal"), method_3589, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1067, type_52, type_52), Reflex::Literal("getDetectorT1"), method_3590, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1067, type_52, type_52), Reflex::Literal("getDetectorT2"), method_3591, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46), Reflex::Literal("init"), method_3592, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_9061), Reflex::Literal("PrintPixels"), method_3593, 0, "option=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_9061), Reflex::Literal("Print"), method_3594, 0, "option=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859), Reflex::Literal("Class"), method_3595, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("Class_Name"), method_3596, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1776), Reflex::Literal("Class_Version"), method_3597, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46), Reflex::Literal("Dictionary"), method_3598, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859), Reflex::Literal("IsA"), method_3599, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_9022), Reflex::Literal("ShowMembers"), method_3600, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_5205), Reflex::Literal("Streamer"), method_3601, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_5205), Reflex::Literal("StreamerNVirtual"), method_3602, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("DeclFileName"), method_3603, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("ImplFileLine"), method_3604, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("ImplFileName"), method_3605, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("DeclFileLine"), method_3606, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TMCParticle -------------------------------
static  void operator_3710( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TMCParticle*)o)->operator=)(*(const ::TMCParticle*)arg[0]);
  else   (((::TMCParticle*)o)->operator=)(*(const ::TMCParticle*)arg[0]);
}

static void constructor_3711( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMCParticle(*(const ::TMCParticle*)arg[0]);
  else ::new(mem) ::TMCParticle(*(const ::TMCParticle*)arg[0]);
}

static void constructor_3712( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMCParticle();
  else ::new(mem) ::TMCParticle();
}

static void destructor_3713(void*, void * o, const std::vector<void*>&, void *) {
(((::TMCParticle*)o)->::TMCParticle::~TMCParticle)();
}
static  void method_3714( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCParticle*)o)->Clear)((::Option_t*)arg[0]);
}

static  void method_3715( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TMCParticle*)o)->getEdep)());
  else   (((const ::TMCParticle*)o)->getEdep)();
}

static  void method_3716( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCParticle*)o)->setEdep)(*(double*)arg[0]);
}

static  void method_3717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TMCParticle*)o)->getEdepVis)());
  else   (((const ::TMCParticle*)o)->getEdepVis)();
}

static  void method_3718( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCParticle*)o)->setEdepVis)(*(double*)arg[0]);
}

static  void method_3719( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TMCParticle*)o)->getId)());
  else   (((const ::TMCParticle*)o)->getId)();
}

static  void method_3720( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCParticle*)o)->setId)(*(int*)arg[0]);
}

static  void method_3721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TMCParticle*)o)->getParentId)());
  else   (((const ::TMCParticle*)o)->getParentId)();
}

static  void method_3722( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCParticle*)o)->setParentId)(*(int*)arg[0]);
}

static  void method_3723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TMCParticle*)o)->getPid)());
  else   (((const ::TMCParticle*)o)->getPid)();
}

static  void method_3724( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCParticle*)o)->setPid)(*(int*)arg[0]);
}

static  void method_3725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCParticle*)o)->Class)());
  else   (((::TMCParticle*)o)->Class)();
}

static  void method_3726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCParticle*)o)->Class_Name)());
  else   (((::TMCParticle*)o)->Class_Name)();
}

static  void method_3727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TMCParticle*)o)->Class_Version)());
  else   (((::TMCParticle*)o)->Class_Version)();
}

static  void method_3728( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TMCParticle*)o)->Dictionary)();
}

static  void method_3729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMCParticle*)o)->IsA)());
  else   (((const ::TMCParticle*)o)->IsA)();
}

static  void method_3730( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCParticle*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_3731( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCParticle*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_3732( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCParticle*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_3733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCParticle*)o)->DeclFileName)());
  else   (((::TMCParticle*)o)->DeclFileName)();
}

static  void method_3734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMCParticle*)o)->ImplFileLine)());
  else   (((::TMCParticle*)o)->ImplFileLine)();
}

static  void method_3735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCParticle*)o)->ImplFileName)());
  else   (((::TMCParticle*)o)->ImplFileName)();
}

static  void method_3736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMCParticle*)o)->DeclFileLine)());
  else   (((::TMCParticle*)o)->DeclFileLine)();
}

static void method_newdel_514( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TMCParticle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TMCParticle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TMCParticle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TMCParticle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TMCParticle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TMCParticle,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TMCParticle -------------------------------
void __TMCParticle_db_datamem(Reflex::Class*);
void __TMCParticle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TMCParticle_datamem_bld(&__TMCParticle_db_datamem);
Reflex::GenreflexMemberBuilder __TMCParticle_funcmem_bld(&__TMCParticle_db_funcmem);
void __TMCParticle_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TMCParticle"), typeid(::TMCParticle), sizeof(::TMCParticle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TMCParticle::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1386, ::Reflex::BaseOffset< ::TMCParticle, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9476, type_9477), Reflex::Literal("operator="), operator_3710, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9477), Reflex::Literal("TMCParticle"), constructor_3711, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TMCParticle"), constructor_3712, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TMCParticle"), destructor_3713, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_514, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TMCParticle_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TMCParticle_funcmem_bld);
}

//------Delayed data member builder for class TMCParticle -------------------
void __TMCParticle_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_52, Reflex::Literal("m_pid"), OffsetOf(__shadow__::__TMCParticle, m_pid), ::Reflex::PRIVATE)
  .AddDataMember(type_52, Reflex::Literal("m_id"), OffsetOf(__shadow__::__TMCParticle, m_id), ::Reflex::PRIVATE)
  .AddDataMember(type_52, Reflex::Literal("m_parentId"), OffsetOf(__shadow__::__TMCParticle, m_parentId), ::Reflex::PRIVATE)
  .AddDataMember(type_382, Reflex::Literal("m_edep"), OffsetOf(__shadow__::__TMCParticle, m_edep), ::Reflex::PRIVATE)
  .AddDataMember(type_382, Reflex::Literal("m_edepVis"), OffsetOf(__shadow__::__TMCParticle, m_edepVis), ::Reflex::PRIVATE)
  .AddDataMember(type_9120, Reflex::Literal("m_x0"), OffsetOf(__shadow__::__TMCParticle, m_x0), ::Reflex::PRIVATE)
  .AddDataMember(type_9120, Reflex::Literal("m_P0"), OffsetOf(__shadow__::__TMCParticle, m_P0), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TMCParticle -------------------
void __TMCParticle_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_9061), Reflex::Literal("Clear"), method_3714, 0, "option", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382), Reflex::Literal("getEdep"), method_3715, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_382), Reflex::Literal("setEdep"), method_3716, 0, "edep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_382), Reflex::Literal("getEdepVis"), method_3717, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_382), Reflex::Literal("setEdepVis"), method_3718, 0, "edepVis", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("getId"), method_3719, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52), Reflex::Literal("setId"), method_3720, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("getParentId"), method_3721, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52), Reflex::Literal("setParentId"), method_3722, 0, "parentId", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("getPid"), method_3723, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_52), Reflex::Literal("setPid"), method_3724, 0, "pid", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859), Reflex::Literal("Class"), method_3725, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("Class_Name"), method_3726, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1776), Reflex::Literal("Class_Version"), method_3727, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46), Reflex::Literal("Dictionary"), method_3728, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859), Reflex::Literal("IsA"), method_3729, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_9022), Reflex::Literal("ShowMembers"), method_3730, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_5205), Reflex::Literal("Streamer"), method_3731, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_5205), Reflex::Literal("StreamerNVirtual"), method_3732, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("DeclFileName"), method_3733, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("ImplFileLine"), method_3734, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("ImplFileName"), method_3735, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("DeclFileLine"), method_3736, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TEvent -------------------------------
static  void operator_4953( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TEvent*)o)->operator=)(*(const ::TEvent*)arg[0]);
  else   (((::TEvent*)o)->operator=)(*(const ::TEvent*)arg[0]);
}

static void constructor_4954( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TEvent(*(const ::TEvent*)arg[0]);
  else ::new(mem) ::TEvent(*(const ::TEvent*)arg[0]);
}

static void constructor_4957( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TEvent();
  else ::new(mem) ::TEvent();
}

static void destructor_4958(void*, void * o, const std::vector<void*>&, void *) {
(((::TEvent*)o)->::TEvent::~TEvent)();
}
static  void method_4959( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::TEvent*)o)->Clear)();
  }
  else if ( arg.size() == 1 ) { 
    (((::TEvent*)o)->Clear)((::Option_t*)arg[0]);
  }
}

static  void method_4960( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TEvent*)o)->clearCollections)();
}

static  void method_4961( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TEvent*)o)->clearObjects)();
}

static  void method_4962( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::TEvent*)o)->printObjects)();
}

static  void method_4963( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEvent*)o)->addObject)((::TObject*)arg[0]);
}

static  void method_4964( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TEvent*)o)->getObject)(*(::std::string*)arg[0]));
  else   (((const ::TEvent*)o)->getObject)(*(::std::string*)arg[0]);
}

static  void method_4965( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TEvent*)o)->hasObject)(*(::std::string*)arg[0]));
  else   (((const ::TEvent*)o)->hasObject)(*(::std::string*)arg[0]);
}

static  void method_4966( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TEvent*)o)->getNcollections)());
  else   (((const ::TEvent*)o)->getNcollections)();
}

static  void method_4967( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::TEvent*)o)->printCollections)();
}

static  void method_4968( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::TEvent*)o)->addCollection)((::TClonesArray*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::TEvent*)o)->addCollection)((::TClonesArray*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_4969( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TEvent*)o)->getCollection)((::TClass*)arg[0],
    *(::std::string*)arg[1]));
  else   (((const ::TEvent*)o)->getCollection)((::TClass*)arg[0],
    *(::std::string*)arg[1]);
}

static  void method_4970( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEvent*)o)->deleteCollection)((::TClass*)arg[0],
    *(::std::string*)arg[1]);
}

static  void method_4971( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TEvent*)o)->hasCollection)((::TClonesArray*)arg[0]));
  else   (((const ::TEvent*)o)->hasCollection)((::TClonesArray*)arg[0]);
}

static  void method_4972( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TEvent*)o)->hasCollection)((::TClass*)arg[0],
    *(::std::string*)arg[1]));
  else   (((const ::TEvent*)o)->hasCollection)((::TClass*)arg[0],
    *(::std::string*)arg[1]);
}

static  void method_4973( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEvent*)o)->Class)());
  else   (((::TEvent*)o)->Class)();
}

static  void method_4974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEvent*)o)->Class_Name)());
  else   (((::TEvent*)o)->Class_Name)();
}

static  void method_4975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TEvent*)o)->Class_Version)());
  else   (((::TEvent*)o)->Class_Version)();
}

static  void method_4976( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TEvent*)o)->Dictionary)();
}

static  void method_4977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TEvent*)o)->IsA)());
  else   (((const ::TEvent*)o)->IsA)();
}

static  void method_4978( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEvent*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4979( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEvent*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4980( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEvent*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEvent*)o)->DeclFileName)());
  else   (((::TEvent*)o)->DeclFileName)();
}

static  void method_4982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TEvent*)o)->ImplFileLine)());
  else   (((::TEvent*)o)->ImplFileLine)();
}

static  void method_4983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEvent*)o)->ImplFileName)());
  else   (((::TEvent*)o)->ImplFileName)();
}

static  void method_4984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TEvent*)o)->DeclFileLine)());
  else   (((::TEvent*)o)->DeclFileLine)();
}

static void method_newdel_1521( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TEvent,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TEvent -------------------------------
void __TEvent_db_datamem(Reflex::Class*);
void __TEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TEvent_datamem_bld(&__TEvent_db_datamem);
Reflex::GenreflexMemberBuilder __TEvent_funcmem_bld(&__TEvent_db_funcmem);
void __TEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TEvent"), typeid(::TEvent), sizeof(::TEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TEvent::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1386, ::Reflex::BaseOffset< ::TEvent, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_9789), Reflex::Literal("operator="), operator_4953, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9789), Reflex::Literal("TEvent"), constructor_4954, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TEvent"), constructor_4957, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TEvent"), destructor_4958, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1521, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TEvent_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TEvent_funcmem_bld);
}

//------Delayed data member builder for class TEvent -------------------
void __TEvent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1640, Reflex::Literal("m_objects"), OffsetOf(__shadow__::__TEvent, m_objects), ::Reflex::PRIVATE)
  .AddDataMember(type_2433, Reflex::Literal("m_collections"), OffsetOf(__shadow__::__TEvent, m_collections), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TEvent -------------------
void __TEvent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_9061), Reflex::Literal("Clear"), method_4959, 0, "option=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46), Reflex::Literal("clearCollections"), method_4960, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46), Reflex::Literal("clearObjects"), method_4961, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46), Reflex::Literal("printObjects"), method_4962, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_7910), Reflex::Literal("addObject"), method_4963, 0, "obj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7910, type_2488), Reflex::Literal("getObject"), method_4964, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52, type_2488), Reflex::Literal("hasObject"), method_4965, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("getNcollections"), method_4966, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46), Reflex::Literal("printCollections"), method_4967, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_7034, type_52), Reflex::Literal("addCollection"), method_4968, 0, "coll;checkAlreadyExists=1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7034, type_859, type_2488), Reflex::Literal("getCollection"), method_4969, 0, "theClass;name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_859, type_2488), Reflex::Literal("deleteCollection"), method_4970, 0, "theClass;name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52, type_7034), Reflex::Literal("hasCollection"), method_4971, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52, type_859, type_2488), Reflex::Literal("hasCollection"), method_4972, 0, "theClass;name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859), Reflex::Literal("Class"), method_4973, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("Class_Name"), method_4974, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1776), Reflex::Literal("Class_Version"), method_4975, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46), Reflex::Literal("Dictionary"), method_4976, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859), Reflex::Literal("IsA"), method_4977, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_9022), Reflex::Literal("ShowMembers"), method_4978, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_5205), Reflex::Literal("Streamer"), method_4979, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_5205), Reflex::Literal("StreamerNVirtual"), method_4980, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("DeclFileName"), method_4981, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("ImplFileLine"), method_4982, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("ImplFileName"), method_4983, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("DeclFileLine"), method_4984, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TNamedContainer -------------------------------
static  void operator_5801( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TNamedContainer*)o)->operator=)(*(const ::TNamedContainer*)arg[0]);
  else   (((::TNamedContainer*)o)->operator=)(*(const ::TNamedContainer*)arg[0]);
}

static void constructor_5802( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TNamedContainer(*(const ::TNamedContainer*)arg[0]);
  else ::new(mem) ::TNamedContainer(*(const ::TNamedContainer*)arg[0]);
}

static void constructor_5803( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TNamedContainer();
  else ::new(mem) ::TNamedContainer();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TNamedContainer((::TObject*)arg[0]);
  else ::new(mem) ::TNamedContainer((::TObject*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TNamedContainer((::TObject*)arg[0],
      *(::std::string*)arg[1]);
  else ::new(mem) ::TNamedContainer((::TObject*)arg[0],
      *(::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TNamedContainer((::TObject*)arg[0],
      *(::std::string*)arg[1],
      *(::std::string*)arg[2]);
  else ::new(mem) ::TNamedContainer((::TObject*)arg[0],
      *(::std::string*)arg[1],
      *(::std::string*)arg[2]);
  }
}

static void destructor_5804(void*, void * o, const std::vector<void*>&, void *) {
(((::TNamedContainer*)o)->::TNamedContainer::~TNamedContainer)();
}
static  void method_5805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TNamedContainer*)o)->getObject)());
  else   (((::TNamedContainer*)o)->getObject)();
}

static  void method_5806( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TNamedContainer*)o)->setObject)((::TObject*)arg[0]);
}

static  void method_5807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TNamedContainer*)o)->Class)());
  else   (((::TNamedContainer*)o)->Class)();
}

static  void method_5808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TNamedContainer*)o)->Class_Name)());
  else   (((::TNamedContainer*)o)->Class_Name)();
}

static  void method_5809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TNamedContainer*)o)->Class_Version)());
  else   (((::TNamedContainer*)o)->Class_Version)();
}

static  void method_5810( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TNamedContainer*)o)->Dictionary)();
}

static  void method_5811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TNamedContainer*)o)->IsA)());
  else   (((const ::TNamedContainer*)o)->IsA)();
}

static  void method_5812( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TNamedContainer*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5813( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TNamedContainer*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5814( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TNamedContainer*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TNamedContainer*)o)->DeclFileName)());
  else   (((::TNamedContainer*)o)->DeclFileName)();
}

static  void method_5816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TNamedContainer*)o)->ImplFileLine)());
  else   (((::TNamedContainer*)o)->ImplFileLine)();
}

static  void method_5817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TNamedContainer*)o)->ImplFileName)());
  else   (((::TNamedContainer*)o)->ImplFileName)();
}

static  void method_5818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TNamedContainer*)o)->DeclFileLine)());
  else   (((::TNamedContainer*)o)->DeclFileLine)();
}

static void constructor_x15( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TNamedContainer();
  else ::new(mem) ::TNamedContainer();
}

static void method_newdel_2262( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TNamedContainer >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TNamedContainer >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TNamedContainer >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TNamedContainer >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TNamedContainer >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::TNamedContainer,::TNamed >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TNamedContainer,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TNamedContainer -------------------------------
void __TNamedContainer_db_datamem(Reflex::Class*);
void __TNamedContainer_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TNamedContainer_datamem_bld(&__TNamedContainer_db_datamem);
Reflex::GenreflexMemberBuilder __TNamedContainer_funcmem_bld(&__TNamedContainer_db_funcmem);
void __TNamedContainer_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TNamedContainer"), typeid(::TNamedContainer), sizeof(::TNamedContainer), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TNamedContainer::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_198, ::Reflex::BaseOffset< ::TNamedContainer, ::TNamed >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9897, type_9898), Reflex::Literal("operator="), operator_5801, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9898), Reflex::Literal("TNamedContainer"), constructor_5802, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7910, type_2488, type_2488), Reflex::Literal("TNamedContainer"), constructor_5803, 0, "obj=0;m_name=\"\";m_title=\"\"", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TNamedContainer"), destructor_5804, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TNamedContainer"), constructor_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2262, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TNamedContainer_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TNamedContainer_funcmem_bld);
}

//------Delayed data member builder for class TNamedContainer -------------------
void __TNamedContainer_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7910, Reflex::Literal("m_object"), OffsetOf(__shadow__::__TNamedContainer, m_object), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TNamedContainer -------------------
void __TNamedContainer_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7910), Reflex::Literal("getObject"), method_5805, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_7910), Reflex::Literal("setObject"), method_5806, 0, "obj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859), Reflex::Literal("Class"), method_5807, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("Class_Name"), method_5808, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1776), Reflex::Literal("Class_Version"), method_5809, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46), Reflex::Literal("Dictionary"), method_5810, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859), Reflex::Literal("IsA"), method_5811, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_9022), Reflex::Literal("ShowMembers"), method_5812, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_5205), Reflex::Literal("Streamer"), method_5813, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_5205), Reflex::Literal("StreamerNVirtual"), method_5814, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("DeclFileName"), method_5815, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("ImplFileLine"), method_5816, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2847), Reflex::Literal("ImplFileName"), method_5817, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_52), Reflex::Literal("DeclFileLine"), method_5818, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __TDetectorUtils_dict(); 
      __TXMLHandler_dict(); 
      __TMCTruth_dict(); 
      __TDetectorLight_dict(); 
      __TMCParticle_dict(); 
      __TEvent_dict(); 
      __TNamedContainer_dict(); 
    }
    ~Dictionaries() {
      type_16.Unload(); // class TDetectorUtils 
      type_122.Unload(); // class TXMLHandler 
      type_318.Unload(); // class TMCTruth 
      type_448.Unload(); // class TDetectorLight 
      type_514.Unload(); // class TMCParticle 
      type_1521.Unload(); // class TEvent 
      type_2262.Unload(); // class TNamedContainer 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
