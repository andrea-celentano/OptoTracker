// Generated at Thu May 21 12:15:50 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/usr/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/usr/bin/c++"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic "
  GCCXML_EXECUTABLE="/usr/bin/gccxml_cc1plus"
  GCCXML_CPP="/usr/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__FLT_MIN__='1.17549435e-38F' -D__CHAR_BIT__='8' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='4.9406564584124654e-324' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__LP64__='1' -D__GNUC_PATCHLEVEL__='7' -D__DEC64_MAX_EXP__='385' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__unix='1' -D__LDBL_MAX_EXP__='16384' -D__linux__='1' -D__SCHAR_MAX__='127' -D__DBL_DIG__='15' -D_FORTIFY_SOURCE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209290e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__SIZEOF_LONG__='8' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='1.7976931348623157e+308' -D__DBL_HAS_INFINITY__='1' -D__DEC32_MIN_EXP__='(-94)' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__DBL_MIN__='2.2250738585072014e-308' -D__FLT_MIN_10_EXP__='(-37)' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__DBL_HAS_DENORM__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.4.7 20120313 (Red Hat 4.4.7-11)"' -D__DEC64_EPSILON__='1E-15DD' -D__DEC128_MIN_EXP__='(-6142)' -Dunix='1' -D__SIZE_TYPE__='long unsigned int' -D__ELF__='1' -D__FLT_RADIX__='2' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__GNUC_RH_RELEASE__='11' -D__k8='1' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__DEC64_MANT_DIG__='16' -D__DEC32_MAX_EXP__='97' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__k8__='1' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__DEC64_MIN_EXP__='(-382)' -D__FLT_DIG__='6' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__FLT_MAX_EXP__='128' -D__DBL_MANT_DIG__='53' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__SSP__='1' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='2.2204460492503131e-16' -D_LP64='1' -D__SIZEOF_WCHAR_T__='4' -D__DEC_EVAL_METHOD__='2' -D__INTMAX_MAX__='9223372036854775807L' -D__FLT_DENORM_MIN__='1.40129846e-45F' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282347e+38F' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='4' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__GNUC_GNU_INLINE__='1' -D_GNU_SOURCE='1' -iwrapper"/usr/share/gccxml-0.9/GCC/4.4" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/backward" -isystem"/usr/local/include" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/usr/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.4.7 20120313 (Red Hat 4.4.7-11)
Copyright (C) 2010 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/project/Gruppo3/fiber5/celentano/OptoTracker/packages/Reconstruction/include/ReconstructionClasses.hh"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("CLHEP") );
  ::Reflex::Type type_151 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_704 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_258 = ::Reflex::TypeBuilder(Reflex::Literal("TH1D"));
  ::Reflex::Type type_266 = ::Reflex::TypeBuilder(Reflex::Literal("TH2D"));
  ::Reflex::Type type_208 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1559 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1067 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_252 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_3083 = ::Reflex::TypeBuilder(Reflex::Literal("TTree"));
  ::Reflex::Type type_1110 = ::Reflex::TypeBuilder(Reflex::Literal("TList"));
  ::Reflex::Type type_905 = ::Reflex::TypeBuilder(Reflex::Literal("TBranch"));
  ::Reflex::Type type_2344 = ::Reflex::TypeBuilder(Reflex::Literal("TRecon"));
  ::Reflex::Type type_908 = ::Reflex::TypeBuilder(Reflex::Literal("TRandom3"));
  ::Reflex::Type type_1163 = ::Reflex::TypeBuilder(Reflex::Literal("TObject"));
  ::Reflex::Type type_439 = ::Reflex::TypeBuilder(Reflex::Literal("TSelector"));
  ::Reflex::Type type_2069 = ::Reflex::TypeBuilder(Reflex::Literal("long long"));
  ::Reflex::Type type_183 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_2016 = ::Reflex::TypeBuilder(Reflex::Literal("CLHEP::Hep3Vector"));
  ::Reflex::Type type_2245 = ::Reflex::TypeBuilder(Reflex::Literal("CLHEP::HepRotation"));
  ::Reflex::Type type_3206 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<TH1D*>"));
  ::Reflex::Type type_3205 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<TH2D*>"));
  ::Reflex::Type type_4609 = ::Reflex::TypeBuilder(Reflex::Literal("CLHEP::HepAxisAngle"));
  ::Reflex::Type type_3552 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<char>"));
  ::Reflex::Type type_2652 = ::Reflex::TypeBuilder(Reflex::Literal("TOpNoviceSelectorRaw"));
  ::Reflex::Type type_6979 = ::Reflex::TypeBuilder(Reflex::Literal("CLHEP::HepEulerAngles"));
  ::Reflex::Type type_818 = ::Reflex::TypeBuilder(Reflex::Literal("TOpNoviceDetectorLight"));
  ::Reflex::Type type_3342 = ::Reflex::TypeBuilder(Reflex::Literal("std::char_traits<char>"));
  ::Reflex::Type type_3251 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_3207 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<OpNovicePMTHit*>"));
  ::Reflex::Type type_16837 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>::_Alloc_hider"));
  ::Reflex::Type type_9171 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >"));
  ::Reflex::Type type_9206 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >"));
  ::Reflex::Type type_3688 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,std::basic_string<char> > >"));
  ::Reflex::Type type_3687 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> > >"));
  ::Reflex::Type type_2016c = ::Reflex::ConstBuilder(type_2016);
  ::Reflex::Type type_20506 = ::Reflex::ReferenceBuilder(type_2016c);
  ::Reflex::Type type_15510 = ::Reflex::ReferenceBuilder(type_252);
  ::Reflex::Type type_20610 = ::Reflex::ReferenceBuilder(type_2016);
  ::Reflex::Type type_2245c = ::Reflex::ConstBuilder(type_2245);
  ::Reflex::Type type_20502 = ::Reflex::ReferenceBuilder(type_2245c);
  ::Reflex::Type type_4609c = ::Reflex::ConstBuilder(type_4609);
  ::Reflex::Type type_20616 = ::Reflex::ReferenceBuilder(type_4609c);
  ::Reflex::Type type_6979c = ::Reflex::ConstBuilder(type_6979);
  ::Reflex::Type type_20808 = ::Reflex::ReferenceBuilder(type_6979c);
  ::Reflex::Type type_6729 = ::Reflex::PointerBuilder(type_3083);
  ::Reflex::Type type_24207 = ::Reflex::PointerBuilder(type_3207);
  ::Reflex::Type type_6728 = ::Reflex::PointerBuilder(type_905);
  ::Reflex::Type type_20386 = ::Reflex::PointerBuilder(type_818);
  ::Reflex::Type type_24208 = ::Reflex::PointerBuilder(type_2344);
  ::Reflex::Type type_24209 = ::Reflex::PointerBuilder(type_908);
  ::Reflex::Type type_9365 = ::Reflex::PointerBuilder(type_252);
  ::Reflex::Type type_24210 = ::Reflex::PointerBuilder(type_9365);
  ::Reflex::Type type_3804 = ::Reflex::PointerBuilder(type_151);
  ::Reflex::Type type_24211 = ::Reflex::PointerBuilder(type_3804);
  ::Reflex::Type type_15437 = ::Reflex::PointerBuilder(type_258);
  ::Reflex::Type type_15371 = ::Reflex::PointerBuilder(type_266);
  ::Reflex::Type type_24212 = ::Reflex::ArrayBuilder(type_15371, 6);
  ::Reflex::Type type_24213 = ::Reflex::ArrayBuilder(type_3206, 6);
  ::Reflex::Type type_24214 = ::Reflex::ArrayBuilder(type_3205, 6);
  ::Reflex::Type type_3263 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_3251);
  ::Reflex::Type type_24215 = ::Reflex::ArrayBuilder(type_3263, 6);
  ::Reflex::Type type_938 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Int_t"), type_151);
  ::Reflex::Type type_705 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Bool_t"), type_704);
  ::Reflex::Type type_2070 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Long64_t"), type_2069);
  ::Reflex::Type type_1067c = ::Reflex::ConstBuilder(type_1067);
  ::Reflex::Type type_3803 = ::Reflex::PointerBuilder(type_1067c);
  ::Reflex::Type type_17462 = ::Reflex::PointerBuilder(type_1163);
  ::Reflex::Type type_20122 = ::Reflex::PointerBuilder(type_1110);
  ::Reflex::Type type_1334 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_183);
  ::Reflex::Type type_813 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("ptrdiff_t"), type_208);
  ::Reflex::Type type_15150 = ::Reflex::ReferenceBuilder(type_1067);
  ::Reflex::Type type_16827 = ::Reflex::ReferenceBuilder(type_1067c);
  ::Reflex::Type type_2859 = ::Reflex::PointerBuilder(type_1067);
  ::Reflex::Type type_3552c = ::Reflex::ConstBuilder(type_3552);
  ::Reflex::Type type_24898 = ::Reflex::ReferenceBuilder(type_3552c);
  ::Reflex::Type type_3251c = ::Reflex::ConstBuilder(type_3251);
  ::Reflex::Type type_15161 = ::Reflex::ReferenceBuilder(type_3251c);
  ::Reflex::Type type_15172 = ::Reflex::ReferenceBuilder(type_3251);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __CLHEP__Hep3Vector
#undef __CLHEP__Hep3Vector
#endif
class __CLHEP__Hep3Vector {
  public:
  __CLHEP__Hep3Vector();
  double dx;
  double dy;
  double dz;
};
#ifdef __TOpNoviceSelectorRaw
#undef __TOpNoviceSelectorRaw
#endif
class __TOpNoviceSelectorRaw : public ::TSelector {
  public:
  __TOpNoviceSelectorRaw();
  virtual ~__TOpNoviceSelectorRaw() throw();
  virtual ::Int_t GetEntry(long long, int) throw();
  virtual void SetInputList(TList*) throw();
  virtual void Init(TTree*) throw();
  virtual ::Bool_t Process(long long) throw();
  virtual void SetOption(char const*) throw();
  virtual ::Bool_t Notify() throw();
  virtual void SlaveTerminate() throw();
  virtual void SetObject(TObject*) throw();
  virtual void Begin(TTree*) throw();
  virtual void Terminate() throw();
  virtual ::TList* GetOutputList() const throw();
  virtual ::Int_t Version() const throw();
  virtual void SlaveBegin(TTree*) throw();
  void* fChain;
  void* raw;
  void* b_raw;
  void* m_detector;
  void* m_recon;
  void* m_rand;
  int m_seed;
  void* q;
  void* tFirst;
  void* N;
  void* hX;
  void* hY;
  void* hZ;
  void* hX_1;
  void* hY_1;
  void* hZ_1;
  void* hX_2;
  void* hY_2;
  void* hZ_2;
  void* hXY;
  void* hXZ;
  void* hYZ;
  void* hXY_1;
  void* hXZ_1;
  void* hYZ_1;
  void* hXY_2;
  void* hXZ_2;
  void* hYZ_2;
  void* hPixel0[6];
  void* hTheta;
  void* hPhi;
  void* hNPhotons;
  void* hT0;
  void* hTau;
  ::std::vector<TH1D*> hCharge[6];
  ::std::vector<TH1D*> hTime[6];
  ::std::vector<TH2D*> hTimeVsCharge[6];
  ::std::string hPixel0Title[6];
};
#ifdef __std__basic_string_char_
#undef __std__basic_string_char_
#endif
struct __std__basic_string_char_ {
  public:
  __std__basic_string_char_();
#ifdef __std__basic_string_char____Rep_base
#undef __std__basic_string_char____Rep_base
#endif
  struct __std__basic_string_char____Rep_base {
    public:
    __std__basic_string_char____Rep_base();
    ::size_t _M_length;
    ::size_t _M_capacity;
    ::_Atomic_word _M_refcount;
  };
#ifdef __std__basic_string_char____Rep
#undef __std__basic_string_char____Rep
#endif
  struct __std__basic_string_char____Rep :   public __std__basic_string_char____Rep_base   {
    public:
    __std__basic_string_char____Rep();
  };
#ifdef __std__basic_string_char____Alloc_hider
#undef __std__basic_string_char____Alloc_hider
#endif
  struct __std__basic_string_char____Alloc_hider :   public ::std::allocator<char>   {
    public:
    __std__basic_string_char____Alloc_hider();
    void* _M_p;
  };
  __std__basic_string_char____Alloc_hider _M_dataplus;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class Hep3Vector -------------------------------
static void constructor_9530( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector();
  else ::new(mem) ::CLHEP::Hep3Vector();
}

static void constructor_9531( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0]);
  else ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0]);
}

static void constructor_9532( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0],
      *(double*)arg[1]);
}

static void constructor_9533( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
}

static void constructor_9534( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else ::new(mem) ::CLHEP::Hep3Vector(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static void destructor_9535(void*, void * o, const std::vector<void*>&, void *) {
(((::CLHEP::Hep3Vector*)o)->::CLHEP::Hep3Vector::~Hep3Vector)();
}
static  void operator_9536( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->operator())(*(int*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator())(*(int*)arg[0]);
}

static  void operator_9537( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->operator[])(*(int*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator[])(*(int*)arg[0]);
}

static  void operator_9538( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator())(*(int*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator())(*(int*)arg[0]);
}

static  void operator_9539( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator[])(*(int*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator[])(*(int*)arg[0]);
}

static  void method_9540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->x)());
  else   (((const ::CLHEP::Hep3Vector*)o)->x)();
}

static  void method_9541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->y)());
  else   (((const ::CLHEP::Hep3Vector*)o)->y)();
}

static  void method_9542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->z)());
  else   (((const ::CLHEP::Hep3Vector*)o)->z)();
}

static  void method_9543( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setX)(*(double*)arg[0]);
}

static  void method_9544( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setY)(*(double*)arg[0]);
}

static  void method_9545( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setZ)(*(double*)arg[0]);
}

static  void method_9546( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->set)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_9547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->phi)());
  else   (((const ::CLHEP::Hep3Vector*)o)->phi)();
}

static  void method_9548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->theta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->theta)();
}

static  void method_9549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->cosTheta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->cosTheta)();
}

static  void method_9550( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->cos2Theta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->cos2Theta)();
}

static  void method_9551( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->mag2)());
  else   (((const ::CLHEP::Hep3Vector*)o)->mag2)();
}

static  void method_9552( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->mag)());
  else   (((const ::CLHEP::Hep3Vector*)o)->mag)();
}

static  void method_9553( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setPhi)(*(double*)arg[0]);
}

static  void method_9554( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setTheta)(*(double*)arg[0]);
}

static  void method_9555( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setMag)(*(double*)arg[0]);
}

static  void method_9556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->perp2)());
  else   (((const ::CLHEP::Hep3Vector*)o)->perp2)();
}

static  void method_9557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->perp)());
  else   (((const ::CLHEP::Hep3Vector*)o)->perp)();
}

static  void method_9558( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setPerp)(*(double*)arg[0]);
}

static  void method_9559( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setCylTheta)(*(double*)arg[0]);
}

static  void method_9560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->perp2)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->perp2)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9561( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->perp)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->perp)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_9562( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_9563( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator==)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator==)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_9564( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator!=)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator!=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9565( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isNear)(*(const ::CLHEP::Hep3Vector*)arg[0]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isNear)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isNear)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isNear)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_9566( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->howNear)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->howNear)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9567( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->deltaR)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->deltaR)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_9568( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator+=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator+=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_9569( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator-=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator-=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_9570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->operator-)());
  else   (((const ::CLHEP::Hep3Vector*)o)->operator-)();
}

static  void operator_9571( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator*=)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator*=)(*(double*)arg[0]);
}

static  void operator_9572( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator/=)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator/=)(*(double*)arg[0]);
}

static  void method_9573( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->unit)());
  else   (((const ::CLHEP::Hep3Vector*)o)->unit)();
}

static  void method_9574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->orthogonal)());
  else   (((const ::CLHEP::Hep3Vector*)o)->orthogonal)();
}

static  void method_9575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->dot)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->dot)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9576( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->cross)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->cross)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9577( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->angle)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->angle)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->pseudoRapidity)());
  else   (((const ::CLHEP::Hep3Vector*)o)->pseudoRapidity)();
}

static  void method_9579( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setEta)(*(double*)arg[0]);
}

static  void method_9580( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setCylEta)(*(double*)arg[0]);
}

static  void method_9581( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotateX)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotateX)(*(double*)arg[0]);
}

static  void method_9582( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotateY)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotateY)(*(double*)arg[0]);
}

static  void method_9583( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotateZ)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotateZ)(*(double*)arg[0]);
}

static  void method_9584( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotateUz)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotateUz)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9585( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(double*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(double*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]);
}

static  void operator_9586( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator*=)(*(const ::CLHEP::HepRotation*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator*=)(*(const ::CLHEP::HepRotation*)arg[0]);
}

static  void method_9587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->transform)(*(const ::CLHEP::HepRotation*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->transform)(*(const ::CLHEP::HepRotation*)arg[0]);
}

static  void method_9588( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRThetaPhi)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_9589( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setREtaPhi)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_9590( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRhoPhiZ)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_9591( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRhoPhiTheta)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_9592( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRhoPhiEta)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_9593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getX)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getX)();
}

static  void method_9594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getY)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getY)();
}

static  void method_9595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getZ)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getZ)();
}

static  void method_9596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getR)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getR)();
}

static  void method_9597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getTheta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getTheta)();
}

static  void method_9598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getPhi)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getPhi)();
}

static  void method_9599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->r)());
  else   (((const ::CLHEP::Hep3Vector*)o)->r)();
}

static  void method_9600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->rho)());
  else   (((const ::CLHEP::Hep3Vector*)o)->rho)();
}

static  void method_9601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getRho)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getRho)();
}

static  void method_9602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->eta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->eta)();
}

static  void method_9603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getEta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getEta)();
}

static  void method_9604( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setR)(*(double*)arg[0]);
}

static  void method_9605( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRho)(*(double*)arg[0]);
}

static  void method_9606( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::CLHEP::Hep3Vector*)o)->compare)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->compare)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_9607( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator>)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator>)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_9608( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator<)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator<)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_9609( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator>=)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator>=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_9610( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator<=)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator<=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9611( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->diff2)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->diff2)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::CLHEP::Hep3Vector*)o)->setTolerance)(*(double*)arg[0]));
  else   (((::CLHEP::Hep3Vector*)o)->setTolerance)(*(double*)arg[0]);
}

static  void method_9613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::CLHEP::Hep3Vector*)o)->getTolerance)());
  else   (((::CLHEP::Hep3Vector*)o)->getTolerance)();
}

static  void method_9614( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isParallel)(*(const ::CLHEP::Hep3Vector*)arg[0]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isParallel)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isParallel)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isParallel)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_9615( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_9616( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->howParallel)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->howParallel)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9617( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->howOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->howOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->beta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->beta)();
}

static  void method_9619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->gamma)());
  else   (((const ::CLHEP::Hep3Vector*)o)->gamma)();
}

static  void method_9620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->coLinearRapidity)());
  else   (((const ::CLHEP::Hep3Vector*)o)->coLinearRapidity)();
}

static  void method_9621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->angle)());
  else   (((const ::CLHEP::Hep3Vector*)o)->angle)();
}

static  void method_9622( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->theta)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->theta)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9623( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->cosTheta)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->cosTheta)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9624( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->cos2Theta)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->cos2Theta)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->project)());
  else   (((const ::CLHEP::Hep3Vector*)o)->project)();
}

static  void method_9626( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->project)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->project)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9627( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->perpPart)());
  else   (((const ::CLHEP::Hep3Vector*)o)->perpPart)();
}

static  void method_9628( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->perpPart)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->perpPart)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9629( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->rapidity)());
  else   (((const ::CLHEP::Hep3Vector*)o)->rapidity)();
}

static  void method_9630( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->rapidity)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->rapidity)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9631( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->eta)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->eta)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->polarAngle)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->polarAngle)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9633( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->deltaPhi)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->deltaPhi)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9634( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->azimAngle)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->azimAngle)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_9635( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->polarAngle)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]));
  else   (((const ::CLHEP::Hep3Vector*)o)->polarAngle)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]);
}

static  void method_9636( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->azimAngle)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]));
  else   (((const ::CLHEP::Hep3Vector*)o)->azimAngle)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]);
}

static  void method_9637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(double*)arg[1]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(double*)arg[1]);
}

static  void method_9638( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::HepAxisAngle*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::HepAxisAngle*)arg[0]);
}

static  void method_9639( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::HepEulerAngles*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::HepEulerAngles*)arg[0]);
}

static  void method_9640( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static void method_newdel_2016( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Hep3Vector -------------------------------
void __CLHEP__Hep3Vector_db_datamem(Reflex::Class*);
void __CLHEP__Hep3Vector_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __CLHEP__Hep3Vector_datamem_bld(&__CLHEP__Hep3Vector_db_datamem);
Reflex::GenreflexMemberBuilder __CLHEP__Hep3Vector_funcmem_bld(&__CLHEP__Hep3Vector_db_funcmem);
void __CLHEP__Hep3Vector_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("CLHEP::Hep3Vector"), typeid(::CLHEP::Hep3Vector), sizeof(::CLHEP::Hep3Vector), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_118"), Reflex::Literal("X=0;Y=1;Z=2;NUM_COORDINATES=3;SIZE=3"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("_119"), Reflex::Literal("ToleranceTicks=100"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Hep3Vector"), constructor_9530, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_252), Reflex::Literal("Hep3Vector"), constructor_9531, 0, "x1", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_252, type_252), Reflex::Literal("Hep3Vector"), constructor_9532, 0, "x1;y1", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_252, type_252, type_252), Reflex::Literal("Hep3Vector"), constructor_9533, 0, "x1;y1;z1", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20506), Reflex::Literal("Hep3Vector"), constructor_9534, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Hep3Vector"), destructor_9535, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2016, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__CLHEP__Hep3Vector_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__CLHEP__Hep3Vector_funcmem_bld);
}

//------Delayed data member builder for class Hep3Vector -------------------
void __CLHEP__Hep3Vector_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_252, Reflex::Literal("dx"), OffsetOf(__shadow__::__CLHEP__Hep3Vector, dx), ::Reflex::PROTECTED)
  .AddDataMember(type_252, Reflex::Literal("dy"), OffsetOf(__shadow__::__CLHEP__Hep3Vector, dy), ::Reflex::PROTECTED)
  .AddDataMember(type_252, Reflex::Literal("dz"), OffsetOf(__shadow__::__CLHEP__Hep3Vector, dz), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Hep3Vector -------------------
void __CLHEP__Hep3Vector_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_151), Reflex::Literal("operator()"), operator_9536, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_151), Reflex::Literal("operator[]"), operator_9537, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15510, type_151), Reflex::Literal("operator()"), operator_9538, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15510, type_151), Reflex::Literal("operator[]"), operator_9539, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("x"), method_9540, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("y"), method_9541, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("z"), method_9542, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_252), Reflex::Literal("setX"), method_9543, 0, "x1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_252), Reflex::Literal("setY"), method_9544, 0, "y1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_252), Reflex::Literal("setZ"), method_9545, 0, "z1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_252, type_252, type_252), Reflex::Literal("set"), method_9546, 0, "x1;y1;z1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("phi"), method_9547, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("theta"), method_9548, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("cosTheta"), method_9549, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("cos2Theta"), method_9550, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("mag2"), method_9551, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("mag"), method_9552, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_252), Reflex::Literal("setPhi"), method_9553, 0, "ph", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_252), Reflex::Literal("setTheta"), method_9554, 0, "th", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_252), Reflex::Literal("setMag"), method_9555, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("perp2"), method_9556, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("perp"), method_9557, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_252), Reflex::Literal("setPerp"), method_9558, 0, "r1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_252), Reflex::Literal("setCylTheta"), method_9559, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506), Reflex::Literal("perp2"), method_9560, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506), Reflex::Literal("perp"), method_9561, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20610, type_20506), Reflex::Literal("operator="), operator_9562, 0, "p", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_704, type_20506), Reflex::Literal("operator=="), operator_9563, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_704, type_20506), Reflex::Literal("operator!="), operator_9564, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_704, type_20506, type_252), Reflex::Literal("isNear"), method_9565, 0, ";epsilon=CLHEP::Hep3Vector::tolerance", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506), Reflex::Literal("howNear"), method_9566, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506), Reflex::Literal("deltaR"), method_9567, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20610, type_20506), Reflex::Literal("operator+="), operator_9568, 0, "p", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20610, type_20506), Reflex::Literal("operator-="), operator_9569, 0, "p", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2016), Reflex::Literal("operator-"), operator_9570, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20610, type_252), Reflex::Literal("operator*="), operator_9571, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20610, type_252), Reflex::Literal("operator/="), operator_9572, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2016), Reflex::Literal("unit"), method_9573, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2016), Reflex::Literal("orthogonal"), method_9574, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506), Reflex::Literal("dot"), method_9575, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2016, type_20506), Reflex::Literal("cross"), method_9576, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506), Reflex::Literal("angle"), method_9577, 0, "q", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("pseudoRapidity"), method_9578, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_252), Reflex::Literal("setEta"), method_9579, 0, "p", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_252), Reflex::Literal("setCylEta"), method_9580, 0, "p", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20610, type_252), Reflex::Literal("rotateX"), method_9581, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20610, type_252), Reflex::Literal("rotateY"), method_9582, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20610, type_252), Reflex::Literal("rotateZ"), method_9583, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20610, type_20506), Reflex::Literal("rotateUz"), method_9584, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20610, type_252, type_20506), Reflex::Literal("rotate"), method_9585, 0, ";", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20610, type_20502), Reflex::Literal("operator*="), operator_9586, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20610, type_20502), Reflex::Literal("transform"), method_9587, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_252, type_252, type_252), Reflex::Literal("setRThetaPhi"), method_9588, 0, "r1;theta1;phi1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_252, type_252, type_252), Reflex::Literal("setREtaPhi"), method_9589, 0, "r1;eta1;phi1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_252, type_252, type_252), Reflex::Literal("setRhoPhiZ"), method_9590, 0, "rho1;phi1;z1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_252, type_252, type_252), Reflex::Literal("setRhoPhiTheta"), method_9591, 0, "rho;phi;theta", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_252, type_252, type_252), Reflex::Literal("setRhoPhiEta"), method_9592, 0, "rho;phi;eta", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("getX"), method_9593, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("getY"), method_9594, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("getZ"), method_9595, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("getR"), method_9596, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("getTheta"), method_9597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("getPhi"), method_9598, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("r"), method_9599, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("rho"), method_9600, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("getRho"), method_9601, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("eta"), method_9602, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("getEta"), method_9603, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_252), Reflex::Literal("setR"), method_9604, 0, "r1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_252), Reflex::Literal("setRho"), method_9605, 0, "rho1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_151, type_20506), Reflex::Literal("compare"), method_9606, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_704, type_20506), Reflex::Literal("operator>"), operator_9607, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_704, type_20506), Reflex::Literal("operator<"), operator_9608, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_704, type_20506), Reflex::Literal("operator>="), operator_9609, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_704, type_20506), Reflex::Literal("operator<="), operator_9610, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506), Reflex::Literal("diff2"), method_9611, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_252), Reflex::Literal("setTolerance"), method_9612, 0, "tol", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("getTolerance"), method_9613, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_704, type_20506, type_252), Reflex::Literal("isParallel"), method_9614, 0, "v;epsilon=CLHEP::Hep3Vector::tolerance", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_704, type_20506, type_252), Reflex::Literal("isOrthogonal"), method_9615, 0, "v;epsilon=CLHEP::Hep3Vector::tolerance", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506), Reflex::Literal("howParallel"), method_9616, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506), Reflex::Literal("howOrthogonal"), method_9617, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("beta"), method_9618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("gamma"), method_9619, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("coLinearRapidity"), method_9620, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("angle"), method_9621, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506), Reflex::Literal("theta"), method_9622, 0, "q", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506), Reflex::Literal("cosTheta"), method_9623, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506), Reflex::Literal("cos2Theta"), method_9624, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2016), Reflex::Literal("project"), method_9625, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2016, type_20506), Reflex::Literal("project"), method_9626, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2016), Reflex::Literal("perpPart"), method_9627, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2016, type_20506), Reflex::Literal("perpPart"), method_9628, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252), Reflex::Literal("rapidity"), method_9629, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506), Reflex::Literal("rapidity"), method_9630, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506), Reflex::Literal("eta"), method_9631, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506), Reflex::Literal("polarAngle"), method_9632, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506), Reflex::Literal("deltaPhi"), method_9633, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506), Reflex::Literal("azimAngle"), method_9634, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506, type_20506), Reflex::Literal("polarAngle"), method_9635, 0, "v2;ref", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_252, type_20506, type_20506), Reflex::Literal("azimAngle"), method_9636, 0, "v2;ref", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20610, type_20506, type_252), Reflex::Literal("rotate"), method_9637, 0, "axis;delta", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20610, type_20616), Reflex::Literal("rotate"), method_9638, 0, "ax", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20610, type_20808), Reflex::Literal("rotate"), method_9639, 0, "e", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20610, type_252, type_252, type_252), Reflex::Literal("rotate"), method_9640, 0, "phi;theta;psi", ::Reflex::PUBLIC);
}
//------Stub functions for class TOpNoviceSelectorRaw -------------------------------
static void constructor_11861( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TOpNoviceSelectorRaw();
  else ::new(mem) ::TOpNoviceSelectorRaw();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TOpNoviceSelectorRaw((::TTree*)arg[0]);
  else ::new(mem) ::TOpNoviceSelectorRaw((::TTree*)arg[0]);
  }
}

static void destructor_11862(void*, void * o, const std::vector<void*>&, void *) {
(((::TOpNoviceSelectorRaw*)o)->::TOpNoviceSelectorRaw::~TOpNoviceSelectorRaw)();
}
static  void method_11863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::TOpNoviceSelectorRaw*)o)->Version)());
  else   (((const ::TOpNoviceSelectorRaw*)o)->Version)();
}

static  void method_11864( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOpNoviceSelectorRaw*)o)->Begin)((::TTree*)arg[0]);
}

static  void method_11865( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOpNoviceSelectorRaw*)o)->SlaveBegin)((::TTree*)arg[0]);
}

static  void method_11866( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOpNoviceSelectorRaw*)o)->Init)((::TTree*)arg[0]);
}

static  void method_11867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((::TOpNoviceSelectorRaw*)o)->Notify)());
  else   (((::TOpNoviceSelectorRaw*)o)->Notify)();
}

static  void method_11868( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((::TOpNoviceSelectorRaw*)o)->Process)(*(::Long64_t*)arg[0]));
  else   (((::TOpNoviceSelectorRaw*)o)->Process)(*(::Long64_t*)arg[0]);
}

static  void method_11869( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Int_t)((((::TOpNoviceSelectorRaw*)o)->GetEntry)(*(::Long64_t*)arg[0]));
    else     (((::TOpNoviceSelectorRaw*)o)->GetEntry)(*(::Long64_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Int_t)((((::TOpNoviceSelectorRaw*)o)->GetEntry)(*(::Long64_t*)arg[0],
      *(::Int_t*)arg[1]));
    else     (((::TOpNoviceSelectorRaw*)o)->GetEntry)(*(::Long64_t*)arg[0],
      *(::Int_t*)arg[1]);
  }
}

static  void method_11870( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOpNoviceSelectorRaw*)o)->SetOption)((const char*)arg[0]);
}

static  void method_11871( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOpNoviceSelectorRaw*)o)->SetObject)((::TObject*)arg[0]);
}

static  void method_11872( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOpNoviceSelectorRaw*)o)->SetInputList)((::TList*)arg[0]);
}

static  void method_11873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TOpNoviceSelectorRaw*)o)->GetOutputList)());
  else   (((const ::TOpNoviceSelectorRaw*)o)->GetOutputList)();
}

static  void method_11874( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TOpNoviceSelectorRaw*)o)->SlaveTerminate)();
}

static  void method_11875( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TOpNoviceSelectorRaw*)o)->Terminate)();
}

static  void method_11876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TOpNoviceSelectorRaw*)o)->getDetector)());
  else   (((::TOpNoviceSelectorRaw*)o)->getDetector)();
}

static  void method_11877( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOpNoviceSelectorRaw*)o)->setDetector)((::TOpNoviceDetectorLight*)arg[0]);
}

static  void method_11878( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOpNoviceSelectorRaw*)o)->setSeed)(*(int*)arg[0]);
}

static void constructor_x1( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TOpNoviceSelectorRaw();
  else ::new(mem) ::TOpNoviceSelectorRaw();
}

static void method_newdel_2652( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TOpNoviceSelectorRaw >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TOpNoviceSelectorRaw >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TOpNoviceSelectorRaw >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TOpNoviceSelectorRaw >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TOpNoviceSelectorRaw >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TSelector")), ::Reflex::BaseOffset< ::TOpNoviceSelectorRaw,::TSelector >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TOpNoviceSelectorRaw,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TOpNoviceSelectorRaw -------------------------------
void __TOpNoviceSelectorRaw_db_datamem(Reflex::Class*);
void __TOpNoviceSelectorRaw_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TOpNoviceSelectorRaw_datamem_bld(&__TOpNoviceSelectorRaw_db_datamem);
Reflex::GenreflexMemberBuilder __TOpNoviceSelectorRaw_funcmem_bld(&__TOpNoviceSelectorRaw_db_funcmem);
void __TOpNoviceSelectorRaw_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TOpNoviceSelectorRaw"), typeid(::TOpNoviceSelectorRaw), sizeof(::TOpNoviceSelectorRaw), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_439, ::Reflex::BaseOffset< ::TOpNoviceSelectorRaw, ::TSelector >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6729), Reflex::Literal("TOpNoviceSelectorRaw"), constructor_11861, 0, "t=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TOpNoviceSelectorRaw"), destructor_11862, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TOpNoviceSelectorRaw"), constructor_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2652, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TOpNoviceSelectorRaw_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TOpNoviceSelectorRaw_funcmem_bld);
}

//------Delayed data member builder for class TOpNoviceSelectorRaw -------------------
void __TOpNoviceSelectorRaw_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6729, Reflex::Literal("fChain"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, fChain), ::Reflex::PUBLIC)
  .AddDataMember(type_24207, Reflex::Literal("raw"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, raw), ::Reflex::PUBLIC)
  .AddDataMember(type_6728, Reflex::Literal("b_raw"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, b_raw), ::Reflex::PUBLIC)
  .AddDataMember(type_20386, Reflex::Literal("m_detector"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, m_detector), ::Reflex::PRIVATE)
  .AddDataMember(type_24208, Reflex::Literal("m_recon"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, m_recon), ::Reflex::PRIVATE)
  .AddDataMember(type_24209, Reflex::Literal("m_rand"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, m_rand), ::Reflex::PRIVATE)
  .AddDataMember(type_151, Reflex::Literal("m_seed"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, m_seed), ::Reflex::PRIVATE)
  .AddDataMember(type_24210, Reflex::Literal("q"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, q), ::Reflex::PRIVATE)
  .AddDataMember(type_24210, Reflex::Literal("tFirst"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, tFirst), ::Reflex::PRIVATE)
  .AddDataMember(type_24211, Reflex::Literal("N"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, N), ::Reflex::PRIVATE)
  .AddDataMember(type_15437, Reflex::Literal("hX"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hX), ::Reflex::PRIVATE)
  .AddDataMember(type_15437, Reflex::Literal("hY"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hY), ::Reflex::PRIVATE)
  .AddDataMember(type_15437, Reflex::Literal("hZ"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hZ), ::Reflex::PRIVATE)
  .AddDataMember(type_15437, Reflex::Literal("hX_1"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hX_1), ::Reflex::PRIVATE)
  .AddDataMember(type_15437, Reflex::Literal("hY_1"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hY_1), ::Reflex::PRIVATE)
  .AddDataMember(type_15437, Reflex::Literal("hZ_1"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hZ_1), ::Reflex::PRIVATE)
  .AddDataMember(type_15437, Reflex::Literal("hX_2"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hX_2), ::Reflex::PRIVATE)
  .AddDataMember(type_15437, Reflex::Literal("hY_2"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hY_2), ::Reflex::PRIVATE)
  .AddDataMember(type_15437, Reflex::Literal("hZ_2"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hZ_2), ::Reflex::PRIVATE)
  .AddDataMember(type_15371, Reflex::Literal("hXY"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hXY), ::Reflex::PRIVATE)
  .AddDataMember(type_15371, Reflex::Literal("hXZ"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hXZ), ::Reflex::PRIVATE)
  .AddDataMember(type_15371, Reflex::Literal("hYZ"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hYZ), ::Reflex::PRIVATE)
  .AddDataMember(type_15371, Reflex::Literal("hXY_1"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hXY_1), ::Reflex::PRIVATE)
  .AddDataMember(type_15371, Reflex::Literal("hXZ_1"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hXZ_1), ::Reflex::PRIVATE)
  .AddDataMember(type_15371, Reflex::Literal("hYZ_1"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hYZ_1), ::Reflex::PRIVATE)
  .AddDataMember(type_15371, Reflex::Literal("hXY_2"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hXY_2), ::Reflex::PRIVATE)
  .AddDataMember(type_15371, Reflex::Literal("hXZ_2"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hXZ_2), ::Reflex::PRIVATE)
  .AddDataMember(type_15371, Reflex::Literal("hYZ_2"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hYZ_2), ::Reflex::PRIVATE)
  .AddDataMember(type_24212, Reflex::Literal("hPixel0"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hPixel0), ::Reflex::PRIVATE)
  .AddDataMember(type_15437, Reflex::Literal("hTheta"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hTheta), ::Reflex::PRIVATE)
  .AddDataMember(type_15437, Reflex::Literal("hPhi"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hPhi), ::Reflex::PRIVATE)
  .AddDataMember(type_15437, Reflex::Literal("hNPhotons"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hNPhotons), ::Reflex::PRIVATE)
  .AddDataMember(type_15437, Reflex::Literal("hT0"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hT0), ::Reflex::PRIVATE)
  .AddDataMember(type_15437, Reflex::Literal("hTau"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hTau), ::Reflex::PRIVATE)
  .AddDataMember(type_24213, Reflex::Literal("hCharge"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hCharge), ::Reflex::PRIVATE)
  .AddDataMember(type_24213, Reflex::Literal("hTime"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hTime), ::Reflex::PRIVATE)
  .AddDataMember(type_24214, Reflex::Literal("hTimeVsCharge"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hTimeVsCharge), ::Reflex::PRIVATE)
  .AddDataMember(type_24215, Reflex::Literal("hPixel0Title"), OffsetOf(__shadow__::__TOpNoviceSelectorRaw, hPixel0Title), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TOpNoviceSelectorRaw -------------------
void __TOpNoviceSelectorRaw_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_938), Reflex::Literal("Version"), method_11863, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_6729), Reflex::Literal("Begin"), method_11864, 0, "tree", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_6729), Reflex::Literal("SlaveBegin"), method_11865, 0, "tree", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_6729), Reflex::Literal("Init"), method_11866, 0, "tree", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_705), Reflex::Literal("Notify"), method_11867, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_705, type_2070), Reflex::Literal("Process"), method_11868, 0, "entry", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_938, type_2070, type_938), Reflex::Literal("GetEntry"), method_11869, 0, "entry;getall=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_3803), Reflex::Literal("SetOption"), method_11870, 0, "option", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_17462), Reflex::Literal("SetObject"), method_11871, 0, "obj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_20122), Reflex::Literal("SetInputList"), method_11872, 0, "input", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20122), Reflex::Literal("GetOutputList"), method_11873, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559), Reflex::Literal("SlaveTerminate"), method_11874, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559), Reflex::Literal("Terminate"), method_11875, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20386), Reflex::Literal("getDetector"), method_11876, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_20386), Reflex::Literal("setDetector"), method_11877, 0, "detector", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_151), Reflex::Literal("setSeed"), method_11878, 0, "seed", ::Reflex::PUBLIC);
}
//------Stub functions for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------------------
static void constructor_16859( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>();
  else ::new(mem) ::std::basic_string<char>();
}

static void constructor_16860( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::allocator<char>*)arg[0]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::allocator<char>*)arg[0]);
}

static void constructor_16861( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0]);
}

static void constructor_16862( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1],
      *(::size_t*)arg[2]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1],
      *(::size_t*)arg[2]);
  }
}

static void constructor_16863( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1],
      *(::size_t*)arg[2],
      *(const ::std::allocator<char>*)arg[3]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1],
      *(::size_t*)arg[2],
      *(const ::std::allocator<char>*)arg[3]);
}

static void constructor_16864( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::size_t*)arg[1]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::size_t*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::size_t*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  }
}

static void constructor_16865( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(const ::std::allocator<char>*)arg[1]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(const ::std::allocator<char>*)arg[1]);
  }
}

static void constructor_16866( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(::size_t*)arg[0],
      *(char*)arg[1]);
  else ::new(mem) ::std::basic_string<char>(*(::size_t*)arg[0],
      *(char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(::size_t*)arg[0],
      *(char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  else ::new(mem) ::std::basic_string<char>(*(::size_t*)arg[0],
      *(char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  }
}

static void destructor_16867(void*, void * o, const std::vector<void*>&, void *) {
(((::std::basic_string<char>*)o)->::std::basic_string<char>::~basic_string)();
}
static  void operator_16868( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void operator_16869( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)((const char*)arg[0]);
}

static  void operator_16870( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)(*(char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)(*(char*)arg[0]);
}

static  void method_16871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->begin)());
  else   (((::std::basic_string<char>*)o)->begin)();
}

static  void method_16872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >)((((const ::std::basic_string<char>*)o)->begin)());
  else   (((const ::std::basic_string<char>*)o)->begin)();
}

static  void method_16873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->end)());
  else   (((::std::basic_string<char>*)o)->end)();
}

static  void method_16874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >)((((const ::std::basic_string<char>*)o)->end)());
  else   (((const ::std::basic_string<char>*)o)->end)();
}

static  void method_16879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->size)());
  else   (((const ::std::basic_string<char>*)o)->size)();
}

static  void method_16880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->length)());
  else   (((const ::std::basic_string<char>*)o)->length)();
}

static  void method_16881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->max_size)());
  else   (((const ::std::basic_string<char>*)o)->max_size)();
}

static  void method_16882( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->resize)(*(::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_16883( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->resize)(*(::size_t*)arg[0]);
}

static  void method_16884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->capacity)());
  else   (((const ::std::basic_string<char>*)o)->capacity)();
}

static  void method_16885( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::std::basic_string<char>*)o)->reserve)();
  }
  else if ( arg.size() == 1 ) { 
    (((::std::basic_string<char>*)o)->reserve)(*(::size_t*)arg[0]);
  }
}

static  void method_16886( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::basic_string<char>*)o)->clear)();
}

static  void method_16887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::basic_string<char>*)o)->empty)());
  else   (((const ::std::basic_string<char>*)o)->empty)();
}

static  void operator_16888( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::basic_string<char>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((const ::std::basic_string<char>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void operator_16889( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_16890( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::basic_string<char>*)o)->at)(*(::size_t*)arg[0]);
  else   (((const ::std::basic_string<char>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_16891( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->at)(*(::size_t*)arg[0]);
  else   (((::std::basic_string<char>*)o)->at)(*(::size_t*)arg[0]);
}

static  void operator_16892( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void operator_16893( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)((const char*)arg[0]);
}

static  void operator_16894( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)(*(char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)(*(char*)arg[0]);
}

static  void method_16895( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_16896( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_16897( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)((const char*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::std::basic_string<char>*)o)->append)((const char*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_16898( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->append)((const char*)arg[0]);
}

static  void method_16899( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(::size_t*)arg[0],
    *(char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->append)(*(::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_16900( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->push_back)(*(char*)arg[0]);
}

static  void method_16901( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_16902( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_16903( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)((const char*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::std::basic_string<char>*)o)->assign)((const char*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_16904( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->assign)((const char*)arg[0]);
}

static  void method_16905( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(::size_t*)arg[0],
    *(char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->assign)(*(::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_16906( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::size_t*)arg[1],
    *(char*)arg[2]);
}

static  void method_16907( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_16908( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1],
    *(::size_t*)arg[2],
    *(::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1],
    *(::size_t*)arg[2],
    *(::size_t*)arg[3]);
}

static  void method_16909( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    (const char*)arg[1],
    *(::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    (const char*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_16910( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    (const char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_16911( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(char*)arg[2]);
}

static  void method_16912( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(char*)arg[1]));
  else   (((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(char*)arg[1]);
}

static  void method_16913( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)();
    else     (((::std::basic_string<char>*)o)->erase)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)(*(::size_t*)arg[0]);
    else     (((::std::basic_string<char>*)o)->erase)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)(*(::size_t*)arg[0],
      *(::size_t*)arg[1]);
    else     (((::std::basic_string<char>*)o)->erase)(*(::size_t*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16914( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0]));
  else   (((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0]);
}

static  void method_16915( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1]));
  else   (((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1]);
}

static  void method_16916( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_16917( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::size_t*)arg[3],
    *(::size_t*)arg[4]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::size_t*)arg[3],
    *(::size_t*)arg[4]);
}

static  void method_16918( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2],
    *(::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2],
    *(::size_t*)arg[3]);
}

static  void method_16919( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2]);
}

static  void method_16920( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2],
    *(char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2],
    *(char*)arg[3]);
}

static  void method_16921( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_16922( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    *(::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    *(::size_t*)arg[3]);
}

static  void method_16923( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2]);
}

static  void method_16924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::size_t*)arg[2],
    *(char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::size_t*)arg[2],
    *(char*)arg[3]);
}

static  void method_16925( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (char*)arg[2],
    (char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (char*)arg[2],
    (char*)arg[3]);
}

static  void method_16926( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    (const char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    (const char*)arg[3]);
}

static  void method_16927( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[3]);
}

static  void method_16928( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[3]);
}

static  void method_16932( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::size_t*)arg[1],
      *(::size_t*)arg[2]));
    else     (((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::size_t*)arg[1],
      *(::size_t*)arg[2]);
  }
}

static  void method_16933( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->swap)(*(::std::basic_string<char>*)arg[0]);
}

static  void method_16934( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::basic_string<char>*)o)->c_str)());
  else   (((const ::std::basic_string<char>*)o)->c_str)();
}

static  void method_16935( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::basic_string<char>*)o)->data)());
  else   (((const ::std::basic_string<char>*)o)->data)();
}

static  void method_16936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<char>)((((const ::std::basic_string<char>*)o)->get_allocator)());
  else   (((const ::std::basic_string<char>*)o)->get_allocator)();
}

static  void method_16937( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_16938( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16939( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16940( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16941( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16942( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_16943( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16944( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16945( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16946( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_16947( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16948( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16950( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_16951( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16952( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16953( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16954( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_16955( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16956( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16957( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16958( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_16959( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16960( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16961( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)());
    else     (((const ::std::basic_string<char>*)o)->substr)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)(*(::size_t*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->substr)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)(*(::size_t*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->substr)(*(::size_t*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_16962( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_16963( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_16964( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::size_t*)arg[3],
    *(::size_t*)arg[4]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::size_t*)arg[3],
    *(::size_t*)arg[4]);
}

static  void method_16965( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)((const char*)arg[0]));
  else   (((const ::std::basic_string<char>*)o)->compare)((const char*)arg[0]);
}

static  void method_16966( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2]);
}

static  void method_16967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2],
    *(::size_t*)arg[3]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2],
    *(::size_t*)arg[3]);
}

static void method_newdel_3251( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------------------
void __std__basic_string_char__db_datamem(Reflex::Class*);
void __std__basic_string_char__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__basic_string_char__datamem_bld(&__std__basic_string_char__db_datamem);
Reflex::GenreflexMemberBuilder __std__basic_string_char__funcmem_bld(&__std__basic_string_char__db_funcmem);
void __std__basic_string_char__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::basic_string<char>"), typeid(::std::basic_string<char>), sizeof(::std::basic_string<char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_3552, Reflex::Literal("std::basic_string<char>::_CharT_alloc_type"))
  .AddTypedef(type_3342, Reflex::Literal("std::basic_string<char>::traits_type"))
  .AddTypedef(type_1067, Reflex::Literal("std::basic_string<char>::value_type"))
  .AddTypedef(type_3552, Reflex::Literal("std::basic_string<char>::allocator_type"))
  .AddTypedef(type_1334, Reflex::Literal("std::basic_string<char>::size_type"))
  .AddTypedef(type_813, Reflex::Literal("std::basic_string<char>::difference_type"))
  .AddTypedef(type_15150, Reflex::Literal("std::basic_string<char>::reference"))
  .AddTypedef(type_16827, Reflex::Literal("std::basic_string<char>::const_reference"))
  .AddTypedef(type_2859, Reflex::Literal("std::basic_string<char>::pointer"))
  .AddTypedef(type_3803, Reflex::Literal("std::basic_string<char>::const_pointer"))
  .AddTypedef(type_9171, Reflex::Literal("std::basic_string<char>::iterator"))
  .AddTypedef(type_9206, Reflex::Literal("std::basic_string<char>::const_iterator"))
  .AddTypedef(type_3687, Reflex::Literal("std::basic_string<char>::const_reverse_iterator"))
  .AddTypedef(type_3688, Reflex::Literal("std::basic_string<char>::reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("basic_string"), constructor_16859, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24898), Reflex::Literal("basic_string"), constructor_16860, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15161), Reflex::Literal("basic_string"), constructor_16861, 0, "__str", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15161, type_1334, type_1334), Reflex::Literal("basic_string"), constructor_16862, 0, "__str;__pos;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15161, type_1334, type_1334, type_24898), Reflex::Literal("basic_string"), constructor_16863, 0, "__str;__pos;__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3803, type_1334, type_24898), Reflex::Literal("basic_string"), constructor_16864, 0, "__s;__n;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3803, type_24898), Reflex::Literal("basic_string"), constructor_16865, 0, "__s;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1334, type_1067, type_24898), Reflex::Literal("basic_string"), constructor_16866, 0, "__n;__c;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~basic_string"), destructor_16867, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3251, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__basic_string_char__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__basic_string_char__funcmem_bld);
}

//------Delayed data member builder for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------
void __std__basic_string_char__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_16837, Reflex::Literal("_M_dataplus"), OffsetOf(__shadow__::__std__basic_string_char_, _M_dataplus), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------
void __std__basic_string_char__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_15161), Reflex::Literal("operator="), operator_16868, 0, "__str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_3803), Reflex::Literal("operator="), operator_16869, 0, "__s", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_1067), Reflex::Literal("operator="), operator_16870, 0, "__c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9171), Reflex::Literal("begin"), method_16871, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9206), Reflex::Literal("begin"), method_16872, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9171), Reflex::Literal("end"), method_16873, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9206), Reflex::Literal("end"), method_16874, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334), Reflex::Literal("size"), method_16879, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334), Reflex::Literal("length"), method_16880, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334), Reflex::Literal("max_size"), method_16881, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_1334, type_1067), Reflex::Literal("resize"), method_16882, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_1334), Reflex::Literal("resize"), method_16883, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334), Reflex::Literal("capacity"), method_16884, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_1334), Reflex::Literal("reserve"), method_16885, 0, "__res=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559), Reflex::Literal("clear"), method_16886, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_704), Reflex::Literal("empty"), method_16887, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16827, type_1334), Reflex::Literal("operator[]"), operator_16888, 0, "__pos", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15150, type_1334), Reflex::Literal("operator[]"), operator_16889, 0, "__pos", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16827, type_1334), Reflex::Literal("at"), method_16890, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15150, type_1334), Reflex::Literal("at"), method_16891, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_15161), Reflex::Literal("operator+="), operator_16892, 0, "__str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_3803), Reflex::Literal("operator+="), operator_16893, 0, "__s", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_1067), Reflex::Literal("operator+="), operator_16894, 0, "__c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_15161), Reflex::Literal("append"), method_16895, 0, "__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_15161, type_1334, type_1334), Reflex::Literal("append"), method_16896, 0, "__str;__pos;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_3803, type_1334), Reflex::Literal("append"), method_16897, 0, "__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_3803), Reflex::Literal("append"), method_16898, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_1334, type_1067), Reflex::Literal("append"), method_16899, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_1067), Reflex::Literal("push_back"), method_16900, 0, "__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_15161), Reflex::Literal("assign"), method_16901, 0, "__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_15161, type_1334, type_1334), Reflex::Literal("assign"), method_16902, 0, "__str;__pos;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_3803, type_1334), Reflex::Literal("assign"), method_16903, 0, "__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_3803), Reflex::Literal("assign"), method_16904, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_1334, type_1067), Reflex::Literal("assign"), method_16905, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_9171, type_1334, type_1067), Reflex::Literal("insert"), method_16906, 0, "__p;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_1334, type_15161), Reflex::Literal("insert"), method_16907, 0, "__pos1;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_1334, type_15161, type_1334, type_1334), Reflex::Literal("insert"), method_16908, 0, "__pos1;__str;__pos2;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_1334, type_3803, type_1334), Reflex::Literal("insert"), method_16909, 0, "__pos;__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_1334, type_3803), Reflex::Literal("insert"), method_16910, 0, "__pos;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_1334, type_1334, type_1067), Reflex::Literal("insert"), method_16911, 0, "__pos;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9171, type_9171, type_1067), Reflex::Literal("insert"), method_16912, 0, "__p;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_1334, type_1334), Reflex::Literal("erase"), method_16913, 0, "__pos=0;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9171, type_9171), Reflex::Literal("erase"), method_16914, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9171, type_9171, type_9171), Reflex::Literal("erase"), method_16915, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_1334, type_1334, type_15161), Reflex::Literal("replace"), method_16916, 0, "__pos;__n;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_1334, type_1334, type_15161, type_1334, type_1334), Reflex::Literal("replace"), method_16917, 0, "__pos1;__n1;__str;__pos2;__n2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_1334, type_1334, type_3803, type_1334), Reflex::Literal("replace"), method_16918, 0, "__pos;__n1;__s;__n2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_1334, type_1334, type_3803), Reflex::Literal("replace"), method_16919, 0, "__pos;__n1;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_1334, type_1334, type_1334, type_1067), Reflex::Literal("replace"), method_16920, 0, "__pos;__n1;__n2;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_9171, type_9171, type_15161), Reflex::Literal("replace"), method_16921, 0, "__i1;__i2;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_9171, type_9171, type_3803, type_1334), Reflex::Literal("replace"), method_16922, 0, "__i1;__i2;__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_9171, type_9171, type_3803), Reflex::Literal("replace"), method_16923, 0, "__i1;__i2;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_9171, type_9171, type_1334, type_1067), Reflex::Literal("replace"), method_16924, 0, "__i1;__i2;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_9171, type_9171, type_2859, type_2859), Reflex::Literal("replace"), method_16925, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_9171, type_9171, type_3803, type_3803), Reflex::Literal("replace"), method_16926, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_9171, type_9171, type_9171, type_9171), Reflex::Literal("replace"), method_16927, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15172, type_9171, type_9171, type_9206, type_9206), Reflex::Literal("replace"), method_16928, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_2859, type_1334, type_1334), Reflex::Literal("copy"), method_16932, 0, "__s;__n;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1559, type_15172), Reflex::Literal("swap"), method_16933, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3803), Reflex::Literal("c_str"), method_16934, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3803), Reflex::Literal("data"), method_16935, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3552), Reflex::Literal("get_allocator"), method_16936, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_3803, type_1334, type_1334), Reflex::Literal("find"), method_16937, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_15161, type_1334), Reflex::Literal("find"), method_16938, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_3803, type_1334), Reflex::Literal("find"), method_16939, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_1067, type_1334), Reflex::Literal("find"), method_16940, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_15161, type_1334), Reflex::Literal("rfind"), method_16941, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_3803, type_1334, type_1334), Reflex::Literal("rfind"), method_16942, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_3803, type_1334), Reflex::Literal("rfind"), method_16943, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_1067, type_1334), Reflex::Literal("rfind"), method_16944, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_15161, type_1334), Reflex::Literal("find_first_of"), method_16945, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_3803, type_1334, type_1334), Reflex::Literal("find_first_of"), method_16946, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_3803, type_1334), Reflex::Literal("find_first_of"), method_16947, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_1067, type_1334), Reflex::Literal("find_first_of"), method_16948, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_15161, type_1334), Reflex::Literal("find_last_of"), method_16949, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_3803, type_1334, type_1334), Reflex::Literal("find_last_of"), method_16950, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_3803, type_1334), Reflex::Literal("find_last_of"), method_16951, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_1067, type_1334), Reflex::Literal("find_last_of"), method_16952, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_15161, type_1334), Reflex::Literal("find_first_not_of"), method_16953, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_3803, type_1334, type_1334), Reflex::Literal("find_first_not_of"), method_16954, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_3803, type_1334), Reflex::Literal("find_first_not_of"), method_16955, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_1067, type_1334), Reflex::Literal("find_first_not_of"), method_16956, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_15161, type_1334), Reflex::Literal("find_last_not_of"), method_16957, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_3803, type_1334, type_1334), Reflex::Literal("find_last_not_of"), method_16958, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_3803, type_1334), Reflex::Literal("find_last_not_of"), method_16959, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1334, type_1067, type_1334), Reflex::Literal("find_last_not_of"), method_16960, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3251, type_1334, type_1334), Reflex::Literal("substr"), method_16961, 0, "__pos=0;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_151, type_15161), Reflex::Literal("compare"), method_16962, 0, "__str", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_151, type_1334, type_1334, type_15161), Reflex::Literal("compare"), method_16963, 0, "__pos;__n;__str", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_151, type_1334, type_1334, type_15161, type_1334, type_1334), Reflex::Literal("compare"), method_16964, 0, "__pos1;__n1;__str;__pos2;__n2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_151, type_3803), Reflex::Literal("compare"), method_16965, 0, "__s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_151, type_1334, type_1334, type_3803), Reflex::Literal("compare"), method_16966, 0, "__pos;__n1;__s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_151, type_1334, type_1334, type_3803, type_1334), Reflex::Literal("compare"), method_16967, 0, "__pos;__n1;__s;__n2", ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __CLHEP__Hep3Vector_dict(); 
      __TOpNoviceSelectorRaw_dict(); 
      __std__basic_string_char__dict(); 
    }
    ~Dictionaries() {
      type_2016.Unload(); // class CLHEP::Hep3Vector 
      type_2652.Unload(); // class TOpNoviceSelectorRaw 
      type_3251.Unload(); // class std::basic_string<char> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
