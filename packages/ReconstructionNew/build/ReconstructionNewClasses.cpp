// Generated at Fri Sep 25 17:54:52 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/usr/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/usr/bin/c++"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic "
  GCCXML_EXECUTABLE="/usr/bin/gccxml_cc1plus"
  GCCXML_CPP="/usr/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__FLT_MIN__='1.17549435e-38F' -D__CHAR_BIT__='8' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='4.9406564584124654e-324' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__LP64__='1' -D__GNUC_PATCHLEVEL__='7' -D__DEC64_MAX_EXP__='385' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__unix='1' -D__LDBL_MAX_EXP__='16384' -D__linux__='1' -D__SCHAR_MAX__='127' -D__DBL_DIG__='15' -D_FORTIFY_SOURCE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209290e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__SIZEOF_LONG__='8' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='1.7976931348623157e+308' -D__DBL_HAS_INFINITY__='1' -D__DEC32_MIN_EXP__='(-94)' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__DBL_MIN__='2.2250738585072014e-308' -D__FLT_MIN_10_EXP__='(-37)' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__DBL_HAS_DENORM__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.4.7 20120313 (Red Hat 4.4.7-16)"' -D__DEC64_EPSILON__='1E-15DD' -D__DEC128_MIN_EXP__='(-6142)' -Dunix='1' -D__SIZE_TYPE__='long unsigned int' -D__ELF__='1' -D__FLT_RADIX__='2' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__GNUC_RH_RELEASE__='16' -D__k8='1' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__DEC64_MANT_DIG__='16' -D__DEC32_MAX_EXP__='97' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__k8__='1' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__DEC64_MIN_EXP__='(-382)' -D__FLT_DIG__='6' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__FLT_MAX_EXP__='128' -D__DBL_MANT_DIG__='53' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__SSP__='1' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='2.2204460492503131e-16' -D_LP64='1' -D__SIZEOF_WCHAR_T__='4' -D__DEC_EVAL_METHOD__='2' -D__INTMAX_MAX__='9223372036854775807L' -D__FLT_DENORM_MIN__='1.40129846e-45F' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282347e+38F' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='4' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__GNUC_GNU_INLINE__='1' -D_GNU_SOURCE='1' -iwrapper"/usr/share/gccxml-0.9/GCC/4.4" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/backward" -isystem"/usr/local/include" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/usr/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.4.7 20120313 (Red Hat 4.4.7-16)
Copyright (C) 2010 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/project/Gruppo3/fiber5/celentano/OptoTracker/packages/ReconstructionNew/include/ReconstructionNewClasses.hh"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::Type type_143 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_248 = ::Reflex::TypeBuilder(Reflex::Literal("TH1D"));
  ::Reflex::Type type_256 = ::Reflex::TypeBuilder(Reflex::Literal("TH2D"));
  ::Reflex::Type type_986 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_649 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_268 = ::Reflex::TypeBuilder(Reflex::Literal("TH3D"));
  ::Reflex::Type type_195 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1188 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_197 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_808 = ::Reflex::TypeBuilder(Reflex::Literal("TFile"));
  ::Reflex::Type type_239 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_2753 = ::Reflex::TypeBuilder(Reflex::Literal("TTree"));
  ::Reflex::Type type_1030 = ::Reflex::TypeBuilder(Reflex::Literal("TList"));
  ::Reflex::Type type_615 = ::Reflex::TypeBuilder(Reflex::Literal("TProof"));
  ::Reflex::Type type_2620 = ::Reflex::TypeBuilder(Reflex::Literal("TEvent"));
  ::Reflex::Type type_1962 = ::Reflex::TypeBuilder(Reflex::Literal("TClass"));
  ::Reflex::Type type_835 = ::Reflex::TypeBuilder(Reflex::Literal("TBuffer"));
  ::Reflex::Type type_2616 = ::Reflex::TypeBuilder(Reflex::Literal("TNamed"));
  ::Reflex::Type type_829 = ::Reflex::TypeBuilder(Reflex::Literal("TBranch"));
  ::Reflex::Type type_2666 = ::Reflex::TypeBuilder(Reflex::Literal("TChain"));
  ::Reflex::Type type_2537 = ::Reflex::TypeBuilder(Reflex::Literal("TDriver"));
  ::Reflex::Type type_2231 = ::Reflex::TypeBuilder(Reflex::Literal("TObject"));
  ::Reflex::Type type_405 = ::Reflex::TypeBuilder(Reflex::Literal("TSelector"));
  ::Reflex::Type type_63 = ::Reflex::TypeBuilder(Reflex::Literal("TXMLHandler"));
  ::Reflex::Type type_1934 = ::Reflex::TypeBuilder(Reflex::Literal("long long"));
  ::Reflex::Type type_2654 = ::Reflex::TypeBuilder(Reflex::Literal("TAnalysis"));
  ::Reflex::Type type_516 = ::Reflex::TypeBuilder(Reflex::Literal("TReconInput"));
  ::Reflex::Type type_210 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_1337 = ::Reflex::TypeBuilder(Reflex::Literal("TJobManager"));
  ::Reflex::Type type_172 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_394 = ::Reflex::EnumTypeBuilder(Reflex::Literal("fitObject_t"));
  ::Reflex::Type type_1686 = ::Reflex::TypeBuilder(Reflex::Literal("TDetectorLight"));
  ::Reflex::Type type_1436 = ::Reflex::TypeBuilder(Reflex::Literal("TDetectorUtils"));
  ::Reflex::Type type_430 = ::Reflex::TypeBuilder(Reflex::Literal("TMemberInspector"));
  ::Reflex::Type type_1120 = ::Reflex::TypeBuilder(Reflex::Literal("TRootSaveDriver"));
  ::Reflex::Type type_148 = ::Reflex::TypeBuilder(Reflex::Literal("TMatrixT<double>"));
  ::Reflex::Type type_576 = ::Reflex::TypeBuilder(Reflex::Literal("TEventMarkerDriver"));
  ::Reflex::Type type_2102 = ::Reflex::TypeBuilder(Reflex::Literal("TMatrixReconDriver"));
  ::Reflex::Type type_2835 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_1203 = ::Reflex::TypeBuilder(Reflex::Literal("TMatrixWriterDriver"));
  ::Reflex::Type type_100 = ::Reflex::TypeBuilder(Reflex::Literal("TChargeAnalysisDriver"));
  ::Reflex::Type type_7626 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::Minimizer"));
  ::Reflex::Type type_220 = ::Reflex::TypeBuilder(Reflex::Literal("TLikelihoodReconDriver"));
  ::Reflex::Type type_2830 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<TDriver*>"));
  ::Reflex::Type type_997 = ::Reflex::EnumTypeBuilder(Reflex::Literal("fitLikelihoodMode_t"));
  ::Reflex::Type type_2861 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_1428 = ::Reflex::TypeBuilder(Reflex::Literal("TMatrixInterpreterDriver"));
  ::Reflex::Type type_3144 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<TDriver*>"));
  ::Reflex::Type type_4096 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::IBaseFunctionMultiDim"));
  ::Reflex::Type type_2838 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_1368 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_ofstream<char,std::char_traits<char> >"));
  ::Reflex::Type type_2789 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TDriver*,std::allocator<TDriver*> >"));
  ::Reflex::Type type_2997 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >"));
  ::Reflex::Type type_7939 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >"));
  ::Reflex::Type type_7940 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TDriver* const*,std::vector<TDriver*> >"));
  ::Reflex::Type type_3210 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> > >"));
  ::Reflex::Type type_3209 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TDriver* const*,std::vector<TDriver*> > >"));
  ::Reflex::Type type_14731 = ::Reflex::PointerBuilder(type_248);
  ::Reflex::Type type_2873 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2861);
  ::Reflex::Type type_1369 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ofstream"), type_1368);
  ::Reflex::Type type_18640 = ::Reflex::PointerBuilder(type_256);
  ::Reflex::Type type_17844 = ::Reflex::ArrayBuilder(type_18640, 256);
  ::Reflex::Type type_14732 = ::Reflex::ArrayBuilder(type_17844, 6);
  ::Reflex::Type type_14733 = ::Reflex::PointerBuilder(type_2620);
  ::Reflex::Type type_986c = ::Reflex::ConstBuilder(type_986);
  ::Reflex::Type type_3354 = ::Reflex::PointerBuilder(type_986c);
  ::Reflex::Type type_769 = ::Reflex::PointerBuilder(type_1962);
  ::Reflex::Type type_2467 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Version_t"), type_197);
  ::Reflex::Type type_14710 = ::Reflex::ReferenceBuilder(type_430);
  ::Reflex::Type type_4589 = ::Reflex::ReferenceBuilder(type_835);
  ::Reflex::Type type_14830 = ::Reflex::PointerBuilder(type_7626);
  ::Reflex::Type type_14831 = ::Reflex::PointerBuilder(type_516);
  ::Reflex::Type type_3355 = ::Reflex::PointerBuilder(type_143);
  ::Reflex::Type type_17866 = ::Reflex::PointerBuilder(type_3355);
  ::Reflex::Type type_14832 = ::Reflex::ArrayBuilder(type_17866, 6);
  ::Reflex::Type type_8040 = ::Reflex::PointerBuilder(type_239);
  ::Reflex::Type type_17867 = ::Reflex::PointerBuilder(type_8040);
  ::Reflex::Type type_14833 = ::Reflex::ArrayBuilder(type_17867, 6);
  ::Reflex::Type type_14834 = ::Reflex::ReferenceBuilder(type_220);
  ::Reflex::Type type_220c = ::Reflex::ConstBuilder(type_220);
  ::Reflex::Type type_14835 = ::Reflex::ReferenceBuilder(type_220c);
  ::Reflex::Type type_239c = ::Reflex::ConstBuilder(type_239);
  ::Reflex::Type type_11463 = ::Reflex::PointerBuilder(type_239c);
  ::Reflex::Type type_14839 = ::Reflex::PointerBuilder(type_4096);
  ::Reflex::Type type_14941 = ::Reflex::ArrayBuilder(type_143, 30);
  ::Reflex::Type type_14942 = ::Reflex::ArrayBuilder(type_239, 30);
  ::Reflex::Type type_14943 = ::Reflex::ReferenceBuilder(type_516);
  ::Reflex::Type type_516c = ::Reflex::ConstBuilder(type_516);
  ::Reflex::Type type_14944 = ::Reflex::ReferenceBuilder(type_516c);
  ::Reflex::Type type_14955 = ::Reflex::ReferenceBuilder(type_576);
  ::Reflex::Type type_576c = ::Reflex::ConstBuilder(type_576);
  ::Reflex::Type type_14956 = ::Reflex::ReferenceBuilder(type_576c);
  ::Reflex::Type type_15012 = ::Reflex::PointerBuilder(type_808);
  ::Reflex::Type type_15657 = ::Reflex::ReferenceBuilder(type_1120);
  ::Reflex::Type type_1120c = ::Reflex::ConstBuilder(type_1120);
  ::Reflex::Type type_15658 = ::Reflex::ReferenceBuilder(type_1120c);
  ::Reflex::Type type_15705 = ::Reflex::ReferenceBuilder(type_1203);
  ::Reflex::Type type_1203c = ::Reflex::ConstBuilder(type_1203);
  ::Reflex::Type type_15706 = ::Reflex::ReferenceBuilder(type_1203c);
  ::Reflex::Type type_5465 = ::Reflex::PointerBuilder(type_2753);
  ::Reflex::Type type_5464 = ::Reflex::PointerBuilder(type_829);
  ::Reflex::Type type_15783 = ::Reflex::PointerBuilder(type_63);
  ::Reflex::Type type_15784 = ::Reflex::PointerBuilder(type_2830);
  ::Reflex::Type type_15785 = ::Reflex::PointerBuilder(type_1686);
  ::Reflex::Type type_15786 = ::Reflex::PointerBuilder(type_1436);
  ::Reflex::Type type_15787 = ::Reflex::PointerBuilder(type_2997);
  ::Reflex::Type type_863 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Int_t"), type_143);
  ::Reflex::Type type_1935 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Long64_t"), type_1934);
  ::Reflex::Type type_13018 = ::Reflex::PointerBuilder(type_2231);
  ::Reflex::Type type_14897 = ::Reflex::PointerBuilder(type_1030);
  ::Reflex::Type type_650 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Bool_t"), type_649);
  ::Reflex::Type type_8546 = ::Reflex::PointerBuilder(type_2537);
  ::Reflex::Type type_15807 = ::Reflex::PointerBuilder(type_268);
  ::Reflex::Type type_15808 = ::Reflex::ReferenceBuilder(type_1428);
  ::Reflex::Type type_1428c = ::Reflex::ConstBuilder(type_1428);
  ::Reflex::Type type_15809 = ::Reflex::ReferenceBuilder(type_1428c);
  ::Reflex::Type type_149 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("TMatrixD"), type_148);
  ::Reflex::Type type_16810 = ::Reflex::PointerBuilder(type_149);
  ::Reflex::Type type_16811 = ::Reflex::ReferenceBuilder(type_2102);
  ::Reflex::Type type_2102c = ::Reflex::ConstBuilder(type_2102);
  ::Reflex::Type type_16812 = ::Reflex::ReferenceBuilder(type_2102c);
  ::Reflex::Type type_17090 = ::Reflex::PointerBuilder(type_1337);
  ::Reflex::Type type_17091 = ::Reflex::ReferenceBuilder(type_2537);
  ::Reflex::Type type_2537c = ::Reflex::ConstBuilder(type_2537);
  ::Reflex::Type type_17092 = ::Reflex::ReferenceBuilder(type_2537c);
  ::Reflex::Type type_2873c = ::Reflex::ConstBuilder(type_2873);
  ::Reflex::Type type_13971 = ::Reflex::ReferenceBuilder(type_2873c);
  ::Reflex::Type type_17130 = ::Reflex::PointerBuilder(type_2666);
  ::Reflex::Type type_17131 = ::Reflex::PointerBuilder(type_615);
  ::Reflex::Type type_17132 = ::Reflex::PointerBuilder(type_2838);
  ::Reflex::Type type_17133 = ::Reflex::ReferenceBuilder(type_2654);
  ::Reflex::Type type_2654c = ::Reflex::ConstBuilder(type_2654);
  ::Reflex::Type type_17134 = ::Reflex::ReferenceBuilder(type_2654c);
  ::Reflex::Type type_2565 = ::Reflex::PointerBuilder(type_986);
  ::Reflex::Type type_4310 = ::Reflex::PointerBuilder(type_2565);
  ::Reflex::Type type_11212 = ::Reflex::PointerBuilder(type_8546);
  ::Reflex::Type type_8546c = ::Reflex::ConstBuilder(type_8546);
  ::Reflex::Type type_11214 = ::Reflex::PointerBuilder(type_8546c);
  ::Reflex::Type type_11216 = ::Reflex::ReferenceBuilder(type_8546);
  ::Reflex::Type type_11218 = ::Reflex::ReferenceBuilder(type_8546c);
  ::Reflex::Type type_1944 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_172);
  ::Reflex::Type type_740 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("ptrdiff_t"), type_195);
  ::Reflex::Type type_3144c = ::Reflex::ConstBuilder(type_3144);
  ::Reflex::Type type_17209 = ::Reflex::ReferenceBuilder(type_3144c);
  ::Reflex::Type type_2830c = ::Reflex::ConstBuilder(type_2830);
  ::Reflex::Type type_17336 = ::Reflex::ReferenceBuilder(type_2830c);
  ::Reflex::Type type_17337 = ::Reflex::ReferenceBuilder(type_2830);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __TChargeAnalysisDriver
#undef __TChargeAnalysisDriver
#endif
class __TChargeAnalysisDriver : public ::TDriver {
  public:
  __TChargeAnalysisDriver();
  virtual ~__TChargeAnalysisDriver() throw();
  virtual int startOfData() throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual int start() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int end() throw();
  virtual int process(TEvent*) throw();
  void* hPixels;
  int m_nPixels;
  int m_nDetectors;
  int m_writeOut;
  ::std::string m_writeOutFileName;
  ::std::ofstream m_writeOutFile;
  ::std::vector<double> m_Q;
  void* hPixels2D[6][256];
};
#ifdef __TLikelihoodReconDriver
#undef __TLikelihoodReconDriver
#endif
class __TLikelihoodReconDriver : public ::TDriver, public ::ROOT::Math::IBaseFunctionMultiDim {
  public:
  __TLikelihoodReconDriver();
  virtual ~__TLikelihoodReconDriver() throw();
  virtual ::ROOT::Math::IBaseFunctionMultiDim* Clone() const throw();
  virtual unsigned int NDim() const throw();
  virtual int process(TEvent*) throw();
  virtual void Streamer(TBuffer&) throw();
  virtual int start() throw();
  virtual double DoEval(double const*) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int endOfData() throw();
  virtual int startOfData() throw();
  virtual ::TClass* IsA() const throw();
  void* m_minimizer;
  void* m_reconInput;
  ::fitObject_t m_fitObject;
  ::fitLikelihoodMode_t m_fitLikelihoodMode;
  void* m_N[6];
  void* m_Q[6];
  void* m_t[6];
  int m_reconInputMode;
  ::std::string m_reconInputFileName;
};
#ifdef __TReconInput
#undef __TReconInput
#endif
class __TReconInput : public ::TNamed {
  public:
  __TReconInput();
  virtual ~__TReconInput() throw();
  virtual void Print() const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  int m_isParConfigured[30];
  double m_parVal[30];
  int m_isParFixed[30];
  int m_isParLowLimited[30];
  int m_isParHighLimited[30];
  double m_parLowLimit[30];
  double m_parHighLimit[30];
  ::fitObject_t m_fitObject;
  ::fitLikelihoodMode_t m_fitLikelihoodMode;
};
#ifdef __TEventMarkerDriver
#undef __TEventMarkerDriver
#endif
class __TEventMarkerDriver : public ::TDriver {
  public:
  __TEventMarkerDriver();
  virtual ~__TEventMarkerDriver() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int process(TEvent*) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  int m_interval;
};
#ifdef __TRootSaveDriver
#undef __TRootSaveDriver
#endif
class __TRootSaveDriver : public ::TDriver {
  public:
  __TRootSaveDriver();
  virtual ~__TRootSaveDriver() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual int end() throw();
  virtual void Streamer(TBuffer&) throw();
  ::std::string m_fname;
  void* m_fout;
};
#ifdef __TMatrixWriterDriver
#undef __TMatrixWriterDriver
#endif
class __TMatrixWriterDriver : public ::TDriver {
  public:
  __TMatrixWriterDriver();
  virtual ~__TMatrixWriterDriver() throw();
  virtual int startOfData() throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual int start() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int end() throw();
  virtual int process(TEvent*) throw();
  void* hPixels;
  int m_nPixels;
  int m_nDetectors;
  int m_voxelID;
};
#ifdef __TJobManager
#undef __TJobManager
#endif
class __TJobManager : public ::TSelector {
  public:
  __TJobManager();
  virtual ~__TJobManager() throw();
  virtual ::Int_t GetEntry(long long, int) throw();
  virtual void SetInputList(TList*) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void Init(TTree*) throw();
  virtual ::Bool_t Process(long long) throw();
  virtual const char* ClassName() const throw();
  virtual void SetOption(char const*) throw();
  virtual ::Bool_t Notify() throw();
  virtual void SlaveTerminate() throw();
  virtual void SetObject(TObject*) throw();
  virtual void Begin(TTree*) throw();
  virtual void Terminate() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TList* GetOutputList() const throw();
  virtual ::Int_t Version() const throw();
  virtual void SlaveBegin(TTree*) throw();
  void* fTree;
  void* b_event;
  void* m_event;
  void* m_xmlHandler;
  void* m_drivers;
  void* m_detector;
  void* m_detectorUtils;
  void* m_variables;
  int m_eventN;
  int m_doProof;
  int m_doProofDiag;
  int m_skipEvents;
  int m_numberOfEvents;
  int m_verboseLevel;
  int m_dryRun;
  int m_numberOfWorkers;
  int m_numberOfIterations;
  int m_iterationN;
  int m_isProofCompatible;
};
#ifdef __TMatrixInterpreterDriver
#undef __TMatrixInterpreterDriver
#endif
class __TMatrixInterpreterDriver : public ::TDriver {
  public:
  __TMatrixInterpreterDriver();
  virtual ~__TMatrixInterpreterDriver() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int process(TEvent*) throw();
  virtual int startOfData() throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  void* hVoxelRecon;
};
#ifdef __TMatrixReconDriver
#undef __TMatrixReconDriver
#endif
class __TMatrixReconDriver : public ::TDriver {
  public:
  __TMatrixReconDriver();
  virtual ~__TMatrixReconDriver() throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int endOfData() throw();
  virtual int startOfData() throw();
  virtual int process(TEvent*) throw();
  void* m_matrix;
  ::TMatrixD m_matrixInverse;
  int m_matrixSource;
  void* m_matrixFile;
  ::std::string m_matrixFileName;
  void* hVoxelsInput;
  void* hVoxelsReconAll;
  ::TMatrixD m_pixelDataAll;
  ::TMatrixD m_voxelDataAll;
};
#ifdef __TDriver
#undef __TDriver
#endif
class __TDriver : public ::TObject {
  public:
  __TDriver();
  virtual ~__TDriver() throw();
  void* m_manager;
  ::std::string m_name;
  int m_verboseLevel;
  int m_iterationN;
  int m_isProofCompatible;
  ::std::string m_collectionName;
  ::std::string m_collectionRawName;
};
#ifdef __TAnalysis
#undef __TAnalysis
#endif
class __TAnalysis : public ::TObject {
  public:
  __TAnalysis();
  virtual ~__TAnalysis() throw();
  void* m_manager;
  void* m_chain;
  void* m_proof;
  ::std::string m_steeringName;
  ::std::string m_detName;
  void* m_fileName;
  int isConfigured;
};
#ifdef __std__vector_TDriverp_
#undef __std__vector_TDriverp_
#endif
class __std__vector_TDriverp_ : protected ::std::_Vector_base<TDriver*,std::allocator<TDriver*> > {
  public:
  __std__vector_TDriverp_();
};
}


#endif // __CINT__
namespace {
} // unnamed namespace

#ifndef G__DICTIONARY
# define G__DICTIONARY
#endif
#include "TClass.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "RtypesImp.h"
#include "TIsAProxy.h"
atomic_TClass_ptr TChargeAnalysisDriver::fgIsA(0);
TClass* ::TChargeAnalysisDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TChargeAnalysisDriver");
   }
   return fgIsA;
}
const char * ::TChargeAnalysisDriver::Class_Name() {return "TChargeAnalysisDriver";}
void ::TChargeAnalysisDriver::Dictionary() {}
const char *::TChargeAnalysisDriver::ImplFileName() {return "";}
int ::TChargeAnalysisDriver::ImplFileLine() {return 1;}
void ::TChargeAnalysisDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TChargeAnalysisDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hPixels", &hPixels);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nPixels", &m_nPixels);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nDetectors", &m_nDetectors);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_writeOut", &m_writeOut);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_writeOutFileName", &m_writeOutFileName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_writeOutFile", &m_writeOutFile);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Q", &m_Q);
   R__insp.InspectMember("std::vector<double>", (void*)&m_Q, "m_Q.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "hPixels2D[6][256]", &hPixels2D);
   TDriver::ShowMembers(R__insp);
}
void ::TChargeAnalysisDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TChargeAnalysisDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TChargeAnalysisDriver::Class(),this);
   }
}

atomic_TClass_ptr TLikelihoodReconDriver::fgIsA(0);
TClass* ::TLikelihoodReconDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TLikelihoodReconDriver");
   }
   return fgIsA;
}
const char * ::TLikelihoodReconDriver::Class_Name() {return "TLikelihoodReconDriver";}
void ::TLikelihoodReconDriver::Dictionary() {}
const char *::TLikelihoodReconDriver::ImplFileName() {return "";}
int ::TLikelihoodReconDriver::ImplFileLine() {return 1;}
void ::TLikelihoodReconDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TLikelihoodReconDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_minimizer", &m_minimizer);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_reconInput", &m_reconInput);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_fitObject", &m_fitObject);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_fitLikelihoodMode", &m_fitLikelihoodMode);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_N[6]", &m_N);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Q[6]", &m_Q);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_t[6]", &m_t);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_reconInputMode", &m_reconInputMode);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_reconInputFileName", &m_reconInputFileName);
   TDriver::ShowMembers(R__insp);
   R__insp.GenericShowMembers("ROOT::Math::IBaseFunctionMultiDim", ( ::ROOT::Math::IBaseFunctionMultiDim *)(this), false);
}
void ::TLikelihoodReconDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TLikelihoodReconDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TLikelihoodReconDriver::Class(),this);
   }
}

atomic_TClass_ptr TReconInput::fgIsA(0);
TClass* ::TReconInput::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TReconInput");
   }
   return fgIsA;
}
const char * ::TReconInput::Class_Name() {return "TReconInput";}
void ::TReconInput::Dictionary() {}
const char *::TReconInput::ImplFileName() {return "";}
int ::TReconInput::ImplFileLine() {return 1;}
void ::TReconInput::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TReconInput::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_isParConfigured[30]", &m_isParConfigured);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_parVal[30]", &m_parVal);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_isParFixed[30]", &m_isParFixed);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_isParLowLimited[30]", &m_isParLowLimited);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_isParHighLimited[30]", &m_isParHighLimited);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_parLowLimit[30]", &m_parLowLimit);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_parHighLimit[30]", &m_parHighLimit);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_fitObject", &m_fitObject);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_fitLikelihoodMode", &m_fitLikelihoodMode);
   TNamed::ShowMembers(R__insp);
}
void ::TReconInput::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TReconInput::Class(),this);
   } else {
      b.WriteClassBuffer(::TReconInput::Class(),this);
   }
}

atomic_TClass_ptr TEventMarkerDriver::fgIsA(0);
TClass* ::TEventMarkerDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TEventMarkerDriver");
   }
   return fgIsA;
}
const char * ::TEventMarkerDriver::Class_Name() {return "TEventMarkerDriver";}
void ::TEventMarkerDriver::Dictionary() {}
const char *::TEventMarkerDriver::ImplFileName() {return "";}
int ::TEventMarkerDriver::ImplFileLine() {return 1;}
void ::TEventMarkerDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TEventMarkerDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_interval", &m_interval);
   TDriver::ShowMembers(R__insp);
}
void ::TEventMarkerDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TEventMarkerDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TEventMarkerDriver::Class(),this);
   }
}

atomic_TClass_ptr TRootSaveDriver::fgIsA(0);
TClass* ::TRootSaveDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TRootSaveDriver");
   }
   return fgIsA;
}
const char * ::TRootSaveDriver::Class_Name() {return "TRootSaveDriver";}
void ::TRootSaveDriver::Dictionary() {}
const char *::TRootSaveDriver::ImplFileName() {return "";}
int ::TRootSaveDriver::ImplFileLine() {return 1;}
void ::TRootSaveDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TRootSaveDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_fname", &m_fname);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_fout", &m_fout);
   TDriver::ShowMembers(R__insp);
}
void ::TRootSaveDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TRootSaveDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TRootSaveDriver::Class(),this);
   }
}

atomic_TClass_ptr TMatrixWriterDriver::fgIsA(0);
TClass* ::TMatrixWriterDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TMatrixWriterDriver");
   }
   return fgIsA;
}
const char * ::TMatrixWriterDriver::Class_Name() {return "TMatrixWriterDriver";}
void ::TMatrixWriterDriver::Dictionary() {}
const char *::TMatrixWriterDriver::ImplFileName() {return "";}
int ::TMatrixWriterDriver::ImplFileLine() {return 1;}
void ::TMatrixWriterDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TMatrixWriterDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hPixels", &hPixels);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nPixels", &m_nPixels);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nDetectors", &m_nDetectors);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_voxelID", &m_voxelID);
   TDriver::ShowMembers(R__insp);
}
void ::TMatrixWriterDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TMatrixWriterDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TMatrixWriterDriver::Class(),this);
   }
}

atomic_TClass_ptr TJobManager::fgIsA(0);
TClass* ::TJobManager::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TJobManager");
   }
   return fgIsA;
}
const char * ::TJobManager::Class_Name() {return "TJobManager";}
void ::TJobManager::Dictionary() {}
const char *::TJobManager::ImplFileName() {return "";}
int ::TJobManager::ImplFileLine() {return 1;}
void ::TJobManager::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TJobManager::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*fTree", &fTree);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*b_event", &b_event);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_event", &m_event);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_xmlHandler", &m_xmlHandler);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_drivers", &m_drivers);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_detector", &m_detector);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_detectorUtils", &m_detectorUtils);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_variables", &m_variables);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_eventN", &m_eventN);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_doProof", &m_doProof);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_doProofDiag", &m_doProofDiag);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_skipEvents", &m_skipEvents);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_numberOfEvents", &m_numberOfEvents);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_verboseLevel", &m_verboseLevel);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_dryRun", &m_dryRun);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_numberOfWorkers", &m_numberOfWorkers);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_numberOfIterations", &m_numberOfIterations);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_iterationN", &m_iterationN);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_isProofCompatible", &m_isProofCompatible);
   TSelector::ShowMembers(R__insp);
}
void ::TJobManager::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TJobManager::Class(),this);
   } else {
      b.WriteClassBuffer(::TJobManager::Class(),this);
   }
}

atomic_TClass_ptr TMatrixInterpreterDriver::fgIsA(0);
TClass* ::TMatrixInterpreterDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TMatrixInterpreterDriver");
   }
   return fgIsA;
}
const char * ::TMatrixInterpreterDriver::Class_Name() {return "TMatrixInterpreterDriver";}
void ::TMatrixInterpreterDriver::Dictionary() {}
const char *::TMatrixInterpreterDriver::ImplFileName() {return "";}
int ::TMatrixInterpreterDriver::ImplFileLine() {return 1;}
void ::TMatrixInterpreterDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TMatrixInterpreterDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hVoxelRecon", &hVoxelRecon);
   TDriver::ShowMembers(R__insp);
}
void ::TMatrixInterpreterDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TMatrixInterpreterDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TMatrixInterpreterDriver::Class(),this);
   }
}

atomic_TClass_ptr TMatrixReconDriver::fgIsA(0);
TClass* ::TMatrixReconDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TMatrixReconDriver");
   }
   return fgIsA;
}
const char * ::TMatrixReconDriver::Class_Name() {return "TMatrixReconDriver";}
void ::TMatrixReconDriver::Dictionary() {}
const char *::TMatrixReconDriver::ImplFileName() {return "";}
int ::TMatrixReconDriver::ImplFileLine() {return 1;}
void ::TMatrixReconDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TMatrixReconDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_matrix", &m_matrix);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_matrixInverse", &m_matrixInverse);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_matrixSource", &m_matrixSource);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_matrixFile", &m_matrixFile);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_matrixFileName", &m_matrixFileName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hVoxelsInput", &hVoxelsInput);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hVoxelsReconAll", &hVoxelsReconAll);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_pixelDataAll", &m_pixelDataAll);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_voxelDataAll", &m_voxelDataAll);
   TDriver::ShowMembers(R__insp);
}
void ::TMatrixReconDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TMatrixReconDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TMatrixReconDriver::Class(),this);
   }
}

atomic_TClass_ptr TDriver::fgIsA(0);
TClass* ::TDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TDriver");
   }
   return fgIsA;
}
const char * ::TDriver::Class_Name() {return "TDriver";}
void ::TDriver::Dictionary() {}
const char *::TDriver::ImplFileName() {return "";}
int ::TDriver::ImplFileLine() {return 1;}
void ::TDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_manager", &m_manager);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_name", &m_name);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_verboseLevel", &m_verboseLevel);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_iterationN", &m_iterationN);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_isProofCompatible", &m_isProofCompatible);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_collectionName", &m_collectionName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_collectionRawName", &m_collectionRawName);
   TObject::ShowMembers(R__insp);
}
void ::TDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TDriver::Class(),this);
   }
}

atomic_TClass_ptr TAnalysis::fgIsA(0);
TClass* ::TAnalysis::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TAnalysis");
   }
   return fgIsA;
}
const char * ::TAnalysis::Class_Name() {return "TAnalysis";}
void ::TAnalysis::Dictionary() {}
const char *::TAnalysis::ImplFileName() {return "";}
int ::TAnalysis::ImplFileLine() {return 1;}
void ::TAnalysis::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TAnalysis::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_manager", &m_manager);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_chain", &m_chain);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_proof", &m_proof);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_steeringName", &m_steeringName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_detName", &m_detName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_fileName", &m_fileName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "isConfigured", &isConfigured);
   TObject::ShowMembers(R__insp);
}
void ::TAnalysis::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TAnalysis::Class(),this);
   } else {
      b.WriteClassBuffer(::TAnalysis::Class(),this);
   }
}


namespace {
//------Stub functions for class TChargeAnalysisDriver -------------------------------
static void constructor_3532( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TChargeAnalysisDriver();
  else ::new(mem) ::TChargeAnalysisDriver();
}

static void destructor_3533(void*, void * o, const std::vector<void*>&, void *) {
(((::TChargeAnalysisDriver*)o)->::TChargeAnalysisDriver::~TChargeAnalysisDriver)();
}
static  void method_3534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TChargeAnalysisDriver*)o)->start)());
  else   (((::TChargeAnalysisDriver*)o)->start)();
}

static  void method_3535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TChargeAnalysisDriver*)o)->startOfData)());
  else   (((::TChargeAnalysisDriver*)o)->startOfData)();
}

static  void method_3536( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TChargeAnalysisDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TChargeAnalysisDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_3537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TChargeAnalysisDriver*)o)->end)());
  else   (((::TChargeAnalysisDriver*)o)->end)();
}

static  void method_3538( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TChargeAnalysisDriver*)o)->setWriteOutFileName)((const char*)arg[0]);
}

static  void method_3539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TChargeAnalysisDriver*)o)->Class)());
  else   (((::TChargeAnalysisDriver*)o)->Class)();
}

static  void method_3540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TChargeAnalysisDriver*)o)->Class_Name)());
  else   (((::TChargeAnalysisDriver*)o)->Class_Name)();
}

static  void method_3541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TChargeAnalysisDriver*)o)->Class_Version)());
  else   (((::TChargeAnalysisDriver*)o)->Class_Version)();
}

static  void method_3542( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TChargeAnalysisDriver*)o)->Dictionary)();
}

static  void method_3543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TChargeAnalysisDriver*)o)->IsA)());
  else   (((const ::TChargeAnalysisDriver*)o)->IsA)();
}

static  void method_3544( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TChargeAnalysisDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_3545( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TChargeAnalysisDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_3546( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TChargeAnalysisDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_3547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TChargeAnalysisDriver*)o)->DeclFileName)());
  else   (((::TChargeAnalysisDriver*)o)->DeclFileName)();
}

static  void method_3548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TChargeAnalysisDriver*)o)->ImplFileLine)());
  else   (((::TChargeAnalysisDriver*)o)->ImplFileLine)();
}

static  void method_3549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TChargeAnalysisDriver*)o)->ImplFileName)());
  else   (((::TChargeAnalysisDriver*)o)->ImplFileName)();
}

static  void method_3550( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TChargeAnalysisDriver*)o)->DeclFileLine)());
  else   (((::TChargeAnalysisDriver*)o)->DeclFileLine)();
}

static void method_newdel_100( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TChargeAnalysisDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TChargeAnalysisDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TChargeAnalysisDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TChargeAnalysisDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TChargeAnalysisDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TChargeAnalysisDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TChargeAnalysisDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TChargeAnalysisDriver -------------------------------
void __TChargeAnalysisDriver_db_datamem(Reflex::Class*);
void __TChargeAnalysisDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TChargeAnalysisDriver_datamem_bld(&__TChargeAnalysisDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TChargeAnalysisDriver_funcmem_bld(&__TChargeAnalysisDriver_db_funcmem);
void __TChargeAnalysisDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TChargeAnalysisDriver"), typeid(::TChargeAnalysisDriver), sizeof(::TChargeAnalysisDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TChargeAnalysisDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2537, ::Reflex::BaseOffset< ::TChargeAnalysisDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TChargeAnalysisDriver"), constructor_3532, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TChargeAnalysisDriver"), destructor_3533, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_100, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TChargeAnalysisDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TChargeAnalysisDriver_funcmem_bld);
}

//------Delayed data member builder for class TChargeAnalysisDriver -------------------
void __TChargeAnalysisDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_14731, Reflex::Literal("hPixels"), OffsetOf(__shadow__::__TChargeAnalysisDriver, hPixels), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("m_nPixels"), OffsetOf(__shadow__::__TChargeAnalysisDriver, m_nPixels), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("m_nDetectors"), OffsetOf(__shadow__::__TChargeAnalysisDriver, m_nDetectors), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("m_writeOut"), OffsetOf(__shadow__::__TChargeAnalysisDriver, m_writeOut), ::Reflex::PRIVATE)
  .AddDataMember(type_2873, Reflex::Literal("m_writeOutFileName"), OffsetOf(__shadow__::__TChargeAnalysisDriver, m_writeOutFileName), ::Reflex::PRIVATE)
  .AddDataMember(type_1369, Reflex::Literal("m_writeOutFile"), OffsetOf(__shadow__::__TChargeAnalysisDriver, m_writeOutFile), ::Reflex::PRIVATE)
  .AddDataMember(type_2835, Reflex::Literal("m_Q"), OffsetOf(__shadow__::__TChargeAnalysisDriver, m_Q), ::Reflex::PRIVATE)
  .AddDataMember(type_14732, Reflex::Literal("hPixels2D"), OffsetOf(__shadow__::__TChargeAnalysisDriver, hPixels2D), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TChargeAnalysisDriver -------------------
void __TChargeAnalysisDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("start"), method_3534, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("startOfData"), method_3535, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143, type_14733), Reflex::Literal("process"), method_3536, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("end"), method_3537, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_3354), Reflex::Literal("setWriteOutFileName"), method_3538, 0, "fname", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("Class"), method_3539, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("Class_Name"), method_3540, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2467), Reflex::Literal("Class_Version"), method_3541, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("Dictionary"), method_3542, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("IsA"), method_3543, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_14710), Reflex::Literal("ShowMembers"), method_3544, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("Streamer"), method_3545, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("StreamerNVirtual"), method_3546, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("DeclFileName"), method_3547, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("ImplFileLine"), method_3548, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("ImplFileName"), method_3549, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("DeclFileLine"), method_3550, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TLikelihoodReconDriver -------------------------------
static  void operator_4055( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TLikelihoodReconDriver*)o)->operator=)(*(const ::TLikelihoodReconDriver*)arg[0]);
  else   (((::TLikelihoodReconDriver*)o)->operator=)(*(const ::TLikelihoodReconDriver*)arg[0]);
}

static void constructor_4056( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TLikelihoodReconDriver(*(const ::TLikelihoodReconDriver*)arg[0]);
  else ::new(mem) ::TLikelihoodReconDriver(*(const ::TLikelihoodReconDriver*)arg[0]);
}

static void constructor_4057( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TLikelihoodReconDriver();
  else ::new(mem) ::TLikelihoodReconDriver();
}

static void destructor_4058(void*, void * o, const std::vector<void*>&, void *) {
(((::TLikelihoodReconDriver*)o)->::TLikelihoodReconDriver::~TLikelihoodReconDriver)();
}
static  void method_4059( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TLikelihoodReconDriver*)o)->initFit)();
}

static  void method_4060( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TLikelihoodReconDriver*)o)->doFit)();
}

static  void method_4061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodReconDriver*)o)->getMinimizer)());
  else   (((::TLikelihoodReconDriver*)o)->getMinimizer)();
}

static  void method_4062( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TLikelihoodReconDriver*)o)->initParameters)();
}

static  void method_4063( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodReconDriver*)o)->setFitObject)(*(::fitObject_t*)arg[0]);
}

static  void method_4064( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodReconDriver*)o)->setFitLikelihoodMode)(*(::fitLikelihoodMode_t*)arg[0]);
}

static  void method_4065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodReconDriver*)o)->getFitObject)());
  else   (((::TLikelihoodReconDriver*)o)->getFitObject)();
}

static  void method_4066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodReconDriver*)o)->getFitLikelihoodMode)());
  else   (((::TLikelihoodReconDriver*)o)->getFitLikelihoodMode)();
}

static  void method_4067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodReconDriver*)o)->start)());
  else   (((::TLikelihoodReconDriver*)o)->start)();
}

static  void method_4068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodReconDriver*)o)->startOfData)());
  else   (((::TLikelihoodReconDriver*)o)->startOfData)();
}

static  void method_4069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodReconDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TLikelihoodReconDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_4070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodReconDriver*)o)->endOfData)());
  else   (((::TLikelihoodReconDriver*)o)->endOfData)();
}

static  void method_4071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodReconDriver*)o)->DoEval)((const double*)arg[0]));
  else   (((const ::TLikelihoodReconDriver*)o)->DoEval)((const double*)arg[0]);
}

static  void method_4072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::TLikelihoodReconDriver*)o)->NDim)());
  else   (((const ::TLikelihoodReconDriver*)o)->NDim)();
}

static  void method_4073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TLikelihoodReconDriver*)o)->Clone)());
  else   (((const ::TLikelihoodReconDriver*)o)->Clone)();
}

static  void method_4074( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodReconDriver*)o)->PointLikelihood)((const double*)arg[0]));
  else   (((const ::TLikelihoodReconDriver*)o)->PointLikelihood)((const double*)arg[0]);
}

static  void method_4075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodReconDriver*)o)->PointLikelihoodCharge)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]));
  else   (((const ::TLikelihoodReconDriver*)o)->PointLikelihoodCharge)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]);
}

static  void method_4076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodReconDriver*)o)->PointLikelihoodTime)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]));
  else   (((const ::TLikelihoodReconDriver*)o)->PointLikelihoodTime)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]);
}

static  void method_4077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodReconDriver*)o)->TrackLikelihood)((const double*)arg[0]));
  else   (((const ::TLikelihoodReconDriver*)o)->TrackLikelihood)((const double*)arg[0]);
}

static  void method_4078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodReconDriver*)o)->TrackLikelihoodTime)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]));
  else   (((const ::TLikelihoodReconDriver*)o)->TrackLikelihoodTime)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]);
}

static  void method_4079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodReconDriver*)o)->TrackLikelihoodCharge)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]));
  else   (((const ::TLikelihoodReconDriver*)o)->TrackLikelihoodCharge)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]);
}

static  void method_4080( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodReconDriver*)o)->setReconInputMode)((const char*)arg[0]);
}

static  void method_4081( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodReconDriver*)o)->setReconInputFileName)((const char*)arg[0]);
}

static  void method_4084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodReconDriver*)o)->Class)());
  else   (((::TLikelihoodReconDriver*)o)->Class)();
}

static  void method_4085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodReconDriver*)o)->Class_Name)());
  else   (((::TLikelihoodReconDriver*)o)->Class_Name)();
}

static  void method_4086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TLikelihoodReconDriver*)o)->Class_Version)());
  else   (((::TLikelihoodReconDriver*)o)->Class_Version)();
}

static  void method_4087( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TLikelihoodReconDriver*)o)->Dictionary)();
}

static  void method_4088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TLikelihoodReconDriver*)o)->IsA)());
  else   (((const ::TLikelihoodReconDriver*)o)->IsA)();
}

static  void method_4089( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodReconDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4090( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodReconDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4091( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodReconDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodReconDriver*)o)->DeclFileName)());
  else   (((::TLikelihoodReconDriver*)o)->DeclFileName)();
}

static  void method_4093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodReconDriver*)o)->ImplFileLine)());
  else   (((::TLikelihoodReconDriver*)o)->ImplFileLine)();
}

static  void method_4094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodReconDriver*)o)->ImplFileName)());
  else   (((::TLikelihoodReconDriver*)o)->ImplFileName)();
}

static  void method_4095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodReconDriver*)o)->DeclFileLine)());
  else   (((::TLikelihoodReconDriver*)o)->DeclFileLine)();
}

static void method_newdel_220( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TLikelihoodReconDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TLikelihoodReconDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TLikelihoodReconDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TLikelihoodReconDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TLikelihoodReconDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TLikelihoodReconDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TLikelihoodReconDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::IBaseFunctionMultiDim")), ::Reflex::BaseOffset< ::TLikelihoodReconDriver,::ROOT::Math::IBaseFunctionMultiDim >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TLikelihoodReconDriver -------------------------------
void __TLikelihoodReconDriver_db_datamem(Reflex::Class*);
void __TLikelihoodReconDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TLikelihoodReconDriver_datamem_bld(&__TLikelihoodReconDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TLikelihoodReconDriver_funcmem_bld(&__TLikelihoodReconDriver_db_funcmem);
void __TLikelihoodReconDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TLikelihoodReconDriver"), typeid(::TLikelihoodReconDriver), sizeof(::TLikelihoodReconDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TLikelihoodReconDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2537, ::Reflex::BaseOffset< ::TLikelihoodReconDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddBase(type_4096, ::Reflex::BaseOffset< ::TLikelihoodReconDriver, ::ROOT::Math::IBaseFunctionMultiDim >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14834, type_14835), Reflex::Literal("operator="), operator_4055, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14835), Reflex::Literal("TLikelihoodReconDriver"), constructor_4056, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TLikelihoodReconDriver"), constructor_4057, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TLikelihoodReconDriver"), destructor_4058, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_220, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TLikelihoodReconDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TLikelihoodReconDriver_funcmem_bld);
}

//------Delayed data member builder for class TLikelihoodReconDriver -------------------
void __TLikelihoodReconDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_14830, Reflex::Literal("m_minimizer"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_minimizer), ::Reflex::PRIVATE)
  .AddDataMember(type_14831, Reflex::Literal("m_reconInput"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_reconInput), ::Reflex::PRIVATE)
  .AddDataMember(type_394, Reflex::Literal("m_fitObject"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_fitObject), ::Reflex::PRIVATE)
  .AddDataMember(type_997, Reflex::Literal("m_fitLikelihoodMode"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_fitLikelihoodMode), ::Reflex::PRIVATE)
  .AddDataMember(type_14832, Reflex::Literal("m_N"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_N), ::Reflex::PRIVATE)
  .AddDataMember(type_14833, Reflex::Literal("m_Q"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_Q), ::Reflex::PRIVATE)
  .AddDataMember(type_14833, Reflex::Literal("m_t"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_t), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("m_reconInputMode"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_reconInputMode), ::Reflex::PRIVATE)
  .AddDataMember(type_2873, Reflex::Literal("m_reconInputFileName"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_reconInputFileName), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TLikelihoodReconDriver -------------------
void __TLikelihoodReconDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("initFit"), method_4059, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("doFit"), method_4060, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14830), Reflex::Literal("getMinimizer"), method_4061, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("initParameters"), method_4062, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_394), Reflex::Literal("setFitObject"), method_4063, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_997), Reflex::Literal("setFitLikelihoodMode"), method_4064, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("getFitObject"), method_4065, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_997), Reflex::Literal("getFitLikelihoodMode"), method_4066, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("start"), method_4067, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("startOfData"), method_4068, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143, type_14733), Reflex::Literal("process"), method_4069, 0, "m_event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("endOfData"), method_4070, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_239, type_11463), Reflex::Literal("DoEval"), method_4071, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_210), Reflex::Literal("NDim"), method_4072, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14839), Reflex::Literal("Clone"), method_4073, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_239, type_11463), Reflex::Literal("PointLikelihood"), method_4074, 0, "x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_239, type_143, type_143, type_143, type_11463), Reflex::Literal("PointLikelihoodCharge"), method_4075, 0, "iface;idetector;id;x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_239, type_143, type_143, type_143, type_11463), Reflex::Literal("PointLikelihoodTime"), method_4076, 0, "iface;idetector;id;x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_239, type_11463), Reflex::Literal("TrackLikelihood"), method_4077, 0, "x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_239, type_143, type_143, type_143, type_11463), Reflex::Literal("TrackLikelihoodTime"), method_4078, 0, "iface;idetector;id;x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_239, type_143, type_143, type_143, type_11463), Reflex::Literal("TrackLikelihoodCharge"), method_4079, 0, "iface;idetector;id;x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_3354), Reflex::Literal("setReconInputMode"), method_4080, 0, "mode", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_3354), Reflex::Literal("setReconInputFileName"), method_4081, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("Class"), method_4084, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("Class_Name"), method_4085, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2467), Reflex::Literal("Class_Version"), method_4086, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("Dictionary"), method_4087, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("IsA"), method_4088, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_14710), Reflex::Literal("ShowMembers"), method_4089, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("Streamer"), method_4090, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("StreamerNVirtual"), method_4091, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("DeclFileName"), method_4092, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("ImplFileLine"), method_4093, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("ImplFileName"), method_4094, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("DeclFileLine"), method_4095, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TReconInput -------------------------------
static  void operator_4550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TReconInput*)o)->operator=)(*(const ::TReconInput*)arg[0]);
  else   (((::TReconInput*)o)->operator=)(*(const ::TReconInput*)arg[0]);
}

static void constructor_4551( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TReconInput(*(const ::TReconInput*)arg[0]);
  else ::new(mem) ::TReconInput(*(const ::TReconInput*)arg[0]);
}

static void constructor_4552( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TReconInput();
  else ::new(mem) ::TReconInput();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TReconInput(*(::std::string*)arg[0]);
  else ::new(mem) ::TReconInput(*(::std::string*)arg[0]);
  }
}

static void destructor_4553(void*, void * o, const std::vector<void*>&, void *) {
(((::TReconInput*)o)->::TReconInput::~TReconInput)();
}
static  void method_4554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TReconInput*)o)->getParVal)(*(int*)arg[0]));
  else   (((const ::TReconInput*)o)->getParVal)(*(int*)arg[0]);
}

static  void method_4555( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconInput*)o)->setParVal)(*(int*)arg[0],
    *(double*)arg[1]);
}

static  void method_4556( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TReconInput*)o)->isParFixed)(*(int*)arg[0]));
  else   (((const ::TReconInput*)o)->isParFixed)(*(int*)arg[0]);
}

static  void method_4557( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::TReconInput*)o)->setParFixed)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::TReconInput*)o)->setParFixed)(*(int*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_4558( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TReconInput*)o)->isParLowLimited)(*(int*)arg[0]));
  else   (((const ::TReconInput*)o)->isParLowLimited)(*(int*)arg[0]);
}

static  void method_4559( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::TReconInput*)o)->setParLowLimited)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::TReconInput*)o)->setParLowLimited)(*(int*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_4560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TReconInput*)o)->getParLowLimit)(*(int*)arg[0]));
  else   (((const ::TReconInput*)o)->getParLowLimit)(*(int*)arg[0]);
}

static  void method_4561( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconInput*)o)->setParLowLimit)(*(int*)arg[0],
    *(double*)arg[1]);
}

static  void method_4562( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TReconInput*)o)->isParHighLimited)(*(int*)arg[0]));
  else   (((const ::TReconInput*)o)->isParHighLimited)(*(int*)arg[0]);
}

static  void method_4563( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::TReconInput*)o)->setParHighLimited)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::TReconInput*)o)->setParHighLimited)(*(int*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_4564( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TReconInput*)o)->getParHighLimit)(*(int*)arg[0]));
  else   (((const ::TReconInput*)o)->getParHighLimit)(*(int*)arg[0]);
}

static  void method_4565( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconInput*)o)->setParHighLimit)(*(int*)arg[0],
    *(double*)arg[1]);
}

static  void method_4566( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TReconInput*)o)->isParBothLimited)(*(int*)arg[0]));
  else   (((const ::TReconInput*)o)->isParBothLimited)(*(int*)arg[0]);
}

static  void method_4567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TReconInput*)o)->getFitObject)());
  else   (((const ::TReconInput*)o)->getFitObject)();
}

static  void method_4568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TReconInput*)o)->getFitLikelihoodMode)());
  else   (((::TReconInput*)o)->getFitLikelihoodMode)();
}

static  void method_4569( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::TReconInput*)o)->Print)();
}

static  void method_4570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TReconInput*)o)->Class)());
  else   (((::TReconInput*)o)->Class)();
}

static  void method_4571( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TReconInput*)o)->Class_Name)());
  else   (((::TReconInput*)o)->Class_Name)();
}

static  void method_4572( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TReconInput*)o)->Class_Version)());
  else   (((::TReconInput*)o)->Class_Version)();
}

static  void method_4573( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TReconInput*)o)->Dictionary)();
}

static  void method_4574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TReconInput*)o)->IsA)());
  else   (((const ::TReconInput*)o)->IsA)();
}

static  void method_4575( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconInput*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4576( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconInput*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4577( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconInput*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TReconInput*)o)->DeclFileName)());
  else   (((::TReconInput*)o)->DeclFileName)();
}

static  void method_4579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TReconInput*)o)->ImplFileLine)());
  else   (((::TReconInput*)o)->ImplFileLine)();
}

static  void method_4580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TReconInput*)o)->ImplFileName)());
  else   (((::TReconInput*)o)->ImplFileName)();
}

static  void method_4581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TReconInput*)o)->DeclFileLine)());
  else   (((::TReconInput*)o)->DeclFileLine)();
}

static void constructor_x4( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TReconInput();
  else ::new(mem) ::TReconInput();
}

static void method_newdel_516( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TReconInput >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TReconInput >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TReconInput >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TReconInput >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TReconInput >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::TReconInput,::TNamed >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TReconInput,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TReconInput -------------------------------
void __TReconInput_db_datamem(Reflex::Class*);
void __TReconInput_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TReconInput_datamem_bld(&__TReconInput_db_datamem);
Reflex::GenreflexMemberBuilder __TReconInput_funcmem_bld(&__TReconInput_db_funcmem);
void __TReconInput_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TReconInput"), typeid(::TReconInput), sizeof(::TReconInput), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TReconInput::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2616, ::Reflex::BaseOffset< ::TReconInput, ::TNamed >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14943, type_14944), Reflex::Literal("operator="), operator_4550, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14944), Reflex::Literal("TReconInput"), constructor_4551, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2873), Reflex::Literal("TReconInput"), constructor_4552, 0, "fname=\"\"", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TReconInput"), destructor_4553, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TReconInput"), constructor_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_516, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TReconInput_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TReconInput_funcmem_bld);
}

//------Delayed data member builder for class TReconInput -------------------
void __TReconInput_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_14941, Reflex::Literal("m_isParConfigured"), OffsetOf(__shadow__::__TReconInput, m_isParConfigured), ::Reflex::PRIVATE)
  .AddDataMember(type_14942, Reflex::Literal("m_parVal"), OffsetOf(__shadow__::__TReconInput, m_parVal), ::Reflex::PRIVATE)
  .AddDataMember(type_14941, Reflex::Literal("m_isParFixed"), OffsetOf(__shadow__::__TReconInput, m_isParFixed), ::Reflex::PRIVATE)
  .AddDataMember(type_14941, Reflex::Literal("m_isParLowLimited"), OffsetOf(__shadow__::__TReconInput, m_isParLowLimited), ::Reflex::PRIVATE)
  .AddDataMember(type_14941, Reflex::Literal("m_isParHighLimited"), OffsetOf(__shadow__::__TReconInput, m_isParHighLimited), ::Reflex::PRIVATE)
  .AddDataMember(type_14942, Reflex::Literal("m_parLowLimit"), OffsetOf(__shadow__::__TReconInput, m_parLowLimit), ::Reflex::PRIVATE)
  .AddDataMember(type_14942, Reflex::Literal("m_parHighLimit"), OffsetOf(__shadow__::__TReconInput, m_parHighLimit), ::Reflex::PRIVATE)
  .AddDataMember(type_394, Reflex::Literal("m_fitObject"), OffsetOf(__shadow__::__TReconInput, m_fitObject), ::Reflex::PRIVATE)
  .AddDataMember(type_997, Reflex::Literal("m_fitLikelihoodMode"), OffsetOf(__shadow__::__TReconInput, m_fitLikelihoodMode), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TReconInput -------------------
void __TReconInput_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_239, type_143), Reflex::Literal("getParVal"), method_4554, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143, type_239), Reflex::Literal("setParVal"), method_4555, 0, "id;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143, type_143), Reflex::Literal("isParFixed"), method_4556, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143, type_143), Reflex::Literal("setParFixed"), method_4557, 0, "id;fix=1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143, type_143), Reflex::Literal("isParLowLimited"), method_4558, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143, type_143), Reflex::Literal("setParLowLimited"), method_4559, 0, "id;limit=1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_239, type_143), Reflex::Literal("getParLowLimit"), method_4560, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143, type_239), Reflex::Literal("setParLowLimit"), method_4561, 0, "id;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143, type_143), Reflex::Literal("isParHighLimited"), method_4562, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143, type_143), Reflex::Literal("setParHighLimited"), method_4563, 0, "id;limit=1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_239, type_143), Reflex::Literal("getParHighLimit"), method_4564, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143, type_239), Reflex::Literal("setParHighLimit"), method_4565, 0, "id;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143, type_143), Reflex::Literal("isParBothLimited"), method_4566, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("getFitObject"), method_4567, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_997), Reflex::Literal("getFitLikelihoodMode"), method_4568, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("Print"), method_4569, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("Class"), method_4570, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("Class_Name"), method_4571, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2467), Reflex::Literal("Class_Version"), method_4572, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("Dictionary"), method_4573, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("IsA"), method_4574, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_14710), Reflex::Literal("ShowMembers"), method_4575, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("Streamer"), method_4576, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("StreamerNVirtual"), method_4577, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("DeclFileName"), method_4578, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("ImplFileLine"), method_4579, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("ImplFileName"), method_4580, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("DeclFileLine"), method_4581, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TEventMarkerDriver -------------------------------
static  void operator_4634( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TEventMarkerDriver*)o)->operator=)(*(const ::TEventMarkerDriver*)arg[0]);
  else   (((::TEventMarkerDriver*)o)->operator=)(*(const ::TEventMarkerDriver*)arg[0]);
}

static void constructor_4635( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TEventMarkerDriver(*(const ::TEventMarkerDriver*)arg[0]);
  else ::new(mem) ::TEventMarkerDriver(*(const ::TEventMarkerDriver*)arg[0]);
}

static void constructor_4636( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TEventMarkerDriver();
  else ::new(mem) ::TEventMarkerDriver();
}

static void destructor_4637(void*, void * o, const std::vector<void*>&, void *) {
(((::TEventMarkerDriver*)o)->::TEventMarkerDriver::~TEventMarkerDriver)();
}
static  void method_4638( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TEventMarkerDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TEventMarkerDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_4639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TEventMarkerDriver*)o)->getInterval)());
  else   (((const ::TEventMarkerDriver*)o)->getInterval)();
}

static  void method_4640( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEventMarkerDriver*)o)->setInterval)(*(int*)arg[0]);
}

static  void method_4641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEventMarkerDriver*)o)->Class)());
  else   (((::TEventMarkerDriver*)o)->Class)();
}

static  void method_4642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEventMarkerDriver*)o)->Class_Name)());
  else   (((::TEventMarkerDriver*)o)->Class_Name)();
}

static  void method_4643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TEventMarkerDriver*)o)->Class_Version)());
  else   (((::TEventMarkerDriver*)o)->Class_Version)();
}

static  void method_4644( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TEventMarkerDriver*)o)->Dictionary)();
}

static  void method_4645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TEventMarkerDriver*)o)->IsA)());
  else   (((const ::TEventMarkerDriver*)o)->IsA)();
}

static  void method_4646( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEventMarkerDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4647( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEventMarkerDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4648( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEventMarkerDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEventMarkerDriver*)o)->DeclFileName)());
  else   (((::TEventMarkerDriver*)o)->DeclFileName)();
}

static  void method_4650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TEventMarkerDriver*)o)->ImplFileLine)());
  else   (((::TEventMarkerDriver*)o)->ImplFileLine)();
}

static  void method_4651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEventMarkerDriver*)o)->ImplFileName)());
  else   (((::TEventMarkerDriver*)o)->ImplFileName)();
}

static  void method_4652( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TEventMarkerDriver*)o)->DeclFileLine)());
  else   (((::TEventMarkerDriver*)o)->DeclFileLine)();
}

static void method_newdel_576( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TEventMarkerDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TEventMarkerDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TEventMarkerDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TEventMarkerDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TEventMarkerDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TEventMarkerDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TEventMarkerDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TEventMarkerDriver -------------------------------
void __TEventMarkerDriver_db_datamem(Reflex::Class*);
void __TEventMarkerDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TEventMarkerDriver_datamem_bld(&__TEventMarkerDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TEventMarkerDriver_funcmem_bld(&__TEventMarkerDriver_db_funcmem);
void __TEventMarkerDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TEventMarkerDriver"), typeid(::TEventMarkerDriver), sizeof(::TEventMarkerDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TEventMarkerDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2537, ::Reflex::BaseOffset< ::TEventMarkerDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14955, type_14956), Reflex::Literal("operator="), operator_4634, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14956), Reflex::Literal("TEventMarkerDriver"), constructor_4635, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TEventMarkerDriver"), constructor_4636, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TEventMarkerDriver"), destructor_4637, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_576, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TEventMarkerDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TEventMarkerDriver_funcmem_bld);
}

//------Delayed data member builder for class TEventMarkerDriver -------------------
void __TEventMarkerDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_143, Reflex::Literal("m_interval"), OffsetOf(__shadow__::__TEventMarkerDriver, m_interval), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TEventMarkerDriver -------------------
void __TEventMarkerDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143, type_14733), Reflex::Literal("process"), method_4638, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("getInterval"), method_4639, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143), Reflex::Literal("setInterval"), method_4640, 0, "interval", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("Class"), method_4641, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("Class_Name"), method_4642, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2467), Reflex::Literal("Class_Version"), method_4643, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("Dictionary"), method_4644, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("IsA"), method_4645, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_14710), Reflex::Literal("ShowMembers"), method_4646, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("Streamer"), method_4647, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("StreamerNVirtual"), method_4648, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("DeclFileName"), method_4649, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("ImplFileLine"), method_4650, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("ImplFileName"), method_4651, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("DeclFileLine"), method_4652, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TRootSaveDriver -------------------------------
static  void operator_5932( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TRootSaveDriver*)o)->operator=)(*(const ::TRootSaveDriver*)arg[0]);
  else   (((::TRootSaveDriver*)o)->operator=)(*(const ::TRootSaveDriver*)arg[0]);
}

static void constructor_5933( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TRootSaveDriver(*(const ::TRootSaveDriver*)arg[0]);
  else ::new(mem) ::TRootSaveDriver(*(const ::TRootSaveDriver*)arg[0]);
}

static void constructor_5934( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TRootSaveDriver();
  else ::new(mem) ::TRootSaveDriver();
}

static void destructor_5935(void*, void * o, const std::vector<void*>&, void *) {
(((::TRootSaveDriver*)o)->::TRootSaveDriver::~TRootSaveDriver)();
}
static  void method_5936( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TRootSaveDriver*)o)->setOutFileName)((const char*)arg[0]);
}

static  void method_5937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TRootSaveDriver*)o)->end)());
  else   (((::TRootSaveDriver*)o)->end)();
}

static  void method_5938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TRootSaveDriver*)o)->Class)());
  else   (((::TRootSaveDriver*)o)->Class)();
}

static  void method_5939( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TRootSaveDriver*)o)->Class_Name)());
  else   (((::TRootSaveDriver*)o)->Class_Name)();
}

static  void method_5940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TRootSaveDriver*)o)->Class_Version)());
  else   (((::TRootSaveDriver*)o)->Class_Version)();
}

static  void method_5941( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TRootSaveDriver*)o)->Dictionary)();
}

static  void method_5942( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TRootSaveDriver*)o)->IsA)());
  else   (((const ::TRootSaveDriver*)o)->IsA)();
}

static  void method_5943( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TRootSaveDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5944( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TRootSaveDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5945( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TRootSaveDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TRootSaveDriver*)o)->DeclFileName)());
  else   (((::TRootSaveDriver*)o)->DeclFileName)();
}

static  void method_5947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TRootSaveDriver*)o)->ImplFileLine)());
  else   (((::TRootSaveDriver*)o)->ImplFileLine)();
}

static  void method_5948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TRootSaveDriver*)o)->ImplFileName)());
  else   (((::TRootSaveDriver*)o)->ImplFileName)();
}

static  void method_5949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TRootSaveDriver*)o)->DeclFileLine)());
  else   (((::TRootSaveDriver*)o)->DeclFileLine)();
}

static void method_newdel_1120( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TRootSaveDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TRootSaveDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TRootSaveDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TRootSaveDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TRootSaveDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TRootSaveDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TRootSaveDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TRootSaveDriver -------------------------------
void __TRootSaveDriver_db_datamem(Reflex::Class*);
void __TRootSaveDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TRootSaveDriver_datamem_bld(&__TRootSaveDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TRootSaveDriver_funcmem_bld(&__TRootSaveDriver_db_funcmem);
void __TRootSaveDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TRootSaveDriver"), typeid(::TRootSaveDriver), sizeof(::TRootSaveDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TRootSaveDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2537, ::Reflex::BaseOffset< ::TRootSaveDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15657, type_15658), Reflex::Literal("operator="), operator_5932, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15658), Reflex::Literal("TRootSaveDriver"), constructor_5933, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TRootSaveDriver"), constructor_5934, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TRootSaveDriver"), destructor_5935, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1120, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TRootSaveDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TRootSaveDriver_funcmem_bld);
}

//------Delayed data member builder for class TRootSaveDriver -------------------
void __TRootSaveDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2873, Reflex::Literal("m_fname"), OffsetOf(__shadow__::__TRootSaveDriver, m_fname), ::Reflex::PRIVATE)
  .AddDataMember(type_15012, Reflex::Literal("m_fout"), OffsetOf(__shadow__::__TRootSaveDriver, m_fout), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TRootSaveDriver -------------------
void __TRootSaveDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_3354), Reflex::Literal("setOutFileName"), method_5936, 0, "m_fname", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("end"), method_5937, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("Class"), method_5938, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("Class_Name"), method_5939, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2467), Reflex::Literal("Class_Version"), method_5940, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("Dictionary"), method_5941, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("IsA"), method_5942, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_14710), Reflex::Literal("ShowMembers"), method_5943, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("Streamer"), method_5944, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("StreamerNVirtual"), method_5945, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("DeclFileName"), method_5946, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("ImplFileLine"), method_5947, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("ImplFileName"), method_5948, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("DeclFileLine"), method_5949, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TMatrixWriterDriver -------------------------------
static  void operator_6366( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TMatrixWriterDriver*)o)->operator=)(*(const ::TMatrixWriterDriver*)arg[0]);
  else   (((::TMatrixWriterDriver*)o)->operator=)(*(const ::TMatrixWriterDriver*)arg[0]);
}

static void constructor_6367( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMatrixWriterDriver(*(const ::TMatrixWriterDriver*)arg[0]);
  else ::new(mem) ::TMatrixWriterDriver(*(const ::TMatrixWriterDriver*)arg[0]);
}

static void constructor_6368( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMatrixWriterDriver();
  else ::new(mem) ::TMatrixWriterDriver();
}

static void destructor_6369(void*, void * o, const std::vector<void*>&, void *) {
(((::TMatrixWriterDriver*)o)->::TMatrixWriterDriver::~TMatrixWriterDriver)();
}
static  void method_6370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixWriterDriver*)o)->start)());
  else   (((::TMatrixWriterDriver*)o)->start)();
}

static  void method_6371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixWriterDriver*)o)->startOfData)());
  else   (((::TMatrixWriterDriver*)o)->startOfData)();
}

static  void method_6372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixWriterDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TMatrixWriterDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_6373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixWriterDriver*)o)->end)());
  else   (((::TMatrixWriterDriver*)o)->end)();
}

static  void method_6374( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixWriterDriver*)o)->setVoxelID)(*(int*)arg[0]);
}

static  void method_6375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixWriterDriver*)o)->Class)());
  else   (((::TMatrixWriterDriver*)o)->Class)();
}

static  void method_6376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixWriterDriver*)o)->Class_Name)());
  else   (((::TMatrixWriterDriver*)o)->Class_Name)();
}

static  void method_6377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TMatrixWriterDriver*)o)->Class_Version)());
  else   (((::TMatrixWriterDriver*)o)->Class_Version)();
}

static  void method_6378( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TMatrixWriterDriver*)o)->Dictionary)();
}

static  void method_6379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMatrixWriterDriver*)o)->IsA)());
  else   (((const ::TMatrixWriterDriver*)o)->IsA)();
}

static  void method_6380( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixWriterDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_6381( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixWriterDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_6382( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixWriterDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_6383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixWriterDriver*)o)->DeclFileName)());
  else   (((::TMatrixWriterDriver*)o)->DeclFileName)();
}

static  void method_6384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixWriterDriver*)o)->ImplFileLine)());
  else   (((::TMatrixWriterDriver*)o)->ImplFileLine)();
}

static  void method_6385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixWriterDriver*)o)->ImplFileName)());
  else   (((::TMatrixWriterDriver*)o)->ImplFileName)();
}

static  void method_6386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixWriterDriver*)o)->DeclFileLine)());
  else   (((::TMatrixWriterDriver*)o)->DeclFileLine)();
}

static void method_newdel_1203( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TMatrixWriterDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TMatrixWriterDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TMatrixWriterDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TMatrixWriterDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TMatrixWriterDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TMatrixWriterDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TMatrixWriterDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TMatrixWriterDriver -------------------------------
void __TMatrixWriterDriver_db_datamem(Reflex::Class*);
void __TMatrixWriterDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TMatrixWriterDriver_datamem_bld(&__TMatrixWriterDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TMatrixWriterDriver_funcmem_bld(&__TMatrixWriterDriver_db_funcmem);
void __TMatrixWriterDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TMatrixWriterDriver"), typeid(::TMatrixWriterDriver), sizeof(::TMatrixWriterDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TMatrixWriterDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2537, ::Reflex::BaseOffset< ::TMatrixWriterDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15705, type_15706), Reflex::Literal("operator="), operator_6366, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15706), Reflex::Literal("TMatrixWriterDriver"), constructor_6367, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TMatrixWriterDriver"), constructor_6368, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TMatrixWriterDriver"), destructor_6369, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1203, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TMatrixWriterDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TMatrixWriterDriver_funcmem_bld);
}

//------Delayed data member builder for class TMatrixWriterDriver -------------------
void __TMatrixWriterDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_14731, Reflex::Literal("hPixels"), OffsetOf(__shadow__::__TMatrixWriterDriver, hPixels), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("m_nPixels"), OffsetOf(__shadow__::__TMatrixWriterDriver, m_nPixels), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("m_nDetectors"), OffsetOf(__shadow__::__TMatrixWriterDriver, m_nDetectors), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("m_voxelID"), OffsetOf(__shadow__::__TMatrixWriterDriver, m_voxelID), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TMatrixWriterDriver -------------------
void __TMatrixWriterDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("start"), method_6370, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("startOfData"), method_6371, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143, type_14733), Reflex::Literal("process"), method_6372, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("end"), method_6373, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143), Reflex::Literal("setVoxelID"), method_6374, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("Class"), method_6375, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("Class_Name"), method_6376, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2467), Reflex::Literal("Class_Version"), method_6377, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("Dictionary"), method_6378, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("IsA"), method_6379, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_14710), Reflex::Literal("ShowMembers"), method_6380, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("Streamer"), method_6381, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("StreamerNVirtual"), method_6382, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("DeclFileName"), method_6383, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("ImplFileLine"), method_6384, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("ImplFileName"), method_6385, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("DeclFileLine"), method_6386, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TJobManager -------------------------------
static void constructor_7026( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TJobManager();
  else ::new(mem) ::TJobManager();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TJobManager((::TTree*)arg[0]);
  else ::new(mem) ::TJobManager((::TTree*)arg[0]);
  }
}

static void destructor_7027(void*, void * o, const std::vector<void*>&, void *) {
(((::TJobManager*)o)->::TJobManager::~TJobManager)();
}
static  void method_7028( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::TJobManager*)o)->Version)());
  else   (((const ::TJobManager*)o)->Version)();
}

static  void method_7029( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->Begin)((::TTree*)arg[0]);
}

static  void method_7030( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->SlaveBegin)((::TTree*)arg[0]);
}

static  void method_7031( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Int_t)((((::TJobManager*)o)->GetEntry)(*(::Long64_t*)arg[0]));
    else     (((::TJobManager*)o)->GetEntry)(*(::Long64_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Int_t)((((::TJobManager*)o)->GetEntry)(*(::Long64_t*)arg[0],
      *(::Int_t*)arg[1]));
    else     (((::TJobManager*)o)->GetEntry)(*(::Long64_t*)arg[0],
      *(::Int_t*)arg[1]);
  }
}

static  void method_7032( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->SetOption)((const char*)arg[0]);
}

static  void method_7033( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->SetObject)((::TObject*)arg[0]);
}

static  void method_7034( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->SetInputList)((::TList*)arg[0]);
}

static  void method_7035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TJobManager*)o)->GetOutputList)());
  else   (((const ::TJobManager*)o)->GetOutputList)();
}

static  void method_7036( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TJobManager*)o)->SlaveTerminate)();
}

static  void method_7037( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TJobManager*)o)->Terminate)();
}

static  void method_7038( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((::TJobManager*)o)->Notify)());
  else   (((::TJobManager*)o)->Notify)();
}

static  void method_7039( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->Init)((::TTree*)arg[0]);
}

static  void method_7040( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((::TJobManager*)o)->Process)(*(::Long64_t*)arg[0]));
  else   (((::TJobManager*)o)->Process)(*(::Long64_t*)arg[0]);
}

static  void method_7041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TJobManager*)o)->ClassName)());
  else   (((const ::TJobManager*)o)->ClassName)();
}

static  void method_7042( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::TJobManager*)o)->Config)();
  }
  else if ( arg.size() == 1 ) { 
    (((::TJobManager*)o)->Config)(*(::std::string*)arg[0]);
  }
}

static  void method_7043( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setVariable)(*(::std::string*)arg[0],
    *(::std::string*)arg[1]);
}

static  void method_7044( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->hasVariable)(*(::std::string*)arg[0]));
  else   (((const ::TJobManager*)o)->hasVariable)(*(::std::string*)arg[0]);
}

static  void method_7045( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::TJobManager*)o)->getVariable)(*(::std::string*)arg[0]));
  else   (((const ::TJobManager*)o)->getVariable)(*(::std::string*)arg[0]);
}

static  void method_7046( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::TJobManager*)o)->printVariables)();
}

static  void method_7047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TJobManager*)o)->getDrivers)());
  else   (((::TJobManager*)o)->getDrivers)();
}

static  void method_7048( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TJobManager*)o)->getDriver)(*(int*)arg[0]));
  else   (((::TJobManager*)o)->getDriver)(*(int*)arg[0]);
}

static  void method_7049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getEventN)());
  else   (((const ::TJobManager*)o)->getEventN)();
}

static  void method_7050( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setEventN)(*(int*)arg[0]);
}

static  void method_7051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getDoProof)());
  else   (((const ::TJobManager*)o)->getDoProof)();
}

static  void method_7052( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setDoProof)(*(int*)arg[0]);
}

static  void method_7053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getDoProofDiag)());
  else   (((const ::TJobManager*)o)->getDoProofDiag)();
}

static  void method_7054( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setDoProofDiag)(*(int*)arg[0]);
}

static  void method_7055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getNumberOfEvents)());
  else   (((const ::TJobManager*)o)->getNumberOfEvents)();
}

static  void method_7056( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setNumberOfEvents)(*(int*)arg[0]);
}

static  void method_7057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getSkipEvents)());
  else   (((const ::TJobManager*)o)->getSkipEvents)();
}

static  void method_7058( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setSkipEvents)(*(int*)arg[0]);
}

static  void method_7059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getVerboseLevel)());
  else   (((const ::TJobManager*)o)->getVerboseLevel)();
}

static  void method_7060( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setVerboseLevel)(*(int*)arg[0]);
}

static  void method_7061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getDryRun)());
  else   (((const ::TJobManager*)o)->getDryRun)();
}

static  void method_7062( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setDryRun)(*(int*)arg[0]);
}

static  void method_7063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getNumberOfWorkers)());
  else   (((const ::TJobManager*)o)->getNumberOfWorkers)();
}

static  void method_7064( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setNumberOfWorkers)(*(int*)arg[0]);
}

static  void method_7065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getIterationN)());
  else   (((const ::TJobManager*)o)->getIterationN)();
}

static  void method_7066( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setIterationN)(*(int*)arg[0]);
}

static  void method_7067( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TJobManager*)o)->incrementIterationN)();
}

static  void method_7068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TJobManager*)o)->isLastIteration)());
  else   (((::TJobManager*)o)->isLastIteration)();
}

static  void method_7069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getNumberOfIterations)());
  else   (((const ::TJobManager*)o)->getNumberOfIterations)();
}

static  void method_7070( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setNumberOfIterations)(*(int*)arg[0]);
}

static  void method_7071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TJobManager*)o)->getDetector)());
  else   (((const ::TJobManager*)o)->getDetector)();
}

static  void method_7072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TJobManager*)o)->getDetectorUtils)());
  else   (((const ::TJobManager*)o)->getDetectorUtils)();
}

static  void method_7073( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setDetector)((::TDetectorLight*)arg[0]);
}

static  void method_7074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->isProofCompatible)());
  else   (((const ::TJobManager*)o)->isProofCompatible)();
}

static  void method_7075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TJobManager*)o)->Class)());
  else   (((::TJobManager*)o)->Class)();
}

static  void method_7076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TJobManager*)o)->Class_Name)());
  else   (((::TJobManager*)o)->Class_Name)();
}

static  void method_7077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TJobManager*)o)->Class_Version)());
  else   (((::TJobManager*)o)->Class_Version)();
}

static  void method_7078( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TJobManager*)o)->Dictionary)();
}

static  void method_7079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TJobManager*)o)->IsA)());
  else   (((const ::TJobManager*)o)->IsA)();
}

static  void method_7080( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_7081( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_7082( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_7083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TJobManager*)o)->DeclFileName)());
  else   (((::TJobManager*)o)->DeclFileName)();
}

static  void method_7084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TJobManager*)o)->ImplFileLine)());
  else   (((::TJobManager*)o)->ImplFileLine)();
}

static  void method_7085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TJobManager*)o)->ImplFileName)());
  else   (((::TJobManager*)o)->ImplFileName)();
}

static  void method_7086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TJobManager*)o)->DeclFileLine)());
  else   (((::TJobManager*)o)->DeclFileLine)();
}

static void constructor_x13( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TJobManager();
  else ::new(mem) ::TJobManager();
}

static void method_newdel_1337( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TJobManager >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TJobManager >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TJobManager >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TJobManager >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TJobManager >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TSelector")), ::Reflex::BaseOffset< ::TJobManager,::TSelector >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TJobManager,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TJobManager -------------------------------
void __TJobManager_db_datamem(Reflex::Class*);
void __TJobManager_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TJobManager_datamem_bld(&__TJobManager_db_datamem);
Reflex::GenreflexMemberBuilder __TJobManager_funcmem_bld(&__TJobManager_db_funcmem);
void __TJobManager_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TJobManager"), typeid(::TJobManager), sizeof(::TJobManager), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TJobManager::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_405, ::Reflex::BaseOffset< ::TJobManager, ::TSelector >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5465), Reflex::Literal("TJobManager"), constructor_7026, 0, "t=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TJobManager"), destructor_7027, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TJobManager"), constructor_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1337, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TJobManager_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TJobManager_funcmem_bld);
}

//------Delayed data member builder for class TJobManager -------------------
void __TJobManager_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5465, Reflex::Literal("fTree"), OffsetOf(__shadow__::__TJobManager, fTree), ::Reflex::PRIVATE)
  .AddDataMember(type_5464, Reflex::Literal("b_event"), OffsetOf(__shadow__::__TJobManager, b_event), ::Reflex::PRIVATE)
  .AddDataMember(type_14733, Reflex::Literal("m_event"), OffsetOf(__shadow__::__TJobManager, m_event), ::Reflex::PRIVATE)
  .AddDataMember(type_15783, Reflex::Literal("m_xmlHandler"), OffsetOf(__shadow__::__TJobManager, m_xmlHandler), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_15784, Reflex::Literal("m_drivers"), OffsetOf(__shadow__::__TJobManager, m_drivers), ::Reflex::PRIVATE)
  .AddDataMember(type_15785, Reflex::Literal("m_detector"), OffsetOf(__shadow__::__TJobManager, m_detector), ::Reflex::PRIVATE)
  .AddDataMember(type_15786, Reflex::Literal("m_detectorUtils"), OffsetOf(__shadow__::__TJobManager, m_detectorUtils), ::Reflex::PRIVATE)
  .AddDataMember(type_15787, Reflex::Literal("m_variables"), OffsetOf(__shadow__::__TJobManager, m_variables), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_143, Reflex::Literal("m_eventN"), OffsetOf(__shadow__::__TJobManager, m_eventN), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("m_doProof"), OffsetOf(__shadow__::__TJobManager, m_doProof), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("m_doProofDiag"), OffsetOf(__shadow__::__TJobManager, m_doProofDiag), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("m_skipEvents"), OffsetOf(__shadow__::__TJobManager, m_skipEvents), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("m_numberOfEvents"), OffsetOf(__shadow__::__TJobManager, m_numberOfEvents), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("m_verboseLevel"), OffsetOf(__shadow__::__TJobManager, m_verboseLevel), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("m_dryRun"), OffsetOf(__shadow__::__TJobManager, m_dryRun), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("m_numberOfWorkers"), OffsetOf(__shadow__::__TJobManager, m_numberOfWorkers), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("m_numberOfIterations"), OffsetOf(__shadow__::__TJobManager, m_numberOfIterations), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("m_iterationN"), OffsetOf(__shadow__::__TJobManager, m_iterationN), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("m_isProofCompatible"), OffsetOf(__shadow__::__TJobManager, m_isProofCompatible), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TJobManager -------------------
void __TJobManager_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_863), Reflex::Literal("Version"), method_7028, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_5465), Reflex::Literal("Begin"), method_7029, 0, "tree", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_5465), Reflex::Literal("SlaveBegin"), method_7030, 0, "tree", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_863, type_1935, type_863), Reflex::Literal("GetEntry"), method_7031, 0, "entry;getall=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_3354), Reflex::Literal("SetOption"), method_7032, 0, "option", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_13018), Reflex::Literal("SetObject"), method_7033, 0, "obj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_14897), Reflex::Literal("SetInputList"), method_7034, 0, "input", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14897), Reflex::Literal("GetOutputList"), method_7035, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("SlaveTerminate"), method_7036, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("Terminate"), method_7037, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_650), Reflex::Literal("Notify"), method_7038, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_5465), Reflex::Literal("Init"), method_7039, 0, "tree", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_650, type_1935), Reflex::Literal("Process"), method_7040, 0, "entry", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("ClassName"), method_7041, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_2873), Reflex::Literal("Config"), method_7042, 0, "fname=\"reconstruction.xml\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_2873, type_2873), Reflex::Literal("setVariable"), method_7043, 0, "name;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143, type_2873), Reflex::Literal("hasVariable"), method_7044, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2873, type_2873), Reflex::Literal("getVariable"), method_7045, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("printVariables"), method_7046, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15784), Reflex::Literal("getDrivers"), method_7047, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8546, type_143), Reflex::Literal("getDriver"), method_7048, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("getEventN"), method_7049, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143), Reflex::Literal("setEventN"), method_7050, 0, "eventN", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("getDoProof"), method_7051, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143), Reflex::Literal("setDoProof"), method_7052, 0, "doProof", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("getDoProofDiag"), method_7053, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143), Reflex::Literal("setDoProofDiag"), method_7054, 0, "doProofDiag", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("getNumberOfEvents"), method_7055, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143), Reflex::Literal("setNumberOfEvents"), method_7056, 0, "numberOfEvents", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("getSkipEvents"), method_7057, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143), Reflex::Literal("setSkipEvents"), method_7058, 0, "skipEvents", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("getVerboseLevel"), method_7059, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143), Reflex::Literal("setVerboseLevel"), method_7060, 0, "verboseLevel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("getDryRun"), method_7061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143), Reflex::Literal("setDryRun"), method_7062, 0, "dryRun", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("getNumberOfWorkers"), method_7063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143), Reflex::Literal("setNumberOfWorkers"), method_7064, 0, "numberOfWorkers", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("getIterationN"), method_7065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143), Reflex::Literal("setIterationN"), method_7066, 0, "iterationN", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("incrementIterationN"), method_7067, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("isLastIteration"), method_7068, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("getNumberOfIterations"), method_7069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143), Reflex::Literal("setNumberOfIterations"), method_7070, 0, "numberOfIterations", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15785), Reflex::Literal("getDetector"), method_7071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15786), Reflex::Literal("getDetectorUtils"), method_7072, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_15785), Reflex::Literal("setDetector"), method_7073, 0, "detector", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("isProofCompatible"), method_7074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("Class"), method_7075, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("Class_Name"), method_7076, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2467), Reflex::Literal("Class_Version"), method_7077, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("Dictionary"), method_7078, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("IsA"), method_7079, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_14710), Reflex::Literal("ShowMembers"), method_7080, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("Streamer"), method_7081, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("StreamerNVirtual"), method_7082, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("DeclFileName"), method_7083, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("ImplFileLine"), method_7084, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("ImplFileName"), method_7085, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("DeclFileLine"), method_7086, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TMatrixInterpreterDriver -------------------------------
static  void operator_7145( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TMatrixInterpreterDriver*)o)->operator=)(*(const ::TMatrixInterpreterDriver*)arg[0]);
  else   (((::TMatrixInterpreterDriver*)o)->operator=)(*(const ::TMatrixInterpreterDriver*)arg[0]);
}

static void constructor_7146( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMatrixInterpreterDriver(*(const ::TMatrixInterpreterDriver*)arg[0]);
  else ::new(mem) ::TMatrixInterpreterDriver(*(const ::TMatrixInterpreterDriver*)arg[0]);
}

static void constructor_7147( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMatrixInterpreterDriver();
  else ::new(mem) ::TMatrixInterpreterDriver();
}

static void destructor_7148(void*, void * o, const std::vector<void*>&, void *) {
(((::TMatrixInterpreterDriver*)o)->::TMatrixInterpreterDriver::~TMatrixInterpreterDriver)();
}
static  void method_7149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixInterpreterDriver*)o)->startOfData)());
  else   (((::TMatrixInterpreterDriver*)o)->startOfData)();
}

static  void method_7150( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixInterpreterDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TMatrixInterpreterDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_7151( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixInterpreterDriver*)o)->Class)());
  else   (((::TMatrixInterpreterDriver*)o)->Class)();
}

static  void method_7152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixInterpreterDriver*)o)->Class_Name)());
  else   (((::TMatrixInterpreterDriver*)o)->Class_Name)();
}

static  void method_7153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TMatrixInterpreterDriver*)o)->Class_Version)());
  else   (((::TMatrixInterpreterDriver*)o)->Class_Version)();
}

static  void method_7154( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TMatrixInterpreterDriver*)o)->Dictionary)();
}

static  void method_7155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMatrixInterpreterDriver*)o)->IsA)());
  else   (((const ::TMatrixInterpreterDriver*)o)->IsA)();
}

static  void method_7156( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixInterpreterDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_7157( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixInterpreterDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_7158( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixInterpreterDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_7159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixInterpreterDriver*)o)->DeclFileName)());
  else   (((::TMatrixInterpreterDriver*)o)->DeclFileName)();
}

static  void method_7160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixInterpreterDriver*)o)->ImplFileLine)());
  else   (((::TMatrixInterpreterDriver*)o)->ImplFileLine)();
}

static  void method_7161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixInterpreterDriver*)o)->ImplFileName)());
  else   (((::TMatrixInterpreterDriver*)o)->ImplFileName)();
}

static  void method_7162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixInterpreterDriver*)o)->DeclFileLine)());
  else   (((::TMatrixInterpreterDriver*)o)->DeclFileLine)();
}

static void method_newdel_1428( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TMatrixInterpreterDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TMatrixInterpreterDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TMatrixInterpreterDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TMatrixInterpreterDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TMatrixInterpreterDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TMatrixInterpreterDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TMatrixInterpreterDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TMatrixInterpreterDriver -------------------------------
void __TMatrixInterpreterDriver_db_datamem(Reflex::Class*);
void __TMatrixInterpreterDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TMatrixInterpreterDriver_datamem_bld(&__TMatrixInterpreterDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TMatrixInterpreterDriver_funcmem_bld(&__TMatrixInterpreterDriver_db_funcmem);
void __TMatrixInterpreterDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TMatrixInterpreterDriver"), typeid(::TMatrixInterpreterDriver), sizeof(::TMatrixInterpreterDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TMatrixInterpreterDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2537, ::Reflex::BaseOffset< ::TMatrixInterpreterDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15808, type_15809), Reflex::Literal("operator="), operator_7145, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15809), Reflex::Literal("TMatrixInterpreterDriver"), constructor_7146, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TMatrixInterpreterDriver"), constructor_7147, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TMatrixInterpreterDriver"), destructor_7148, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1428, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TMatrixInterpreterDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TMatrixInterpreterDriver_funcmem_bld);
}

//------Delayed data member builder for class TMatrixInterpreterDriver -------------------
void __TMatrixInterpreterDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_15807, Reflex::Literal("hVoxelRecon"), OffsetOf(__shadow__::__TMatrixInterpreterDriver, hVoxelRecon), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TMatrixInterpreterDriver -------------------
void __TMatrixInterpreterDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("startOfData"), method_7149, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143, type_14733), Reflex::Literal("process"), method_7150, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("Class"), method_7151, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("Class_Name"), method_7152, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2467), Reflex::Literal("Class_Version"), method_7153, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("Dictionary"), method_7154, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("IsA"), method_7155, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_14710), Reflex::Literal("ShowMembers"), method_7156, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("Streamer"), method_7157, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("StreamerNVirtual"), method_7158, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("DeclFileName"), method_7159, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("ImplFileLine"), method_7160, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("ImplFileName"), method_7161, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("DeclFileLine"), method_7162, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TMatrixReconDriver -------------------------------
static  void operator_8820( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TMatrixReconDriver*)o)->operator=)(*(const ::TMatrixReconDriver*)arg[0]);
  else   (((::TMatrixReconDriver*)o)->operator=)(*(const ::TMatrixReconDriver*)arg[0]);
}

static void constructor_8821( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMatrixReconDriver(*(const ::TMatrixReconDriver*)arg[0]);
  else ::new(mem) ::TMatrixReconDriver(*(const ::TMatrixReconDriver*)arg[0]);
}

static void constructor_8822( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMatrixReconDriver();
  else ::new(mem) ::TMatrixReconDriver();
}

static void destructor_8823(void*, void * o, const std::vector<void*>&, void *) {
(((::TMatrixReconDriver*)o)->::TMatrixReconDriver::~TMatrixReconDriver)();
}
static  void method_8824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixReconDriver*)o)->startOfData)());
  else   (((::TMatrixReconDriver*)o)->startOfData)();
}

static  void method_8825( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixReconDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TMatrixReconDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_8826( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixReconDriver*)o)->endOfData)());
  else   (((::TMatrixReconDriver*)o)->endOfData)();
}

static  void method_8827( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixReconDriver*)o)->setMatrixSource)((const char*)arg[0]);
}

static  void method_8828( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixReconDriver*)o)->setMatrixFileName)((const char*)arg[0]);
}

static  void method_8829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixReconDriver*)o)->Class)());
  else   (((::TMatrixReconDriver*)o)->Class)();
}

static  void method_8830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixReconDriver*)o)->Class_Name)());
  else   (((::TMatrixReconDriver*)o)->Class_Name)();
}

static  void method_8831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TMatrixReconDriver*)o)->Class_Version)());
  else   (((::TMatrixReconDriver*)o)->Class_Version)();
}

static  void method_8832( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TMatrixReconDriver*)o)->Dictionary)();
}

static  void method_8833( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMatrixReconDriver*)o)->IsA)());
  else   (((const ::TMatrixReconDriver*)o)->IsA)();
}

static  void method_8834( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixReconDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_8835( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixReconDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_8836( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixReconDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_8837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixReconDriver*)o)->DeclFileName)());
  else   (((::TMatrixReconDriver*)o)->DeclFileName)();
}

static  void method_8838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixReconDriver*)o)->ImplFileLine)());
  else   (((::TMatrixReconDriver*)o)->ImplFileLine)();
}

static  void method_8839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixReconDriver*)o)->ImplFileName)());
  else   (((::TMatrixReconDriver*)o)->ImplFileName)();
}

static  void method_8840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixReconDriver*)o)->DeclFileLine)());
  else   (((::TMatrixReconDriver*)o)->DeclFileLine)();
}

static void method_newdel_2102( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TMatrixReconDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TMatrixReconDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TMatrixReconDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TMatrixReconDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TMatrixReconDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x19( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TMatrixReconDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TMatrixReconDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TMatrixReconDriver -------------------------------
void __TMatrixReconDriver_db_datamem(Reflex::Class*);
void __TMatrixReconDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TMatrixReconDriver_datamem_bld(&__TMatrixReconDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TMatrixReconDriver_funcmem_bld(&__TMatrixReconDriver_db_funcmem);
void __TMatrixReconDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TMatrixReconDriver"), typeid(::TMatrixReconDriver), sizeof(::TMatrixReconDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TMatrixReconDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2537, ::Reflex::BaseOffset< ::TMatrixReconDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16811, type_16812), Reflex::Literal("operator="), operator_8820, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16812), Reflex::Literal("TMatrixReconDriver"), constructor_8821, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TMatrixReconDriver"), constructor_8822, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TMatrixReconDriver"), destructor_8823, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2102, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x19, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TMatrixReconDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TMatrixReconDriver_funcmem_bld);
}

//------Delayed data member builder for class TMatrixReconDriver -------------------
void __TMatrixReconDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_16810, Reflex::Literal("m_matrix"), OffsetOf(__shadow__::__TMatrixReconDriver, m_matrix), ::Reflex::PRIVATE)
  .AddDataMember(type_149, Reflex::Literal("m_matrixInverse"), OffsetOf(__shadow__::__TMatrixReconDriver, m_matrixInverse), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("m_matrixSource"), OffsetOf(__shadow__::__TMatrixReconDriver, m_matrixSource), ::Reflex::PRIVATE)
  .AddDataMember(type_15012, Reflex::Literal("m_matrixFile"), OffsetOf(__shadow__::__TMatrixReconDriver, m_matrixFile), ::Reflex::PRIVATE)
  .AddDataMember(type_2873, Reflex::Literal("m_matrixFileName"), OffsetOf(__shadow__::__TMatrixReconDriver, m_matrixFileName), ::Reflex::PRIVATE)
  .AddDataMember(type_15807, Reflex::Literal("hVoxelsInput"), OffsetOf(__shadow__::__TMatrixReconDriver, hVoxelsInput), ::Reflex::PRIVATE)
  .AddDataMember(type_15807, Reflex::Literal("hVoxelsReconAll"), OffsetOf(__shadow__::__TMatrixReconDriver, hVoxelsReconAll), ::Reflex::PRIVATE)
  .AddDataMember(type_149, Reflex::Literal("m_pixelDataAll"), OffsetOf(__shadow__::__TMatrixReconDriver, m_pixelDataAll), ::Reflex::PRIVATE)
  .AddDataMember(type_149, Reflex::Literal("m_voxelDataAll"), OffsetOf(__shadow__::__TMatrixReconDriver, m_voxelDataAll), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TMatrixReconDriver -------------------
void __TMatrixReconDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("startOfData"), method_8824, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143, type_14733), Reflex::Literal("process"), method_8825, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("endOfData"), method_8826, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_3354), Reflex::Literal("setMatrixSource"), method_8827, 0, "source", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_3354), Reflex::Literal("setMatrixFileName"), method_8828, 0, "fname", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("Class"), method_8829, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("Class_Name"), method_8830, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2467), Reflex::Literal("Class_Version"), method_8831, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("Dictionary"), method_8832, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("IsA"), method_8833, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_14710), Reflex::Literal("ShowMembers"), method_8834, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("Streamer"), method_8835, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("StreamerNVirtual"), method_8836, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("DeclFileName"), method_8837, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("ImplFileLine"), method_8838, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("ImplFileName"), method_8839, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("DeclFileLine"), method_8840, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TDriver -------------------------------
static  void operator_9660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TDriver*)o)->operator=)(*(const ::TDriver*)arg[0]);
  else   (((::TDriver*)o)->operator=)(*(const ::TDriver*)arg[0]);
}

static void constructor_9661( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TDriver(*(const ::TDriver*)arg[0]);
  else ::new(mem) ::TDriver(*(const ::TDriver*)arg[0]);
}

static void constructor_9662( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TDriver();
  else ::new(mem) ::TDriver();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TDriver((::TJobManager*)arg[0]);
  else ::new(mem) ::TDriver((::TJobManager*)arg[0]);
  }
}

static void destructor_9663(void*, void * o, const std::vector<void*>&, void *) {
(((::TDriver*)o)->::TDriver::~TDriver)();
}
static  void method_9664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->start)());
  else   (((::TDriver*)o)->start)();
}

static  void method_9665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->startOfData)());
  else   (((::TDriver*)o)->startOfData)();
}

static  void method_9666( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->endOfData)());
  else   (((::TDriver*)o)->endOfData)();
}

static  void method_9667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->end)());
  else   (((::TDriver*)o)->end)();
}

static  void method_9668( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_9669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->detectorChanged)());
  else   (((::TDriver*)o)->detectorChanged)();
}

static  void method_9670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TDriver*)o)->getManager)());
  else   (((const ::TDriver*)o)->getManager)();
}

static  void method_9671( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->setManager)((::TJobManager*)arg[0]);
}

static  void method_9672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::TDriver*)o)->getName)();
  else   (((const ::TDriver*)o)->getName)();
}

static  void method_9673( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->setName)(*(const ::std::string*)arg[0]);
}

static  void method_9674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDriver*)o)->getVerboseLevel)());
  else   (((const ::TDriver*)o)->getVerboseLevel)();
}

static  void method_9675( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->setVerboseLevel)(*(int*)arg[0]);
}

static  void method_9676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDriver*)o)->getIterationN)());
  else   (((const ::TDriver*)o)->getIterationN)();
}

static  void method_9677( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->setIterationN)(*(int*)arg[0]);
}

static  void method_9678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDriver*)o)->isProofCompatible)());
  else   (((const ::TDriver*)o)->isProofCompatible)();
}

static  void method_9679( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->setIsProofCompatible)(*(int*)arg[0]);
}

static  void method_9680( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->setCollectionName)((const char*)arg[0]);
}

static  void method_9681( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->setCollectionRawName)((const char*)arg[0]);
}

static  void method_9682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDriver*)o)->Class)());
  else   (((::TDriver*)o)->Class)();
}

static  void method_9683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDriver*)o)->Class_Name)());
  else   (((::TDriver*)o)->Class_Name)();
}

static  void method_9684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TDriver*)o)->Class_Version)());
  else   (((::TDriver*)o)->Class_Version)();
}

static  void method_9685( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TDriver*)o)->Dictionary)();
}

static  void method_9686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TDriver*)o)->IsA)());
  else   (((const ::TDriver*)o)->IsA)();
}

static  void method_9687( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_9688( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_9689( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_9690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDriver*)o)->DeclFileName)());
  else   (((::TDriver*)o)->DeclFileName)();
}

static  void method_9691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->ImplFileLine)());
  else   (((::TDriver*)o)->ImplFileLine)();
}

static  void method_9692( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDriver*)o)->ImplFileName)());
  else   (((::TDriver*)o)->ImplFileName)();
}

static  void method_9693( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->DeclFileLine)());
  else   (((::TDriver*)o)->DeclFileLine)();
}

static void constructor_x20( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TDriver();
  else ::new(mem) ::TDriver();
}

static void method_newdel_2537( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TDriver,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TDriver -------------------------------
void __TDriver_db_datamem(Reflex::Class*);
void __TDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TDriver_datamem_bld(&__TDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TDriver_funcmem_bld(&__TDriver_db_funcmem);
void __TDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TDriver"), typeid(::TDriver), sizeof(::TDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2231, ::Reflex::BaseOffset< ::TDriver, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17091, type_17092), Reflex::Literal("operator="), operator_9660, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17092), Reflex::Literal("TDriver"), constructor_9661, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17090), Reflex::Literal("TDriver"), constructor_9662, 0, "manager=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TDriver"), destructor_9663, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TDriver"), constructor_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2537, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TDriver_funcmem_bld);
}

//------Delayed data member builder for class TDriver -------------------
void __TDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17090, Reflex::Literal("m_manager"), OffsetOf(__shadow__::__TDriver, m_manager), ::Reflex::PROTECTED)
  .AddDataMember(type_2873, Reflex::Literal("m_name"), OffsetOf(__shadow__::__TDriver, m_name), ::Reflex::PROTECTED)
  .AddDataMember(type_143, Reflex::Literal("m_verboseLevel"), OffsetOf(__shadow__::__TDriver, m_verboseLevel), ::Reflex::PROTECTED)
  .AddDataMember(type_143, Reflex::Literal("m_iterationN"), OffsetOf(__shadow__::__TDriver, m_iterationN), ::Reflex::PROTECTED)
  .AddDataMember(type_143, Reflex::Literal("m_isProofCompatible"), OffsetOf(__shadow__::__TDriver, m_isProofCompatible), ::Reflex::PROTECTED)
  .AddDataMember(type_2873, Reflex::Literal("m_collectionName"), OffsetOf(__shadow__::__TDriver, m_collectionName), ::Reflex::PROTECTED)
  .AddDataMember(type_2873, Reflex::Literal("m_collectionRawName"), OffsetOf(__shadow__::__TDriver, m_collectionRawName), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class TDriver -------------------
void __TDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("start"), method_9664, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("startOfData"), method_9665, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("endOfData"), method_9666, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("end"), method_9667, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143, type_14733), Reflex::Literal("process"), method_9668, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("detectorChanged"), method_9669, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17090), Reflex::Literal("getManager"), method_9670, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_17090), Reflex::Literal("setManager"), method_9671, 0, "manager", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13971), Reflex::Literal("getName"), method_9672, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_13971), Reflex::Literal("setName"), method_9673, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("getVerboseLevel"), method_9674, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143), Reflex::Literal("setVerboseLevel"), method_9675, 0, "verboseLevel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("getIterationN"), method_9676, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143), Reflex::Literal("setIterationN"), method_9677, 0, "iterationN", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("isProofCompatible"), method_9678, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143), Reflex::Literal("setIsProofCompatible"), method_9679, 0, "isProofCompatible", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_3354), Reflex::Literal("setCollectionName"), method_9680, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_3354), Reflex::Literal("setCollectionRawName"), method_9681, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("Class"), method_9682, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("Class_Name"), method_9683, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2467), Reflex::Literal("Class_Version"), method_9684, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("Dictionary"), method_9685, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("IsA"), method_9686, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_14710), Reflex::Literal("ShowMembers"), method_9687, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("Streamer"), method_9688, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("StreamerNVirtual"), method_9689, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("DeclFileName"), method_9690, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("ImplFileLine"), method_9691, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("ImplFileName"), method_9692, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("DeclFileLine"), method_9693, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TAnalysis -------------------------------
static  void operator_10257( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TAnalysis*)o)->operator=)(*(const ::TAnalysis*)arg[0]);
  else   (((::TAnalysis*)o)->operator=)(*(const ::TAnalysis*)arg[0]);
}

static void constructor_10258( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TAnalysis(*(const ::TAnalysis*)arg[0]);
  else ::new(mem) ::TAnalysis(*(const ::TAnalysis*)arg[0]);
}

static void constructor_10259( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TAnalysis();
  else ::new(mem) ::TAnalysis();
}

static void destructor_10260(void*, void * o, const std::vector<void*>&, void *) {
(((::TAnalysis*)o)->::TAnalysis::~TAnalysis)();
}
static  void method_10261( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TAnalysis*)o)->getChain)());
  else   (((const ::TAnalysis*)o)->getChain)();
}

static  void method_10262( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TAnalysis*)o)->setChain)((::TChain*)arg[0]);
}

static  void method_10263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TAnalysis*)o)->getManager)());
  else   (((const ::TAnalysis*)o)->getManager)();
}

static  void method_10264( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TAnalysis*)o)->setManager)((::TJobManager*)arg[0]);
}

static  void method_10265( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TAnalysis*)o)->addToInputList)((::TObject*)arg[0]);
}

static  void method_10266( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TAnalysis*)o)->configure)(*(::std::string*)arg[0]);
}

static  void method_10267( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TAnalysis*)o)->addFileToChain)(*(::std::string*)arg[0]);
}

static  void method_10268( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TAnalysis*)o)->run)();
}

static  void method_10269( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TAnalysis*)o)->ParseCommandLine)(*(int*)arg[0],
    (char**)arg[1]);
}

static  void method_10270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TAnalysis*)o)->Class)());
  else   (((::TAnalysis*)o)->Class)();
}

static  void method_10271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TAnalysis*)o)->Class_Name)());
  else   (((::TAnalysis*)o)->Class_Name)();
}

static  void method_10272( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TAnalysis*)o)->Class_Version)());
  else   (((::TAnalysis*)o)->Class_Version)();
}

static  void method_10273( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TAnalysis*)o)->Dictionary)();
}

static  void method_10274( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TAnalysis*)o)->IsA)());
  else   (((const ::TAnalysis*)o)->IsA)();
}

static  void method_10275( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TAnalysis*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_10276( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TAnalysis*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_10277( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TAnalysis*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_10278( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TAnalysis*)o)->DeclFileName)());
  else   (((::TAnalysis*)o)->DeclFileName)();
}

static  void method_10279( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TAnalysis*)o)->ImplFileLine)());
  else   (((::TAnalysis*)o)->ImplFileLine)();
}

static  void method_10280( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TAnalysis*)o)->ImplFileName)());
  else   (((::TAnalysis*)o)->ImplFileName)();
}

static  void method_10281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TAnalysis*)o)->DeclFileLine)());
  else   (((::TAnalysis*)o)->DeclFileLine)();
}

static void method_newdel_2654( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TAnalysis >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TAnalysis >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TAnalysis >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TAnalysis >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TAnalysis >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TAnalysis,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TAnalysis -------------------------------
void __TAnalysis_db_datamem(Reflex::Class*);
void __TAnalysis_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TAnalysis_datamem_bld(&__TAnalysis_db_datamem);
Reflex::GenreflexMemberBuilder __TAnalysis_funcmem_bld(&__TAnalysis_db_funcmem);
void __TAnalysis_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TAnalysis"), typeid(::TAnalysis), sizeof(::TAnalysis), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TAnalysis::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2231, ::Reflex::BaseOffset< ::TAnalysis, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17133, type_17134), Reflex::Literal("operator="), operator_10257, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17134), Reflex::Literal("TAnalysis"), constructor_10258, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TAnalysis"), constructor_10259, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TAnalysis"), destructor_10260, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2654, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TAnalysis_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TAnalysis_funcmem_bld);
}

//------Delayed data member builder for class TAnalysis -------------------
void __TAnalysis_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17090, Reflex::Literal("m_manager"), OffsetOf(__shadow__::__TAnalysis, m_manager), ::Reflex::PRIVATE)
  .AddDataMember(type_17130, Reflex::Literal("m_chain"), OffsetOf(__shadow__::__TAnalysis, m_chain), ::Reflex::PRIVATE)
  .AddDataMember(type_17131, Reflex::Literal("m_proof"), OffsetOf(__shadow__::__TAnalysis, m_proof), ::Reflex::PRIVATE)
  .AddDataMember(type_2873, Reflex::Literal("m_steeringName"), OffsetOf(__shadow__::__TAnalysis, m_steeringName), ::Reflex::PRIVATE)
  .AddDataMember(type_2873, Reflex::Literal("m_detName"), OffsetOf(__shadow__::__TAnalysis, m_detName), ::Reflex::PRIVATE)
  .AddDataMember(type_17132, Reflex::Literal("m_fileName"), OffsetOf(__shadow__::__TAnalysis, m_fileName), ::Reflex::PRIVATE)
  .AddDataMember(type_143, Reflex::Literal("isConfigured"), OffsetOf(__shadow__::__TAnalysis, isConfigured), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TAnalysis -------------------
void __TAnalysis_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17130), Reflex::Literal("getChain"), method_10261, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_17130), Reflex::Literal("setChain"), method_10262, 0, "fChain", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17090), Reflex::Literal("getManager"), method_10263, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_17090), Reflex::Literal("setManager"), method_10264, 0, "manager", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_13018), Reflex::Literal("addToInputList"), method_10265, 0, "obj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_2873), Reflex::Literal("configure"), method_10266, 0, "fname", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_2873), Reflex::Literal("addFileToChain"), method_10267, 0, "fname", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("run"), method_10268, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_143, type_4310), Reflex::Literal("ParseCommandLine"), method_10269, 0, "argc;argv", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("Class"), method_10270, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("Class_Name"), method_10271, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2467), Reflex::Literal("Class_Version"), method_10272, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("Dictionary"), method_10273, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_769), Reflex::Literal("IsA"), method_10274, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_14710), Reflex::Literal("ShowMembers"), method_10275, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("Streamer"), method_10276, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_4589), Reflex::Literal("StreamerNVirtual"), method_10277, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("DeclFileName"), method_10278, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("ImplFileLine"), method_10279, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3354), Reflex::Literal("ImplFileName"), method_10280, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_143), Reflex::Literal("DeclFileLine"), method_10281, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<TDriver*,std::allocator<TDriver*> > -------------------------------
static void constructor_11227( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TDriver*>();
  else ::new(mem) ::std::vector<TDriver*>();
}

static void constructor_11228( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TDriver*>(*(const ::std::allocator<TDriver*>*)arg[0]);
  else ::new(mem) ::std::vector<TDriver*>(*(const ::std::allocator<TDriver*>*)arg[0]);
}

static void constructor_11229( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TDriver*>(*(::size_t*)arg[0]);
  else ::new(mem) ::std::vector<TDriver*>(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TDriver*>(*(::size_t*)arg[0],
      *(::TDriver* const*)arg[1]);
  else ::new(mem) ::std::vector<TDriver*>(*(::size_t*)arg[0],
      *(::TDriver* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TDriver*>(*(::size_t*)arg[0],
      *(::TDriver* const*)arg[1],
      *(const ::std::allocator<TDriver*>*)arg[2]);
  else ::new(mem) ::std::vector<TDriver*>(*(::size_t*)arg[0],
      *(::TDriver* const*)arg[1],
      *(const ::std::allocator<TDriver*>*)arg[2]);
  }
}

static void constructor_11230( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TDriver*>(*(const ::std::vector<TDriver*>*)arg[0]);
  else ::new(mem) ::std::vector<TDriver*>(*(const ::std::vector<TDriver*>*)arg[0]);
}

static void destructor_11231(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<TDriver*>*)o)->::std::vector<TDriver*>::~vector)();
}
static  void operator_11232( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TDriver*>*)o)->operator=)(*(const ::std::vector<TDriver*>*)arg[0]);
  else   (((::std::vector<TDriver*>*)o)->operator=)(*(const ::std::vector<TDriver*>*)arg[0]);
}

static  void method_11233( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TDriver*>*)o)->assign)(*(::size_t*)arg[0],
    *(::TDriver* const*)arg[1]);
}

static  void method_11234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >)((((::std::vector<TDriver*>*)o)->begin)());
  else   (((::std::vector<TDriver*>*)o)->begin)();
}

static  void method_11235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TDriver* const*,std::vector<TDriver*> >)((((const ::std::vector<TDriver*>*)o)->begin)());
  else   (((const ::std::vector<TDriver*>*)o)->begin)();
}

static  void method_11236( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >)((((::std::vector<TDriver*>*)o)->end)());
  else   (((::std::vector<TDriver*>*)o)->end)();
}

static  void method_11237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TDriver* const*,std::vector<TDriver*> >)((((const ::std::vector<TDriver*>*)o)->end)());
  else   (((const ::std::vector<TDriver*>*)o)->end)();
}

static  void method_11242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<TDriver*>*)o)->size)());
  else   (((const ::std::vector<TDriver*>*)o)->size)();
}

static  void method_11243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<TDriver*>*)o)->max_size)());
  else   (((const ::std::vector<TDriver*>*)o)->max_size)();
}

static  void method_11244( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<TDriver*>*)o)->resize)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<TDriver*>*)o)->resize)(*(::size_t*)arg[0],
      (::TDriver*)arg[1]);
  }
}

static  void method_11245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<TDriver*>*)o)->capacity)());
  else   (((const ::std::vector<TDriver*>*)o)->capacity)();
}

static  void method_11246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<TDriver*>*)o)->empty)());
  else   (((const ::std::vector<TDriver*>*)o)->empty)();
}

static  void method_11247( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TDriver*>*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void operator_11248( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TDriver*>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((::std::vector<TDriver*>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void operator_11249( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TDriver*>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((const ::std::vector<TDriver*>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_11251( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TDriver*>*)o)->at)(*(::size_t*)arg[0]);
  else   (((::std::vector<TDriver*>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_11252( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TDriver*>*)o)->at)(*(::size_t*)arg[0]);
  else   (((const ::std::vector<TDriver*>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_11253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TDriver*>*)o)->front)();
  else   (((::std::vector<TDriver*>*)o)->front)();
}

static  void method_11254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TDriver*>*)o)->front)();
  else   (((const ::std::vector<TDriver*>*)o)->front)();
}

static  void method_11255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TDriver*>*)o)->back)();
  else   (((::std::vector<TDriver*>*)o)->back)();
}

static  void method_11256( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TDriver*>*)o)->back)();
  else   (((const ::std::vector<TDriver*>*)o)->back)();
}

static  void method_11257( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<TDriver*>*)o)->data)());
  else   (((::std::vector<TDriver*>*)o)->data)();
}

static  void method_11258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<TDriver*>*)o)->data)());
  else   (((const ::std::vector<TDriver*>*)o)->data)();
}

static  void method_11259( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TDriver*>*)o)->push_back)(*(::TDriver* const*)arg[0]);
}

static  void method_11260( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TDriver*>*)o)->pop_back)();
}

static  void method_11261( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >)((((::std::vector<TDriver*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >*)arg[0],
    *(::TDriver* const*)arg[1]));
  else   (((::std::vector<TDriver*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >*)arg[0],
    *(::TDriver* const*)arg[1]);
}

static  void method_11262( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TDriver*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >*)arg[0],
    *(::size_t*)arg[1],
    *(::TDriver* const*)arg[2]);
}

static  void method_11263( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >)((((::std::vector<TDriver*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >*)arg[0]));
  else   (((::std::vector<TDriver*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >*)arg[0]);
}

static  void method_11264( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >)((((::std::vector<TDriver*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >*)arg[1]));
  else   (((::std::vector<TDriver*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >*)arg[1]);
}

static  void method_11265( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TDriver*>*)o)->swap)(*(::std::vector<TDriver*>*)arg[0]);
}

static  void method_11266( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TDriver*>*)o)->clear)();
}

static void method_newdel_2830( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<TDriver*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<TDriver*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<TDriver*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<TDriver*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<TDriver*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x26( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TDriver*,std::allocator<TDriver*> >")), ::Reflex::BaseOffset< ::std::vector<TDriver*>,::std::_Vector_base<TDriver*,std::allocator<TDriver*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<TDriver*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<TDriver*> >::Generate();
}

//------Dictionary for class vector<TDriver*,std::allocator<TDriver*> > -------------------------------
void __std__vector_TDriverp__db_datamem(Reflex::Class*);
void __std__vector_TDriverp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_TDriverp__datamem_bld(&__std__vector_TDriverp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_TDriverp__funcmem_bld(&__std__vector_TDriverp__db_funcmem);
void __std__vector_TDriverp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<TDriver*>"), typeid(::std::vector<TDriver*>), sizeof(::std::vector<TDriver*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2789, ::Reflex::BaseOffset< ::std::vector<TDriver*>, ::std::_Vector_base<TDriver*,std::allocator<TDriver*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_8546, Reflex::Literal("std::vector<TDriver*>::_Alloc_value_type"))
  .AddTypedef(type_2789, Reflex::Literal("std::vector<TDriver*>::_Base"))
  .AddTypedef(type_3144, Reflex::Literal("std::vector<TDriver*>::_Tp_alloc_type"))
  .AddTypedef(type_8546, Reflex::Literal("std::vector<TDriver*>::value_type"))
  .AddTypedef(type_11212, Reflex::Literal("std::vector<TDriver*>::pointer"))
  .AddTypedef(type_11214, Reflex::Literal("std::vector<TDriver*>::const_pointer"))
  .AddTypedef(type_11216, Reflex::Literal("std::vector<TDriver*>::reference"))
  .AddTypedef(type_11218, Reflex::Literal("std::vector<TDriver*>::const_reference"))
  .AddTypedef(type_7939, Reflex::Literal("std::vector<TDriver*>::iterator"))
  .AddTypedef(type_7940, Reflex::Literal("std::vector<TDriver*>::const_iterator"))
  .AddTypedef(type_3209, Reflex::Literal("std::vector<TDriver*>::const_reverse_iterator"))
  .AddTypedef(type_3210, Reflex::Literal("std::vector<TDriver*>::reverse_iterator"))
  .AddTypedef(type_1944, Reflex::Literal("std::vector<TDriver*>::size_type"))
  .AddTypedef(type_740, Reflex::Literal("std::vector<TDriver*>::difference_type"))
  .AddTypedef(type_3144, Reflex::Literal("std::vector<TDriver*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_11227, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17209), Reflex::Literal("vector"), constructor_11228, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1944, type_11218, type_17209), Reflex::Literal("vector"), constructor_11229, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17336), Reflex::Literal("vector"), constructor_11230, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_11231, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2830, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x26, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_TDriverp__funcmem_bld);
}

//------Delayed data member builder for class vector<TDriver*,std::allocator<TDriver*> > -------------------
void __std__vector_TDriverp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<TDriver*,std::allocator<TDriver*> > -------------------
void __std__vector_TDriverp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17337, type_17336), Reflex::Literal("operator="), operator_11232, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_1944, type_11218), Reflex::Literal("assign"), method_11233, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7939), Reflex::Literal("begin"), method_11234, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7940), Reflex::Literal("begin"), method_11235, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7939), Reflex::Literal("end"), method_11236, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7940), Reflex::Literal("end"), method_11237, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1944), Reflex::Literal("size"), method_11242, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1944), Reflex::Literal("max_size"), method_11243, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_1944, type_8546), Reflex::Literal("resize"), method_11244, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1944), Reflex::Literal("capacity"), method_11245, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_649), Reflex::Literal("empty"), method_11246, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_1944), Reflex::Literal("reserve"), method_11247, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11216, type_1944), Reflex::Literal("operator[]"), operator_11248, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11218, type_1944), Reflex::Literal("operator[]"), operator_11249, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11216, type_1944), Reflex::Literal("at"), method_11251, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11218, type_1944), Reflex::Literal("at"), method_11252, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11216), Reflex::Literal("front"), method_11253, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11218), Reflex::Literal("front"), method_11254, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11216), Reflex::Literal("back"), method_11255, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11218), Reflex::Literal("back"), method_11256, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11212), Reflex::Literal("data"), method_11257, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11214), Reflex::Literal("data"), method_11258, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_11218), Reflex::Literal("push_back"), method_11259, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("pop_back"), method_11260, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7939, type_7939, type_11218), Reflex::Literal("insert"), method_11261, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_7939, type_1944, type_11218), Reflex::Literal("insert"), method_11262, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7939, type_7939), Reflex::Literal("erase"), method_11263, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7939, type_7939, type_7939), Reflex::Literal("erase"), method_11264, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188, type_17337), Reflex::Literal("swap"), method_11265, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1188), Reflex::Literal("clear"), method_11266, 0, 0, ::Reflex::PUBLIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __TChargeAnalysisDriver_dict(); 
      __TLikelihoodReconDriver_dict(); 
      __TReconInput_dict(); 
      __TEventMarkerDriver_dict(); 
      __TRootSaveDriver_dict(); 
      __TMatrixWriterDriver_dict(); 
      __TJobManager_dict(); 
      __TMatrixInterpreterDriver_dict(); 
      __TMatrixReconDriver_dict(); 
      __TDriver_dict(); 
      __TAnalysis_dict(); 
      __std__vector_TDriverp__dict(); 
    }
    ~Dictionaries() {
      type_100.Unload(); // class TChargeAnalysisDriver 
      type_220.Unload(); // class TLikelihoodReconDriver 
      type_516.Unload(); // class TReconInput 
      type_576.Unload(); // class TEventMarkerDriver 
      type_1120.Unload(); // class TRootSaveDriver 
      type_1203.Unload(); // class TMatrixWriterDriver 
      type_1337.Unload(); // class TJobManager 
      type_1428.Unload(); // class TMatrixInterpreterDriver 
      type_2102.Unload(); // class TMatrixReconDriver 
      type_2537.Unload(); // class TDriver 
      type_2654.Unload(); // class TAnalysis 
      type_2830.Unload(); // class std::vector<TDriver*> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
