// Generated at Wed Sep  2 18:54:06 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/usr/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/usr/bin/c++"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic "
  GCCXML_EXECUTABLE="/usr/bin/gccxml_cc1plus"
  GCCXML_CPP="/usr/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__FLT_MIN__='1.17549435e-38F' -D__CHAR_BIT__='8' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='4.9406564584124654e-324' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__LP64__='1' -D__GNUC_PATCHLEVEL__='7' -D__DEC64_MAX_EXP__='385' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__unix='1' -D__LDBL_MAX_EXP__='16384' -D__linux__='1' -D__SCHAR_MAX__='127' -D__DBL_DIG__='15' -D_FORTIFY_SOURCE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209290e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__SIZEOF_LONG__='8' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='1.7976931348623157e+308' -D__DBL_HAS_INFINITY__='1' -D__DEC32_MIN_EXP__='(-94)' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__DBL_MIN__='2.2250738585072014e-308' -D__FLT_MIN_10_EXP__='(-37)' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__DBL_HAS_DENORM__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.4.7 20120313 (Red Hat 4.4.7-16)"' -D__DEC64_EPSILON__='1E-15DD' -D__DEC128_MIN_EXP__='(-6142)' -Dunix='1' -D__SIZE_TYPE__='long unsigned int' -D__ELF__='1' -D__FLT_RADIX__='2' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__GNUC_RH_RELEASE__='16' -D__k8='1' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__DEC64_MANT_DIG__='16' -D__DEC32_MAX_EXP__='97' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__k8__='1' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__DEC64_MIN_EXP__='(-382)' -D__FLT_DIG__='6' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__FLT_MAX_EXP__='128' -D__DBL_MANT_DIG__='53' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__SSP__='1' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='2.2204460492503131e-16' -D_LP64='1' -D__SIZEOF_WCHAR_T__='4' -D__DEC_EVAL_METHOD__='2' -D__INTMAX_MAX__='9223372036854775807L' -D__FLT_DENORM_MIN__='1.40129846e-45F' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282347e+38F' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='4' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__GNUC_GNU_INLINE__='1' -D_GNU_SOURCE='1' -iwrapper"/usr/share/gccxml-0.9/GCC/4.4" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/backward" -isystem"/usr/local/include" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/usr/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.4.7 20120313 (Red Hat 4.4.7-16)
Copyright (C) 2010 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/project/Gruppo3/fiber5/celentano/OptoTracker/packages/ReconstructionNew/include/ReconstructionNewClasses.hh"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::Type type_49 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_42 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_926 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_962 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_279 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_142 = ::Reflex::TypeBuilder(Reflex::Literal("TList"));
  ::Reflex::Type type_889 = ::Reflex::TypeBuilder(Reflex::Literal("TClass"));
  ::Reflex::Type type_1856 = ::Reflex::TypeBuilder(Reflex::Literal("TTree"));
  ::Reflex::Type type_991 = ::Reflex::TypeBuilder(Reflex::Literal("TObject"));
  ::Reflex::Type type_1857 = ::Reflex::TypeBuilder(Reflex::Literal("TDriver"));
  ::Reflex::Type type_2161 = ::Reflex::TypeBuilder(Reflex::Literal("TBuffer"));
  ::Reflex::Type type_1271 = ::Reflex::TypeBuilder(Reflex::Literal("TBranch"));
  ::Reflex::Type type_620 = ::Reflex::TypeBuilder(Reflex::Literal("TSelector"));
  ::Reflex::Type type_843 = ::Reflex::TypeBuilder(Reflex::Literal("long long"));
  ::Reflex::Type type_612 = ::Reflex::TypeBuilder(Reflex::Literal("TMemberInspector"));
  ::Reflex::Type type_2183 = ::Reflex::TypeBuilder(Reflex::Literal("TOptoJobManager"));
  ::Reflex::Type type_2303 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<OpNoviceDigi*>"));
  ::Reflex::Type type_2304 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<OpNoviceDetectorHit*>"));
  ::Reflex::Type type_8383 = ::Reflex::ReferenceBuilder(type_1857);
  ::Reflex::Type type_1857c = ::Reflex::ConstBuilder(type_1857);
  ::Reflex::Type type_8384 = ::Reflex::ReferenceBuilder(type_1857c);
  ::Reflex::Type type_831 = ::Reflex::PointerBuilder(type_889);
  ::Reflex::Type type_926c = ::Reflex::ConstBuilder(type_926);
  ::Reflex::Type type_2643 = ::Reflex::PointerBuilder(type_926c);
  ::Reflex::Type type_1682 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Version_t"), type_279);
  ::Reflex::Type type_7632 = ::Reflex::ReferenceBuilder(type_612);
  ::Reflex::Type type_4793 = ::Reflex::ReferenceBuilder(type_2161);
  ::Reflex::Type type_4690 = ::Reflex::PointerBuilder(type_1856);
  ::Reflex::Type type_4689 = ::Reflex::PointerBuilder(type_1271);
  ::Reflex::Type type_8437 = ::Reflex::PointerBuilder(type_2304);
  ::Reflex::Type type_8438 = ::Reflex::PointerBuilder(type_2303);
  ::Reflex::Type type_1337 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Int_t"), type_49);
  ::Reflex::Type type_844 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Long64_t"), type_843);
  ::Reflex::Type type_7452 = ::Reflex::PointerBuilder(type_991);
  ::Reflex::Type type_7952 = ::Reflex::PointerBuilder(type_142);
  ::Reflex::Type type_963 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Bool_t"), type_962);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __TDriver
#undef __TDriver
#endif
class __TDriver : public ::TObject {
  public:
  __TDriver();
  virtual ~__TDriver() throw();
};
#ifdef __TOptoJobManager
#undef __TOptoJobManager
#endif
class __TOptoJobManager : public ::TSelector {
  public:
  __TOptoJobManager();
  virtual ~__TOptoJobManager() throw();
  virtual ::Int_t GetEntry(long long, int) throw();
  virtual void SetInputList(TList*) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void Init(TTree*) throw();
  virtual ::Bool_t Process(long long) throw();
  virtual const char* ClassName() const throw();
  virtual void SetOption(char const*) throw();
  virtual ::Bool_t Notify() throw();
  virtual void SlaveTerminate() throw();
  virtual void SetObject(TObject*) throw();
  virtual void Begin(TTree*) throw();
  virtual void Terminate() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TList* GetOutputList() const throw();
  virtual ::Int_t Version() const throw();
  virtual void SlaveBegin(TTree*) throw();
  void* fTree;
  void* b_MCraw;
  void* m_MCraw;
  void* b_MCdigi;
  void* m_MCdigi;
};
}


#endif // __CINT__
namespace {
} // unnamed namespace

#ifndef G__DICTIONARY
# define G__DICTIONARY
#endif
#include "TClass.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "RtypesImp.h"
#include "TIsAProxy.h"
atomic_TClass_ptr TDriver::fgIsA(0);
TClass* ::TDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TDriver");
   }
   return fgIsA;
}
const char * ::TDriver::Class_Name() {return "TDriver";}
void ::TDriver::Dictionary() {}
const char *::TDriver::ImplFileName() {return "";}
int ::TDriver::ImplFileLine() {return 1;}
void ::TDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   TObject::ShowMembers(R__insp);
}
void ::TDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TDriver::Class(),this);
   }
}

atomic_TClass_ptr TOptoJobManager::fgIsA(0);
TClass* ::TOptoJobManager::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TOptoJobManager");
   }
   return fgIsA;
}
const char * ::TOptoJobManager::Class_Name() {return "TOptoJobManager";}
void ::TOptoJobManager::Dictionary() {}
const char *::TOptoJobManager::ImplFileName() {return "";}
int ::TOptoJobManager::ImplFileLine() {return 1;}
void ::TOptoJobManager::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TOptoJobManager::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*fTree", &fTree);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*b_MCraw", &b_MCraw);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_MCraw", &m_MCraw);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*b_MCdigi", &b_MCdigi);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_MCdigi", &m_MCdigi);
   TSelector::ShowMembers(R__insp);
}
void ::TOptoJobManager::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TOptoJobManager::Class(),this);
   } else {
      b.WriteClassBuffer(::TOptoJobManager::Class(),this);
   }
}


namespace {
//------Stub functions for class TDriver -------------------------------
static  void operator_5376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TDriver*)o)->operator=)(*(const ::TDriver*)arg[0]);
  else   (((::TDriver*)o)->operator=)(*(const ::TDriver*)arg[0]);
}

static void constructor_5377( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TDriver(*(const ::TDriver*)arg[0]);
  else ::new(mem) ::TDriver(*(const ::TDriver*)arg[0]);
}

static void constructor_5378( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TDriver();
  else ::new(mem) ::TDriver();
}

static void destructor_5379(void*, void * o, const std::vector<void*>&, void *) {
(((::TDriver*)o)->::TDriver::~TDriver)();
}
static  void method_5380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDriver*)o)->Class)());
  else   (((::TDriver*)o)->Class)();
}

static  void method_5381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDriver*)o)->Class_Name)());
  else   (((::TDriver*)o)->Class_Name)();
}

static  void method_5382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TDriver*)o)->Class_Version)());
  else   (((::TDriver*)o)->Class_Version)();
}

static  void method_5383( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TDriver*)o)->Dictionary)();
}

static  void method_5384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TDriver*)o)->IsA)());
  else   (((const ::TDriver*)o)->IsA)();
}

static  void method_5385( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5386( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5387( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDriver*)o)->DeclFileName)());
  else   (((::TDriver*)o)->DeclFileName)();
}

static  void method_5389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->ImplFileLine)());
  else   (((::TDriver*)o)->ImplFileLine)();
}

static  void method_5390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDriver*)o)->ImplFileName)());
  else   (((::TDriver*)o)->ImplFileName)();
}

static  void method_5391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->DeclFileLine)());
  else   (((::TDriver*)o)->DeclFileLine)();
}

static void method_newdel_1857( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TDriver,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TDriver -------------------------------
void __TDriver_db_datamem(Reflex::Class*);
void __TDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TDriver_datamem_bld(&__TDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TDriver_funcmem_bld(&__TDriver_db_funcmem);
void __TDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TDriver"), typeid(::TDriver), sizeof(::TDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_991, ::Reflex::BaseOffset< ::TDriver, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8383, type_8384), Reflex::Literal("operator="), operator_5376, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8384), Reflex::Literal("TDriver"), constructor_5377, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TDriver"), constructor_5378, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TDriver"), destructor_5379, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1857, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__TDriver_funcmem_bld);
}

//------Delayed data member builder for class TDriver -------------------
void __TDriver_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class TDriver -------------------
void __TDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_831), Reflex::Literal("Class"), method_5380, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2643), Reflex::Literal("Class_Name"), method_5381, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1682), Reflex::Literal("Class_Version"), method_5382, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_42), Reflex::Literal("Dictionary"), method_5383, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_831), Reflex::Literal("IsA"), method_5384, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_42, type_7632), Reflex::Literal("ShowMembers"), method_5385, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_42, type_4793), Reflex::Literal("Streamer"), method_5386, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_42, type_4793), Reflex::Literal("StreamerNVirtual"), method_5387, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2643), Reflex::Literal("DeclFileName"), method_5388, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_49), Reflex::Literal("ImplFileLine"), method_5389, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2643), Reflex::Literal("ImplFileName"), method_5390, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_49), Reflex::Literal("DeclFileLine"), method_5391, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TOptoJobManager -------------------------------
static void constructor_5765( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TOptoJobManager();
  else ::new(mem) ::TOptoJobManager();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TOptoJobManager((::TTree*)arg[0]);
  else ::new(mem) ::TOptoJobManager((::TTree*)arg[0]);
  }
}

static void destructor_5766(void*, void * o, const std::vector<void*>&, void *) {
(((::TOptoJobManager*)o)->::TOptoJobManager::~TOptoJobManager)();
}
static  void method_5767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::TOptoJobManager*)o)->Version)());
  else   (((const ::TOptoJobManager*)o)->Version)();
}

static  void method_5768( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->Begin)((::TTree*)arg[0]);
}

static  void method_5769( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->SlaveBegin)((::TTree*)arg[0]);
}

static  void method_5770( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Int_t)((((::TOptoJobManager*)o)->GetEntry)(*(::Long64_t*)arg[0]));
    else     (((::TOptoJobManager*)o)->GetEntry)(*(::Long64_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Int_t)((((::TOptoJobManager*)o)->GetEntry)(*(::Long64_t*)arg[0],
      *(::Int_t*)arg[1]));
    else     (((::TOptoJobManager*)o)->GetEntry)(*(::Long64_t*)arg[0],
      *(::Int_t*)arg[1]);
  }
}

static  void method_5771( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->SetOption)((const char*)arg[0]);
}

static  void method_5772( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->SetObject)((::TObject*)arg[0]);
}

static  void method_5773( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->SetInputList)((::TList*)arg[0]);
}

static  void method_5774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TOptoJobManager*)o)->GetOutputList)());
  else   (((const ::TOptoJobManager*)o)->GetOutputList)();
}

static  void method_5775( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TOptoJobManager*)o)->SlaveTerminate)();
}

static  void method_5776( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TOptoJobManager*)o)->Terminate)();
}

static  void method_5777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((::TOptoJobManager*)o)->Notify)());
  else   (((::TOptoJobManager*)o)->Notify)();
}

static  void method_5778( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->Init)((::TTree*)arg[0]);
}

static  void method_5779( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((::TOptoJobManager*)o)->Process)(*(::Long64_t*)arg[0]));
  else   (((::TOptoJobManager*)o)->Process)(*(::Long64_t*)arg[0]);
}

static  void method_5780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TOptoJobManager*)o)->ClassName)());
  else   (((const ::TOptoJobManager*)o)->ClassName)();
}

static  void method_5781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TOptoJobManager*)o)->Class)());
  else   (((::TOptoJobManager*)o)->Class)();
}

static  void method_5782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TOptoJobManager*)o)->Class_Name)());
  else   (((::TOptoJobManager*)o)->Class_Name)();
}

static  void method_5783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TOptoJobManager*)o)->Class_Version)());
  else   (((::TOptoJobManager*)o)->Class_Version)();
}

static  void method_5784( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TOptoJobManager*)o)->Dictionary)();
}

static  void method_5785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TOptoJobManager*)o)->IsA)());
  else   (((const ::TOptoJobManager*)o)->IsA)();
}

static  void method_5786( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5787( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5788( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TOptoJobManager*)o)->DeclFileName)());
  else   (((::TOptoJobManager*)o)->DeclFileName)();
}

static  void method_5790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TOptoJobManager*)o)->ImplFileLine)());
  else   (((::TOptoJobManager*)o)->ImplFileLine)();
}

static  void method_5791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TOptoJobManager*)o)->ImplFileName)());
  else   (((::TOptoJobManager*)o)->ImplFileName)();
}

static  void method_5792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TOptoJobManager*)o)->DeclFileLine)());
  else   (((::TOptoJobManager*)o)->DeclFileLine)();
}

static void constructor_x2( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TOptoJobManager();
  else ::new(mem) ::TOptoJobManager();
}

static void method_newdel_2183( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TOptoJobManager >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TOptoJobManager >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TOptoJobManager >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TOptoJobManager >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TOptoJobManager >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TSelector")), ::Reflex::BaseOffset< ::TOptoJobManager,::TSelector >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TOptoJobManager,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TOptoJobManager -------------------------------
void __TOptoJobManager_db_datamem(Reflex::Class*);
void __TOptoJobManager_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TOptoJobManager_datamem_bld(&__TOptoJobManager_db_datamem);
Reflex::GenreflexMemberBuilder __TOptoJobManager_funcmem_bld(&__TOptoJobManager_db_funcmem);
void __TOptoJobManager_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TOptoJobManager"), typeid(::TOptoJobManager), sizeof(::TOptoJobManager), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TOptoJobManager::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_620, ::Reflex::BaseOffset< ::TOptoJobManager, ::TSelector >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4690), Reflex::Literal("TOptoJobManager"), constructor_5765, 0, "t=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TOptoJobManager"), destructor_5766, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TOptoJobManager"), constructor_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2183, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TOptoJobManager_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TOptoJobManager_funcmem_bld);
}

//------Delayed data member builder for class TOptoJobManager -------------------
void __TOptoJobManager_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4690, Reflex::Literal("fTree"), OffsetOf(__shadow__::__TOptoJobManager, fTree), ::Reflex::PRIVATE)
  .AddDataMember(type_4689, Reflex::Literal("b_MCraw"), OffsetOf(__shadow__::__TOptoJobManager, b_MCraw), ::Reflex::PRIVATE)
  .AddDataMember(type_8437, Reflex::Literal("m_MCraw"), OffsetOf(__shadow__::__TOptoJobManager, m_MCraw), ::Reflex::PRIVATE)
  .AddDataMember(type_4689, Reflex::Literal("b_MCdigi"), OffsetOf(__shadow__::__TOptoJobManager, b_MCdigi), ::Reflex::PRIVATE)
  .AddDataMember(type_8438, Reflex::Literal("m_MCdigi"), OffsetOf(__shadow__::__TOptoJobManager, m_MCdigi), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TOptoJobManager -------------------
void __TOptoJobManager_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1337), Reflex::Literal("Version"), method_5767, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_42, type_4690), Reflex::Literal("Begin"), method_5768, 0, "tree", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_42, type_4690), Reflex::Literal("SlaveBegin"), method_5769, 0, "tree", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1337, type_844, type_1337), Reflex::Literal("GetEntry"), method_5770, 0, "entry;getall=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_42, type_2643), Reflex::Literal("SetOption"), method_5771, 0, "option", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_42, type_7452), Reflex::Literal("SetObject"), method_5772, 0, "obj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_42, type_7952), Reflex::Literal("SetInputList"), method_5773, 0, "input", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7952), Reflex::Literal("GetOutputList"), method_5774, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_42), Reflex::Literal("SlaveTerminate"), method_5775, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_42), Reflex::Literal("Terminate"), method_5776, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_963), Reflex::Literal("Notify"), method_5777, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_42, type_4690), Reflex::Literal("Init"), method_5778, 0, "tree", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_963, type_844), Reflex::Literal("Process"), method_5779, 0, "entry", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2643), Reflex::Literal("ClassName"), method_5780, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_831), Reflex::Literal("Class"), method_5781, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2643), Reflex::Literal("Class_Name"), method_5782, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1682), Reflex::Literal("Class_Version"), method_5783, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_42), Reflex::Literal("Dictionary"), method_5784, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_831), Reflex::Literal("IsA"), method_5785, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_42, type_7632), Reflex::Literal("ShowMembers"), method_5786, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_42, type_4793), Reflex::Literal("Streamer"), method_5787, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_42, type_4793), Reflex::Literal("StreamerNVirtual"), method_5788, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2643), Reflex::Literal("DeclFileName"), method_5789, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_49), Reflex::Literal("ImplFileLine"), method_5790, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2643), Reflex::Literal("ImplFileName"), method_5791, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_49), Reflex::Literal("DeclFileLine"), method_5792, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __TDriver_dict(); 
      __TOptoJobManager_dict(); 
    }
    ~Dictionaries() {
      type_1857.Unload(); // class TDriver 
      type_2183.Unload(); // class TOptoJobManager 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
