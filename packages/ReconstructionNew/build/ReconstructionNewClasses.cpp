// Generated at Mon Sep  7 09:54:27 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/usr/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/usr/bin/c++"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic "
  GCCXML_EXECUTABLE="/usr/bin/gccxml_cc1plus"
  GCCXML_CPP="/usr/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__FLT_MIN__='1.17549435e-38F' -D__CHAR_BIT__='8' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='4.9406564584124654e-324' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__LP64__='1' -D__GNUC_PATCHLEVEL__='7' -D__DEC64_MAX_EXP__='385' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__unix='1' -D__LDBL_MAX_EXP__='16384' -D__linux__='1' -D__SCHAR_MAX__='127' -D__DBL_DIG__='15' -D_FORTIFY_SOURCE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209290e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__SIZEOF_LONG__='8' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='1.7976931348623157e+308' -D__DBL_HAS_INFINITY__='1' -D__DEC32_MIN_EXP__='(-94)' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__DBL_MIN__='2.2250738585072014e-308' -D__FLT_MIN_10_EXP__='(-37)' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__DBL_HAS_DENORM__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.4.7 20120313 (Red Hat 4.4.7-16)"' -D__DEC64_EPSILON__='1E-15DD' -D__DEC128_MIN_EXP__='(-6142)' -Dunix='1' -D__SIZE_TYPE__='long unsigned int' -D__ELF__='1' -D__FLT_RADIX__='2' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__GNUC_RH_RELEASE__='16' -D__k8='1' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__DEC64_MANT_DIG__='16' -D__DEC32_MAX_EXP__='97' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__k8__='1' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__DEC64_MIN_EXP__='(-382)' -D__FLT_DIG__='6' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__FLT_MAX_EXP__='128' -D__DBL_MANT_DIG__='53' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__SSP__='1' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='2.2204460492503131e-16' -D_LP64='1' -D__SIZEOF_WCHAR_T__='4' -D__DEC_EVAL_METHOD__='2' -D__INTMAX_MAX__='9223372036854775807L' -D__FLT_DENORM_MIN__='1.40129846e-45F' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282347e+38F' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='4' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__GNUC_GNU_INLINE__='1' -D_GNU_SOURCE='1' -iwrapper"/usr/share/gccxml-0.9/GCC/4.4" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/backward" -isystem"/usr/local/include" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/usr/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.4.7 20120313 (Red Hat 4.4.7-16)
Copyright (C) 2010 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/project/Gruppo3/fiber5/celentano/OptoTracker/packages/ReconstructionNew/include/ReconstructionNewClasses.hh"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::Type type_47 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_41 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_931 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_61 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_967 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_143 = ::Reflex::TypeBuilder(Reflex::Literal("TList"));
  ::Reflex::Type type_897 = ::Reflex::TypeBuilder(Reflex::Literal("TClass"));
  ::Reflex::Type type_1857 = ::Reflex::TypeBuilder(Reflex::Literal("TTree"));
  ::Reflex::Type type_358 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_994 = ::Reflex::TypeBuilder(Reflex::Literal("TObject"));
  ::Reflex::Type type_648 = ::Reflex::TypeBuilder(Reflex::Literal("TBuffer"));
  ::Reflex::Type type_1439 = ::Reflex::TypeBuilder(Reflex::Literal("TEvent"));
  ::Reflex::Type type_1858 = ::Reflex::TypeBuilder(Reflex::Literal("TDriver"));
  ::Reflex::Type type_1275 = ::Reflex::TypeBuilder(Reflex::Literal("TBranch"));
  ::Reflex::Type type_622 = ::Reflex::TypeBuilder(Reflex::Literal("TSelector"));
  ::Reflex::Type type_849 = ::Reflex::TypeBuilder(Reflex::Literal("long long"));
  ::Reflex::Type type_614 = ::Reflex::TypeBuilder(Reflex::Literal("TMemberInspector"));
  ::Reflex::Type type_2188 = ::Reflex::TypeBuilder(Reflex::Literal("TOptoJobManager"));
  ::Reflex::Type type_8638 = ::Reflex::ReferenceBuilder(type_1858);
  ::Reflex::Type type_1858c = ::Reflex::ConstBuilder(type_1858);
  ::Reflex::Type type_8639 = ::Reflex::ReferenceBuilder(type_1858c);
  ::Reflex::Type type_836 = ::Reflex::PointerBuilder(type_897);
  ::Reflex::Type type_931c = ::Reflex::ConstBuilder(type_931);
  ::Reflex::Type type_2657 = ::Reflex::PointerBuilder(type_931c);
  ::Reflex::Type type_1687 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Version_t"), type_61);
  ::Reflex::Type type_7830 = ::Reflex::ReferenceBuilder(type_614);
  ::Reflex::Type type_5139 = ::Reflex::ReferenceBuilder(type_648);
  ::Reflex::Type type_5036 = ::Reflex::PointerBuilder(type_1857);
  ::Reflex::Type type_5035 = ::Reflex::PointerBuilder(type_1275);
  ::Reflex::Type type_8649 = ::Reflex::PointerBuilder(type_1439);
  ::Reflex::Type type_1979 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Int_t"), type_47);
  ::Reflex::Type type_850 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Long64_t"), type_849);
  ::Reflex::Type type_7640 = ::Reflex::PointerBuilder(type_994);
  ::Reflex::Type type_8173 = ::Reflex::PointerBuilder(type_143);
  ::Reflex::Type type_968 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Bool_t"), type_967);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __TDriver
#undef __TDriver
#endif
class __TDriver : public ::TObject {
  public:
  __TDriver();
  virtual ~__TDriver() throw();
};
#ifdef __TOptoJobManager
#undef __TOptoJobManager
#endif
class __TOptoJobManager : public ::TSelector {
  public:
  __TOptoJobManager();
  virtual ~__TOptoJobManager() throw();
  virtual ::Int_t GetEntry(long long, int) throw();
  virtual void SetInputList(TList*) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void Init(TTree*) throw();
  virtual ::Bool_t Process(long long) throw();
  virtual const char* ClassName() const throw();
  virtual void SetOption(char const*) throw();
  virtual ::Bool_t Notify() throw();
  virtual void SlaveTerminate() throw();
  virtual void SetObject(TObject*) throw();
  virtual void Begin(TTree*) throw();
  virtual void Terminate() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TList* GetOutputList() const throw();
  virtual ::Int_t Version() const throw();
  virtual void SlaveBegin(TTree*) throw();
  void* fTree;
  void* b_event;
  void* m_event;
  double tmp2;
};
}


#endif // __CINT__
namespace {
} // unnamed namespace

#ifndef G__DICTIONARY
# define G__DICTIONARY
#endif
#include "TClass.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "RtypesImp.h"
#include "TIsAProxy.h"
atomic_TClass_ptr TDriver::fgIsA(0);
TClass* ::TDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TDriver");
   }
   return fgIsA;
}
const char * ::TDriver::Class_Name() {return "TDriver";}
void ::TDriver::Dictionary() {}
const char *::TDriver::ImplFileName() {return "";}
int ::TDriver::ImplFileLine() {return 1;}
void ::TDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   TObject::ShowMembers(R__insp);
}
void ::TDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TDriver::Class(),this);
   }
}

atomic_TClass_ptr TOptoJobManager::fgIsA(0);
TClass* ::TOptoJobManager::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TOptoJobManager");
   }
   return fgIsA;
}
const char * ::TOptoJobManager::Class_Name() {return "TOptoJobManager";}
void ::TOptoJobManager::Dictionary() {}
const char *::TOptoJobManager::ImplFileName() {return "";}
int ::TOptoJobManager::ImplFileLine() {return 1;}
void ::TOptoJobManager::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TOptoJobManager::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*fTree", &fTree);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*b_event", &b_event);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_event", &m_event);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "tmp2", &tmp2);
   TSelector::ShowMembers(R__insp);
}
void ::TOptoJobManager::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TOptoJobManager::Class(),this);
   } else {
      b.WriteClassBuffer(::TOptoJobManager::Class(),this);
   }
}


namespace {
//------Stub functions for class TDriver -------------------------------
static  void operator_5723( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TDriver*)o)->operator=)(*(const ::TDriver*)arg[0]);
  else   (((::TDriver*)o)->operator=)(*(const ::TDriver*)arg[0]);
}

static void constructor_5724( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TDriver(*(const ::TDriver*)arg[0]);
  else ::new(mem) ::TDriver(*(const ::TDriver*)arg[0]);
}

static void constructor_5725( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TDriver();
  else ::new(mem) ::TDriver();
}

static void destructor_5726(void*, void * o, const std::vector<void*>&, void *) {
(((::TDriver*)o)->::TDriver::~TDriver)();
}
static  void method_5727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDriver*)o)->Class)());
  else   (((::TDriver*)o)->Class)();
}

static  void method_5728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDriver*)o)->Class_Name)());
  else   (((::TDriver*)o)->Class_Name)();
}

static  void method_5729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TDriver*)o)->Class_Version)());
  else   (((::TDriver*)o)->Class_Version)();
}

static  void method_5730( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TDriver*)o)->Dictionary)();
}

static  void method_5731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TDriver*)o)->IsA)());
  else   (((const ::TDriver*)o)->IsA)();
}

static  void method_5732( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5733( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5734( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDriver*)o)->DeclFileName)());
  else   (((::TDriver*)o)->DeclFileName)();
}

static  void method_5736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->ImplFileLine)());
  else   (((::TDriver*)o)->ImplFileLine)();
}

static  void method_5737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDriver*)o)->ImplFileName)());
  else   (((::TDriver*)o)->ImplFileName)();
}

static  void method_5738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->DeclFileLine)());
  else   (((::TDriver*)o)->DeclFileLine)();
}

static void method_newdel_1858( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TDriver,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TDriver -------------------------------
void __TDriver_db_datamem(Reflex::Class*);
void __TDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TDriver_datamem_bld(&__TDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TDriver_funcmem_bld(&__TDriver_db_funcmem);
void __TDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TDriver"), typeid(::TDriver), sizeof(::TDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_994, ::Reflex::BaseOffset< ::TDriver, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8638, type_8639), Reflex::Literal("operator="), operator_5723, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8639), Reflex::Literal("TDriver"), constructor_5724, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TDriver"), constructor_5725, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TDriver"), destructor_5726, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1858, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__TDriver_funcmem_bld);
}

//------Delayed data member builder for class TDriver -------------------
void __TDriver_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class TDriver -------------------
void __TDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_836), Reflex::Literal("Class"), method_5727, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2657), Reflex::Literal("Class_Name"), method_5728, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1687), Reflex::Literal("Class_Version"), method_5729, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_41), Reflex::Literal("Dictionary"), method_5730, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_836), Reflex::Literal("IsA"), method_5731, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_41, type_7830), Reflex::Literal("ShowMembers"), method_5732, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_41, type_5139), Reflex::Literal("Streamer"), method_5733, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_41, type_5139), Reflex::Literal("StreamerNVirtual"), method_5734, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2657), Reflex::Literal("DeclFileName"), method_5735, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47), Reflex::Literal("ImplFileLine"), method_5736, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2657), Reflex::Literal("ImplFileName"), method_5737, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47), Reflex::Literal("DeclFileLine"), method_5738, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TOptoJobManager -------------------------------
static void constructor_5828( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TOptoJobManager();
  else ::new(mem) ::TOptoJobManager();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TOptoJobManager((::TTree*)arg[0]);
  else ::new(mem) ::TOptoJobManager((::TTree*)arg[0]);
  }
}

static void destructor_5829(void*, void * o, const std::vector<void*>&, void *) {
(((::TOptoJobManager*)o)->::TOptoJobManager::~TOptoJobManager)();
}
static  void method_5830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::TOptoJobManager*)o)->Version)());
  else   (((const ::TOptoJobManager*)o)->Version)();
}

static  void method_5831( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->Begin)((::TTree*)arg[0]);
}

static  void method_5832( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->SlaveBegin)((::TTree*)arg[0]);
}

static  void method_5833( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Int_t)((((::TOptoJobManager*)o)->GetEntry)(*(::Long64_t*)arg[0]));
    else     (((::TOptoJobManager*)o)->GetEntry)(*(::Long64_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Int_t)((((::TOptoJobManager*)o)->GetEntry)(*(::Long64_t*)arg[0],
      *(::Int_t*)arg[1]));
    else     (((::TOptoJobManager*)o)->GetEntry)(*(::Long64_t*)arg[0],
      *(::Int_t*)arg[1]);
  }
}

static  void method_5834( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->SetOption)((const char*)arg[0]);
}

static  void method_5835( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->SetObject)((::TObject*)arg[0]);
}

static  void method_5836( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->SetInputList)((::TList*)arg[0]);
}

static  void method_5837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TOptoJobManager*)o)->GetOutputList)());
  else   (((const ::TOptoJobManager*)o)->GetOutputList)();
}

static  void method_5838( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TOptoJobManager*)o)->SlaveTerminate)();
}

static  void method_5839( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TOptoJobManager*)o)->Terminate)();
}

static  void method_5840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((::TOptoJobManager*)o)->Notify)());
  else   (((::TOptoJobManager*)o)->Notify)();
}

static  void method_5841( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->Init)((::TTree*)arg[0]);
}

static  void method_5842( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((::TOptoJobManager*)o)->Process)(*(::Long64_t*)arg[0]));
  else   (((::TOptoJobManager*)o)->Process)(*(::Long64_t*)arg[0]);
}

static  void method_5843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TOptoJobManager*)o)->ClassName)());
  else   (((const ::TOptoJobManager*)o)->ClassName)();
}

static  void method_5844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::TOptoJobManager*)o)->getTmp2)());
  else   (((::TOptoJobManager*)o)->getTmp2)();
}

static  void method_5845( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->setTmp2)(*(double*)arg[0]);
}

static  void method_5846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TOptoJobManager*)o)->Class)());
  else   (((::TOptoJobManager*)o)->Class)();
}

static  void method_5847( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TOptoJobManager*)o)->Class_Name)());
  else   (((::TOptoJobManager*)o)->Class_Name)();
}

static  void method_5848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TOptoJobManager*)o)->Class_Version)());
  else   (((::TOptoJobManager*)o)->Class_Version)();
}

static  void method_5849( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TOptoJobManager*)o)->Dictionary)();
}

static  void method_5850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TOptoJobManager*)o)->IsA)());
  else   (((const ::TOptoJobManager*)o)->IsA)();
}

static  void method_5851( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5852( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5853( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TOptoJobManager*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TOptoJobManager*)o)->DeclFileName)());
  else   (((::TOptoJobManager*)o)->DeclFileName)();
}

static  void method_5855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TOptoJobManager*)o)->ImplFileLine)());
  else   (((::TOptoJobManager*)o)->ImplFileLine)();
}

static  void method_5856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TOptoJobManager*)o)->ImplFileName)());
  else   (((::TOptoJobManager*)o)->ImplFileName)();
}

static  void method_5857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TOptoJobManager*)o)->DeclFileLine)());
  else   (((::TOptoJobManager*)o)->DeclFileLine)();
}

static void constructor_x2( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TOptoJobManager();
  else ::new(mem) ::TOptoJobManager();
}

static void method_newdel_2188( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TOptoJobManager >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TOptoJobManager >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TOptoJobManager >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TOptoJobManager >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TOptoJobManager >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TSelector")), ::Reflex::BaseOffset< ::TOptoJobManager,::TSelector >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TOptoJobManager,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TOptoJobManager -------------------------------
void __TOptoJobManager_db_datamem(Reflex::Class*);
void __TOptoJobManager_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TOptoJobManager_datamem_bld(&__TOptoJobManager_db_datamem);
Reflex::GenreflexMemberBuilder __TOptoJobManager_funcmem_bld(&__TOptoJobManager_db_funcmem);
void __TOptoJobManager_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TOptoJobManager"), typeid(::TOptoJobManager), sizeof(::TOptoJobManager), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TOptoJobManager::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_622, ::Reflex::BaseOffset< ::TOptoJobManager, ::TSelector >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5036), Reflex::Literal("TOptoJobManager"), constructor_5828, 0, "t=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TOptoJobManager"), destructor_5829, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TOptoJobManager"), constructor_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2188, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TOptoJobManager_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TOptoJobManager_funcmem_bld);
}

//------Delayed data member builder for class TOptoJobManager -------------------
void __TOptoJobManager_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5036, Reflex::Literal("fTree"), OffsetOf(__shadow__::__TOptoJobManager, fTree), ::Reflex::PRIVATE)
  .AddDataMember(type_5035, Reflex::Literal("b_event"), OffsetOf(__shadow__::__TOptoJobManager, b_event), ::Reflex::PRIVATE)
  .AddDataMember(type_8649, Reflex::Literal("m_event"), OffsetOf(__shadow__::__TOptoJobManager, m_event), ::Reflex::PRIVATE)
  .AddDataMember(type_358, Reflex::Literal("tmp2"), OffsetOf(__shadow__::__TOptoJobManager, tmp2), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TOptoJobManager -------------------
void __TOptoJobManager_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1979), Reflex::Literal("Version"), method_5830, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_41, type_5036), Reflex::Literal("Begin"), method_5831, 0, "tree", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_41, type_5036), Reflex::Literal("SlaveBegin"), method_5832, 0, "tree", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1979, type_850, type_1979), Reflex::Literal("GetEntry"), method_5833, 0, "entry;getall=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_41, type_2657), Reflex::Literal("SetOption"), method_5834, 0, "option", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_41, type_7640), Reflex::Literal("SetObject"), method_5835, 0, "obj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_41, type_8173), Reflex::Literal("SetInputList"), method_5836, 0, "input", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8173), Reflex::Literal("GetOutputList"), method_5837, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_41), Reflex::Literal("SlaveTerminate"), method_5838, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_41), Reflex::Literal("Terminate"), method_5839, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968), Reflex::Literal("Notify"), method_5840, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_41, type_5036), Reflex::Literal("Init"), method_5841, 0, "tree", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968, type_850), Reflex::Literal("Process"), method_5842, 0, "entry", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2657), Reflex::Literal("ClassName"), method_5843, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_358), Reflex::Literal("getTmp2"), method_5844, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_41, type_358), Reflex::Literal("setTmp2"), method_5845, 0, "d", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_836), Reflex::Literal("Class"), method_5846, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2657), Reflex::Literal("Class_Name"), method_5847, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1687), Reflex::Literal("Class_Version"), method_5848, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_41), Reflex::Literal("Dictionary"), method_5849, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_836), Reflex::Literal("IsA"), method_5850, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_41, type_7830), Reflex::Literal("ShowMembers"), method_5851, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_41, type_5139), Reflex::Literal("Streamer"), method_5852, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_41, type_5139), Reflex::Literal("StreamerNVirtual"), method_5853, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2657), Reflex::Literal("DeclFileName"), method_5854, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47), Reflex::Literal("ImplFileLine"), method_5855, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2657), Reflex::Literal("ImplFileName"), method_5856, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47), Reflex::Literal("DeclFileLine"), method_5857, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __TDriver_dict(); 
      __TOptoJobManager_dict(); 
    }
    ~Dictionaries() {
      type_1858.Unload(); // class TDriver 
      type_2188.Unload(); // class TOptoJobManager 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
