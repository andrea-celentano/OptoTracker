// Generated at Thu Apr 30 18:39:48 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/usr/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/usr/bin/c++"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic "
  GCCXML_EXECUTABLE="/usr/bin/gccxml_cc1plus"
  GCCXML_CPP="/usr/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__FLT_MIN__='1.17549435e-38F' -D__CHAR_BIT__='8' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='4.9406564584124654e-324' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__LP64__='1' -D__GNUC_PATCHLEVEL__='7' -D__DEC64_MAX_EXP__='385' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__unix='1' -D__LDBL_MAX_EXP__='16384' -D__linux__='1' -D__SCHAR_MAX__='127' -D__DBL_DIG__='15' -D_FORTIFY_SOURCE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209290e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__SIZEOF_LONG__='8' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='1.7976931348623157e+308' -D__DBL_HAS_INFINITY__='1' -D__DEC32_MIN_EXP__='(-94)' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__DBL_MIN__='2.2250738585072014e-308' -D__FLT_MIN_10_EXP__='(-37)' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__DBL_HAS_DENORM__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.4.7 20120313 (Red Hat 4.4.7-11)"' -D__DEC64_EPSILON__='1E-15DD' -D__DEC128_MIN_EXP__='(-6142)' -Dunix='1' -D__SIZE_TYPE__='long unsigned int' -D__ELF__='1' -D__FLT_RADIX__='2' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__GNUC_RH_RELEASE__='11' -D__k8='1' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__DEC64_MANT_DIG__='16' -D__DEC32_MAX_EXP__='97' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__k8__='1' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__DEC64_MIN_EXP__='(-382)' -D__FLT_DIG__='6' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__FLT_MAX_EXP__='128' -D__DBL_MANT_DIG__='53' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__SSP__='1' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='2.2204460492503131e-16' -D_LP64='1' -D__SIZEOF_WCHAR_T__='4' -D__DEC_EVAL_METHOD__='2' -D__INTMAX_MAX__='9223372036854775807L' -D__FLT_DENORM_MIN__='1.40129846e-45F' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282347e+38F' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='4' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__GNUC_GNU_INLINE__='1' -D_GNU_SOURCE='1' -iwrapper"/usr/share/gccxml-0.9/GCC/4.4" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/backward" -isystem"/usr/local/include" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/usr/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.4.7 20120313 (Red Hat 4.4.7-11)
Copyright (C) 2010 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/project/Gruppo3/fiber5/celentano/OptoTracker/sim/OpNovice_bench/include/OpNoviceClasses.hh"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("CLHEP") );
  ::Reflex::Type type_45 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_59 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_136 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_980 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_324 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_390 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_1760 = ::Reflex::TypeBuilder(Reflex::Literal("G4VHit"));
  ::Reflex::Type type_1035 = ::Reflex::TypeBuilder(Reflex::Literal("G4VDigi"));
  ::Reflex::Type type_2223 = ::Reflex::TypeBuilder(Reflex::Literal("G4String"));
  ::Reflex::Type type_486 = ::Reflex::TypeBuilder(Reflex::Literal("OpNoviceDigi"));
  ::Reflex::Type type_82 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_1751 = ::Reflex::TypeBuilder(Reflex::Literal("G4SubString"));
  ::Reflex::Type type_147 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_1659 = ::Reflex::TypeBuilder(Reflex::Literal("OpNovicePMTHit"));
  ::Reflex::Type type_1351 = ::Reflex::TypeBuilder(Reflex::Literal("G4VPhysicalVolume"));
  ::Reflex::Type type_1016 = ::Reflex::TypeBuilder(Reflex::Literal("CLHEP::Hep3Vector"));
  ::Reflex::Type type_2138 = ::Reflex::TypeBuilder(Reflex::Literal("CLHEP::HepRotation"));
  ::Reflex::Type type_2850 = ::Reflex::TypeBuilder(Reflex::Literal("CLHEP::HepAxisAngle"));
  ::Reflex::Type type_2364 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_2493 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<char>"));
  ::Reflex::Type type_4651 = ::Reflex::TypeBuilder(Reflex::Literal("CLHEP::HepEulerAngles"));
  ::Reflex::Type type_2543 = ::Reflex::TypeBuilder(Reflex::Literal("std::char_traits<char>"));
  ::Reflex::Type type_2363 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<G4AttValue>"));
  ::Reflex::Type type_2383 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_5347 = ::Reflex::EnumTypeBuilder(Reflex::Literal("G4String::caseCompare"));
  ::Reflex::Type type_2361 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<OpNoviceDigi*>"));
  ::Reflex::Type type_2568 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<G4String,G4AttDef>"));
  ::Reflex::Type type_2362 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<OpNovicePMTHit*>"));
  ::Reflex::Type type_2485 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<OpNoviceDigi*>"));
  ::Reflex::Type type_2486 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<OpNovicePMTHit*>"));
  ::Reflex::Type type_6559 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>::_Alloc_hider"));
  ::Reflex::Type type_206 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_istream<char,std::char_traits<char> >"));
  ::Reflex::Type type_3314 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >"));
  ::Reflex::Type type_2683 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<OpNoviceDigi*,std::allocator<OpNoviceDigi*> >"));
  ::Reflex::Type type_3317 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >"));
  ::Reflex::Type type_2684 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<OpNovicePMTHit*,std::allocator<OpNovicePMTHit*> >"));
  ::Reflex::Type type_3298 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >"));
  ::Reflex::Type type_3300 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >"));
  ::Reflex::Type type_3299 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<OpNoviceDigi* const*,std::vector<OpNoviceDigi*> >"));
  ::Reflex::Type type_3301 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<OpNovicePMTHit* const*,std::vector<OpNovicePMTHit*> >"));
  ::Reflex::Type type_2607 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,std::basic_string<char> > >"));
  ::Reflex::Type type_2606 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> > >"));
  ::Reflex::Type type_2585 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> > >"));
  ::Reflex::Type type_2587 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> > >"));
  ::Reflex::Type type_2584 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<OpNoviceDigi* const*,std::vector<OpNoviceDigi*> > >"));
  ::Reflex::Type type_2586 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<OpNovicePMTHit* const*,std::vector<OpNovicePMTHit*> > >"));
  ::Reflex::Type type_231 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("G4int"), type_45);
  ::Reflex::Type type_1847 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("G4double"), type_390);
  ::Reflex::Type type_5846 = ::Reflex::PointerBuilder(type_1351);
  ::Reflex::Type type_486c = ::Reflex::ConstBuilder(type_486);
  ::Reflex::Type type_5216 = ::Reflex::ReferenceBuilder(type_486c);
  ::Reflex::Type type_613 = ::Reflex::PointerBuilder(type_136);
  ::Reflex::Type type_1441 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_82);
  ::Reflex::Type type_1016c = ::Reflex::ConstBuilder(type_1016);
  ::Reflex::Type type_9831 = ::Reflex::ReferenceBuilder(type_1016c);
  ::Reflex::Type type_6080 = ::Reflex::ReferenceBuilder(type_390);
  ::Reflex::Type type_9832 = ::Reflex::ReferenceBuilder(type_1016);
  ::Reflex::Type type_2138c = ::Reflex::ConstBuilder(type_2138);
  ::Reflex::Type type_9833 = ::Reflex::ReferenceBuilder(type_2138c);
  ::Reflex::Type type_2850c = ::Reflex::ConstBuilder(type_2850);
  ::Reflex::Type type_9834 = ::Reflex::ReferenceBuilder(type_2850c);
  ::Reflex::Type type_4651c = ::Reflex::ConstBuilder(type_4651);
  ::Reflex::Type type_9835 = ::Reflex::ReferenceBuilder(type_4651c);
  ::Reflex::Type type_9838 = ::Reflex::ReferenceBuilder(type_1035);
  ::Reflex::Type type_1035c = ::Reflex::ConstBuilder(type_1035);
  ::Reflex::Type type_9839 = ::Reflex::ReferenceBuilder(type_1035c);
  ::Reflex::Type type_2568c = ::Reflex::ConstBuilder(type_2568);
  ::Reflex::Type type_9840 = ::Reflex::PointerBuilder(type_2568c);
  ::Reflex::Type type_9841 = ::Reflex::PointerBuilder(type_2363);
  ::Reflex::Type type_1086 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("G4bool"), type_980);
  ::Reflex::Type type_1659c = ::Reflex::ConstBuilder(type_1659);
  ::Reflex::Type type_5272 = ::Reflex::ReferenceBuilder(type_1659c);
  ::Reflex::Type type_10814 = ::Reflex::ReferenceBuilder(type_1760);
  ::Reflex::Type type_1760c = ::Reflex::ConstBuilder(type_1760);
  ::Reflex::Type type_10815 = ::Reflex::ReferenceBuilder(type_1760c);
  ::Reflex::Type type_2396 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2383);
  ::Reflex::Type type_324c = ::Reflex::ConstBuilder(type_324);
  ::Reflex::Type type_2829 = ::Reflex::PointerBuilder(type_324c);
  ::Reflex::Type type_2243 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("str_size"), type_1441);
  ::Reflex::Type type_2223c = ::Reflex::ConstBuilder(type_2223);
  ::Reflex::Type type_9697 = ::Reflex::ReferenceBuilder(type_2223c);
  ::Reflex::Type type_1751c = ::Reflex::ConstBuilder(type_1751);
  ::Reflex::Type type_10811 = ::Reflex::ReferenceBuilder(type_1751c);
  ::Reflex::Type type_2396c = ::Reflex::ConstBuilder(type_2396);
  ::Reflex::Type type_7943 = ::Reflex::ReferenceBuilder(type_2396c);
  ::Reflex::Type type_10813 = ::Reflex::ReferenceBuilder(type_2223);
  ::Reflex::Type type_5926 = ::Reflex::ReferenceBuilder(type_324);
  ::Reflex::Type type_6549 = ::Reflex::ReferenceBuilder(type_324c);
  ::Reflex::Type type_207 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::istream"), type_206);
  ::Reflex::Type type_10176 = ::Reflex::ReferenceBuilder(type_207);
  ::Reflex::Type type_5210 = ::Reflex::PointerBuilder(type_486);
  ::Reflex::Type type_5947 = ::Reflex::PointerBuilder(type_5210);
  ::Reflex::Type type_5210c = ::Reflex::ConstBuilder(type_5210);
  ::Reflex::Type type_5949 = ::Reflex::PointerBuilder(type_5210c);
  ::Reflex::Type type_5951 = ::Reflex::ReferenceBuilder(type_5210);
  ::Reflex::Type type_5953 = ::Reflex::ReferenceBuilder(type_5210c);
  ::Reflex::Type type_1141 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("ptrdiff_t"), type_59);
  ::Reflex::Type type_2485c = ::Reflex::ConstBuilder(type_2485);
  ::Reflex::Type type_10996 = ::Reflex::ReferenceBuilder(type_2485c);
  ::Reflex::Type type_2361c = ::Reflex::ConstBuilder(type_2361);
  ::Reflex::Type type_10997 = ::Reflex::ReferenceBuilder(type_2361c);
  ::Reflex::Type type_10998 = ::Reflex::ReferenceBuilder(type_2361);
  ::Reflex::Type type_5266 = ::Reflex::PointerBuilder(type_1659);
  ::Reflex::Type type_6012 = ::Reflex::PointerBuilder(type_5266);
  ::Reflex::Type type_5266c = ::Reflex::ConstBuilder(type_5266);
  ::Reflex::Type type_6014 = ::Reflex::PointerBuilder(type_5266c);
  ::Reflex::Type type_6016 = ::Reflex::ReferenceBuilder(type_5266);
  ::Reflex::Type type_6018 = ::Reflex::ReferenceBuilder(type_5266c);
  ::Reflex::Type type_2486c = ::Reflex::ConstBuilder(type_2486);
  ::Reflex::Type type_11000 = ::Reflex::ReferenceBuilder(type_2486c);
  ::Reflex::Type type_2362c = ::Reflex::ConstBuilder(type_2362);
  ::Reflex::Type type_11001 = ::Reflex::ReferenceBuilder(type_2362c);
  ::Reflex::Type type_11002 = ::Reflex::ReferenceBuilder(type_2362);
  ::Reflex::Type type_1888 = ::Reflex::PointerBuilder(type_324);
  ::Reflex::Type type_2493c = ::Reflex::ConstBuilder(type_2493);
  ::Reflex::Type type_11071 = ::Reflex::ReferenceBuilder(type_2493c);
  ::Reflex::Type type_2383c = ::Reflex::ConstBuilder(type_2383);
  ::Reflex::Type type_8035 = ::Reflex::ReferenceBuilder(type_2383c);
  ::Reflex::Type type_7950 = ::Reflex::ReferenceBuilder(type_2383);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __OpNoviceDigi
#undef __OpNoviceDigi
#endif
class __OpNoviceDigi : public ::G4VDigi {
  public:
  __OpNoviceDigi();
  virtual ~__OpNoviceDigi() throw();
  ::G4int fPmtNumber;
  ::G4int fNPixels;
  ::G4String fName;
  ::G4double fXmax;
  ::G4double fYmax;
  ::G4int fPhotons;
  ::G4double fFirstTime;
  void* fPhysVolMother;
  void* fPhysVol;
};
#ifdef __CLHEP__Hep3Vector
#undef __CLHEP__Hep3Vector
#endif
class __CLHEP__Hep3Vector {
  public:
  __CLHEP__Hep3Vector();
  double dx;
  double dy;
  double dz;
};
#ifdef __G4VDigi
#undef __G4VDigi
#endif
class __G4VDigi {
  public:
  __G4VDigi();
  virtual ~__G4VDigi() throw();
};
#ifdef __OpNovicePMTHit
#undef __OpNovicePMTHit
#endif
class __OpNovicePMTHit : public ::G4VHit {
  public:
  __OpNovicePMTHit();
  virtual ~__OpNovicePMTHit() throw();
  ::G4int fPmtNumber;
  ::G4int fPhotons;
  ::G4int fNPixels;
  ::G4double fFirstTime;
  ::G4String fName;
  ::std::vector<double> fTime;
  ::std::vector<double> fEnergy;
  ::std::vector<double> fX;
  ::std::vector<double> fY;
  void* fPhysVolMother;
  void* fPhysVol;
  ::G4bool fDrawit;
  ::G4int fDrawScaleMin;
  ::G4int fDrawScaleMax;
};
#ifdef __G4VHit
#undef __G4VHit
#endif
class __G4VHit {
  public:
  __G4VHit();
  virtual ~__G4VHit() throw();
};
#ifdef __G4String
#undef __G4String
#endif
class __G4String : public ::std::basic_string<char> {
  public:
  __G4String();
};
#ifdef __std__vector_OpNoviceDigip_
#undef __std__vector_OpNoviceDigip_
#endif
class __std__vector_OpNoviceDigip_ : protected ::std::_Vector_base<OpNoviceDigi*,std::allocator<OpNoviceDigi*> > {
  public:
  __std__vector_OpNoviceDigip_();
};
#ifdef __std__vector_OpNovicePMTHitp_
#undef __std__vector_OpNovicePMTHitp_
#endif
class __std__vector_OpNovicePMTHitp_ : protected ::std::_Vector_base<OpNovicePMTHit*,std::allocator<OpNovicePMTHit*> > {
  public:
  __std__vector_OpNovicePMTHitp_();
};
#ifdef __std__basic_string_char_
#undef __std__basic_string_char_
#endif
struct __std__basic_string_char_ {
  public:
  __std__basic_string_char_();
#ifdef __std__basic_string_char____Rep_base
#undef __std__basic_string_char____Rep_base
#endif
  struct __std__basic_string_char____Rep_base {
    public:
    __std__basic_string_char____Rep_base();
    ::size_t _M_length;
    ::size_t _M_capacity;
    ::_Atomic_word _M_refcount;
  };
#ifdef __std__basic_string_char____Rep
#undef __std__basic_string_char____Rep
#endif
  struct __std__basic_string_char____Rep :   public __std__basic_string_char____Rep_base   {
    public:
    __std__basic_string_char____Rep();
  };
#ifdef __std__basic_string_char____Alloc_hider
#undef __std__basic_string_char____Alloc_hider
#endif
  struct __std__basic_string_char____Alloc_hider :   public ::std::allocator<char>   {
    public:
    __std__basic_string_char____Alloc_hider();
    void* _M_p;
  };
  __std__basic_string_char____Alloc_hider _M_dataplus;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class OpNoviceDigi -------------------------------
static void constructor_3330( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::OpNoviceDigi();
  else ::new(mem) ::OpNoviceDigi();
}

static void constructor_3331( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::OpNoviceDigi(*(::G4String*)arg[0]);
  else ::new(mem) ::OpNoviceDigi(*(::G4String*)arg[0]);
}

static void destructor_3332(void*, void * o, const std::vector<void*>&, void *) {
(((::OpNoviceDigi*)o)->::OpNoviceDigi::~OpNoviceDigi)();
}
static void constructor_3333( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::OpNoviceDigi(*(const ::OpNoviceDigi*)arg[0]);
  else ::new(mem) ::OpNoviceDigi(*(const ::OpNoviceDigi*)arg[0]);
}

static  void operator_3334( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::OpNoviceDigi*)o)->operator=)(*(const ::OpNoviceDigi*)arg[0]);
  else   (((::OpNoviceDigi*)o)->operator=)(*(const ::OpNoviceDigi*)arg[0]);
}

static  void operator_3335( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::OpNoviceDigi*)o)->operator==)(*(const ::OpNoviceDigi*)arg[0]));
  else   (((const ::OpNoviceDigi*)o)->operator==)(*(const ::OpNoviceDigi*)arg[0]);
}

static  void operator_3336( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDigi*)o)->operator new)(*(::size_t*)arg[0]));
  else   (((::OpNoviceDigi*)o)->operator new)(*(::size_t*)arg[0]);
}

static  void operator_3337( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->operator delete)((void*)arg[0]);
}

static  void method_3338( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNoviceDigi*)o)->Draw)();
}

static  void method_3339( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNoviceDigi*)o)->Print)();
}

static  void method_3340( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetPMTNumber)(*(::G4int*)arg[0]);
}

static  void method_3341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNoviceDigi*)o)->GetPMTNumber)());
  else   (((::OpNoviceDigi*)o)->GetPMTNumber)();
}

static  void method_3342( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetNPixels)(*(::G4int*)arg[0]);
}

static  void method_3343( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNoviceDigi*)o)->GetNPixels)());
  else   (((::OpNoviceDigi*)o)->GetNPixels)();
}

static  void method_3344( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetPhotonsNumber)(*(::G4int*)arg[0]);
}

static  void method_3345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNoviceDigi*)o)->GetPhotonsNumber)());
  else   (((::OpNoviceDigi*)o)->GetPhotonsNumber)();
}

static  void method_3346( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetPMTPhysVol)((::G4VPhysicalVolume*)arg[0]);
}

static  void method_3347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDigi*)o)->GetPMTPhysVol)());
  else   (((::OpNoviceDigi*)o)->GetPMTPhysVol)();
}

static  void method_3348( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetPMTPhysVolMother)((::G4VPhysicalVolume*)arg[0]);
}

static  void method_3349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDigi*)o)->GetPMTPhysVolMother)());
  else   (((::OpNoviceDigi*)o)->GetPMTPhysVolMother)();
}

static  void method_3350( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetName)(*(::G4String*)arg[0]);
}

static  void method_3351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4String)((((::OpNoviceDigi*)o)->GetName)());
  else   (((::OpNoviceDigi*)o)->GetName)();
}

static void method_newdel_486( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::OpNoviceDigi >::new_np_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::OpNoviceDigi >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::OpNoviceDigi >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::OpNoviceDigi >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::OpNoviceDigi >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("G4VDigi")), ::Reflex::BaseOffset< ::OpNoviceDigi,::G4VDigi >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class OpNoviceDigi -------------------------------
void __OpNoviceDigi_db_datamem(Reflex::Class*);
void __OpNoviceDigi_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __OpNoviceDigi_datamem_bld(&__OpNoviceDigi_db_datamem);
Reflex::GenreflexMemberBuilder __OpNoviceDigi_funcmem_bld(&__OpNoviceDigi_db_funcmem);
void __OpNoviceDigi_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("OpNoviceDigi"), typeid(::OpNoviceDigi), sizeof(::OpNoviceDigi), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1035, ::Reflex::BaseOffset< ::OpNoviceDigi, ::G4VDigi >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("OpNoviceDigi"), constructor_3330, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2223), Reflex::Literal("OpNoviceDigi"), constructor_3331, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~OpNoviceDigi"), destructor_3332, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5216), Reflex::Literal("OpNoviceDigi"), constructor_3333, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_486, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__OpNoviceDigi_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__OpNoviceDigi_funcmem_bld);
}

//------Delayed data member builder for class OpNoviceDigi -------------------
void __OpNoviceDigi_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_231, Reflex::Literal("fPmtNumber"), OffsetOf(__shadow__::__OpNoviceDigi, fPmtNumber), ::Reflex::PRIVATE)
  .AddDataMember(type_231, Reflex::Literal("fNPixels"), OffsetOf(__shadow__::__OpNoviceDigi, fNPixels), ::Reflex::PRIVATE)
  .AddDataMember(type_2223, Reflex::Literal("fName"), OffsetOf(__shadow__::__OpNoviceDigi, fName), ::Reflex::PRIVATE)
  .AddDataMember(type_1847, Reflex::Literal("fXmax"), OffsetOf(__shadow__::__OpNoviceDigi, fXmax), ::Reflex::PRIVATE)
  .AddDataMember(type_1847, Reflex::Literal("fYmax"), OffsetOf(__shadow__::__OpNoviceDigi, fYmax), ::Reflex::PRIVATE)
  .AddDataMember(type_231, Reflex::Literal("fPhotons"), OffsetOf(__shadow__::__OpNoviceDigi, fPhotons), ::Reflex::PRIVATE)
  .AddDataMember(type_1847, Reflex::Literal("fFirstTime"), OffsetOf(__shadow__::__OpNoviceDigi, fFirstTime), ::Reflex::PRIVATE)
  .AddDataMember(type_5846, Reflex::Literal("fPhysVolMother"), OffsetOf(__shadow__::__OpNoviceDigi, fPhysVolMother), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_5846, Reflex::Literal("fPhysVol"), OffsetOf(__shadow__::__OpNoviceDigi, fPhysVol), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class OpNoviceDigi -------------------
void __OpNoviceDigi_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5216, type_5216), Reflex::Literal("operator="), operator_3334, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45, type_5216), Reflex::Literal("operator=="), operator_3335, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_1441), Reflex::Literal("operator new"), operator_3336, 0, "", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_613), Reflex::Literal("operator delete"), operator_3337, 0, "aDigi", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("Draw"), method_3338, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("Print"), method_3339, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_231), Reflex::Literal("SetPMTNumber"), method_3340, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231), Reflex::Literal("GetPMTNumber"), method_3341, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_231), Reflex::Literal("SetNPixels"), method_3342, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231), Reflex::Literal("GetNPixels"), method_3343, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_231), Reflex::Literal("SetPhotonsNumber"), method_3344, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231), Reflex::Literal("GetPhotonsNumber"), method_3345, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_5846), Reflex::Literal("SetPMTPhysVol"), method_3346, 0, "physVol", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5846), Reflex::Literal("GetPMTPhysVol"), method_3347, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_5846), Reflex::Literal("SetPMTPhysVolMother"), method_3348, 0, "physVol", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5846), Reflex::Literal("GetPMTPhysVolMother"), method_3349, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_2223), Reflex::Literal("SetName"), method_3350, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2223), Reflex::Literal("GetName"), method_3351, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Hep3Vector -------------------------------
static void constructor_4052( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector();
  else ::new(mem) ::CLHEP::Hep3Vector();
}

static void constructor_4053( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0]);
  else ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0]);
}

static void constructor_4054( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0],
      *(double*)arg[1]);
}

static void constructor_4055( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
}

static void constructor_4056( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else ::new(mem) ::CLHEP::Hep3Vector(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static void destructor_4057(void*, void * o, const std::vector<void*>&, void *) {
(((::CLHEP::Hep3Vector*)o)->::CLHEP::Hep3Vector::~Hep3Vector)();
}
static  void operator_4058( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->operator())(*(int*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator())(*(int*)arg[0]);
}

static  void operator_4059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->operator[])(*(int*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator[])(*(int*)arg[0]);
}

static  void operator_4060( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator())(*(int*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator())(*(int*)arg[0]);
}

static  void operator_4061( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator[])(*(int*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator[])(*(int*)arg[0]);
}

static  void method_4062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->x)());
  else   (((const ::CLHEP::Hep3Vector*)o)->x)();
}

static  void method_4063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->y)());
  else   (((const ::CLHEP::Hep3Vector*)o)->y)();
}

static  void method_4064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->z)());
  else   (((const ::CLHEP::Hep3Vector*)o)->z)();
}

static  void method_4065( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setX)(*(double*)arg[0]);
}

static  void method_4066( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setY)(*(double*)arg[0]);
}

static  void method_4067( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setZ)(*(double*)arg[0]);
}

static  void method_4068( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->set)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->phi)());
  else   (((const ::CLHEP::Hep3Vector*)o)->phi)();
}

static  void method_4070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->theta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->theta)();
}

static  void method_4071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->cosTheta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->cosTheta)();
}

static  void method_4072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->cos2Theta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->cos2Theta)();
}

static  void method_4073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->mag2)());
  else   (((const ::CLHEP::Hep3Vector*)o)->mag2)();
}

static  void method_4074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->mag)());
  else   (((const ::CLHEP::Hep3Vector*)o)->mag)();
}

static  void method_4075( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setPhi)(*(double*)arg[0]);
}

static  void method_4076( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setTheta)(*(double*)arg[0]);
}

static  void method_4077( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setMag)(*(double*)arg[0]);
}

static  void method_4078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->perp2)());
  else   (((const ::CLHEP::Hep3Vector*)o)->perp2)();
}

static  void method_4079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->perp)());
  else   (((const ::CLHEP::Hep3Vector*)o)->perp)();
}

static  void method_4080( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setPerp)(*(double*)arg[0]);
}

static  void method_4081( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setCylTheta)(*(double*)arg[0]);
}

static  void method_4082( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->perp2)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->perp2)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4083( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->perp)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->perp)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4084( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4085( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator==)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator==)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4086( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator!=)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator!=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4087( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isNear)(*(const ::CLHEP::Hep3Vector*)arg[0]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isNear)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isNear)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isNear)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_4088( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->howNear)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->howNear)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->deltaR)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->deltaR)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4090( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator+=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator+=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4091( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator-=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator-=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->operator-)());
  else   (((const ::CLHEP::Hep3Vector*)o)->operator-)();
}

static  void operator_4093( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator*=)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator*=)(*(double*)arg[0]);
}

static  void operator_4094( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator/=)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator/=)(*(double*)arg[0]);
}

static  void method_4095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->unit)());
  else   (((const ::CLHEP::Hep3Vector*)o)->unit)();
}

static  void method_4096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->orthogonal)());
  else   (((const ::CLHEP::Hep3Vector*)o)->orthogonal)();
}

static  void method_4097( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->dot)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->dot)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4098( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->cross)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->cross)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4099( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->angle)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->angle)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->pseudoRapidity)());
  else   (((const ::CLHEP::Hep3Vector*)o)->pseudoRapidity)();
}

static  void method_4101( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setEta)(*(double*)arg[0]);
}

static  void method_4102( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setCylEta)(*(double*)arg[0]);
}

static  void method_4103( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotateX)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotateX)(*(double*)arg[0]);
}

static  void method_4104( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotateY)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotateY)(*(double*)arg[0]);
}

static  void method_4105( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotateZ)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotateZ)(*(double*)arg[0]);
}

static  void method_4106( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotateUz)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotateUz)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4107( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(double*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(double*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]);
}

static  void operator_4108( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator*=)(*(const ::CLHEP::HepRotation*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator*=)(*(const ::CLHEP::HepRotation*)arg[0]);
}

static  void method_4109( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->transform)(*(const ::CLHEP::HepRotation*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->transform)(*(const ::CLHEP::HepRotation*)arg[0]);
}

static  void method_4110( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRThetaPhi)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4111( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setREtaPhi)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4112( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRhoPhiZ)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4113( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRhoPhiTheta)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4114( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRhoPhiEta)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getX)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getX)();
}

static  void method_4116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getY)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getY)();
}

static  void method_4117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getZ)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getZ)();
}

static  void method_4118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getR)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getR)();
}

static  void method_4119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getTheta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getTheta)();
}

static  void method_4120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getPhi)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getPhi)();
}

static  void method_4121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->r)());
  else   (((const ::CLHEP::Hep3Vector*)o)->r)();
}

static  void method_4122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->rho)());
  else   (((const ::CLHEP::Hep3Vector*)o)->rho)();
}

static  void method_4123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getRho)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getRho)();
}

static  void method_4124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->eta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->eta)();
}

static  void method_4125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getEta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getEta)();
}

static  void method_4126( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setR)(*(double*)arg[0]);
}

static  void method_4127( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRho)(*(double*)arg[0]);
}

static  void method_4128( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::CLHEP::Hep3Vector*)o)->compare)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->compare)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4129( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator>)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator>)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4130( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator<)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator<)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4131( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator>=)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator>=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4132( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator<=)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator<=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4133( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->diff2)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->diff2)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::CLHEP::Hep3Vector*)o)->setTolerance)(*(double*)arg[0]));
  else   (((::CLHEP::Hep3Vector*)o)->setTolerance)(*(double*)arg[0]);
}

static  void method_4135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::CLHEP::Hep3Vector*)o)->getTolerance)());
  else   (((::CLHEP::Hep3Vector*)o)->getTolerance)();
}

static  void method_4136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isParallel)(*(const ::CLHEP::Hep3Vector*)arg[0]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isParallel)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isParallel)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isParallel)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_4137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_4138( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->howParallel)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->howParallel)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4139( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->howOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->howOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->beta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->beta)();
}

static  void method_4141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->gamma)());
  else   (((const ::CLHEP::Hep3Vector*)o)->gamma)();
}

static  void method_4142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->coLinearRapidity)());
  else   (((const ::CLHEP::Hep3Vector*)o)->coLinearRapidity)();
}

static  void method_4143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->angle)());
  else   (((const ::CLHEP::Hep3Vector*)o)->angle)();
}

static  void method_4144( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->theta)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->theta)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4145( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->cosTheta)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->cosTheta)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->cos2Theta)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->cos2Theta)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->project)());
  else   (((const ::CLHEP::Hep3Vector*)o)->project)();
}

static  void method_4148( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->project)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->project)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->perpPart)());
  else   (((const ::CLHEP::Hep3Vector*)o)->perpPart)();
}

static  void method_4150( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->perpPart)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->perpPart)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4151( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->rapidity)());
  else   (((const ::CLHEP::Hep3Vector*)o)->rapidity)();
}

static  void method_4152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->rapidity)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->rapidity)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4153( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->eta)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->eta)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4154( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->polarAngle)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->polarAngle)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4155( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->deltaPhi)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->deltaPhi)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4156( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->azimAngle)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->azimAngle)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4157( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->polarAngle)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]));
  else   (((const ::CLHEP::Hep3Vector*)o)->polarAngle)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]);
}

static  void method_4158( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->azimAngle)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]));
  else   (((const ::CLHEP::Hep3Vector*)o)->azimAngle)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]);
}

static  void method_4159( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(double*)arg[1]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(double*)arg[1]);
}

static  void method_4160( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::HepAxisAngle*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::HepAxisAngle*)arg[0]);
}

static  void method_4161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::HepEulerAngles*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::HepEulerAngles*)arg[0]);
}

static  void method_4162( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static void method_newdel_1016( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Hep3Vector -------------------------------
void __CLHEP__Hep3Vector_db_datamem(Reflex::Class*);
void __CLHEP__Hep3Vector_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __CLHEP__Hep3Vector_datamem_bld(&__CLHEP__Hep3Vector_db_datamem);
Reflex::GenreflexMemberBuilder __CLHEP__Hep3Vector_funcmem_bld(&__CLHEP__Hep3Vector_db_funcmem);
void __CLHEP__Hep3Vector_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("CLHEP::Hep3Vector"), typeid(::CLHEP::Hep3Vector), sizeof(::CLHEP::Hep3Vector), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_88"), Reflex::Literal("X=0;Y=1;Z=2;NUM_COORDINATES=3;SIZE=3"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("_89"), Reflex::Literal("ToleranceTicks=100"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Hep3Vector"), constructor_4052, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_390), Reflex::Literal("Hep3Vector"), constructor_4053, 0, "x1", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_390, type_390), Reflex::Literal("Hep3Vector"), constructor_4054, 0, "x1;y1", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_390, type_390, type_390), Reflex::Literal("Hep3Vector"), constructor_4055, 0, "x1;y1;z1", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9831), Reflex::Literal("Hep3Vector"), constructor_4056, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Hep3Vector"), destructor_4057, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1016, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__CLHEP__Hep3Vector_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__CLHEP__Hep3Vector_funcmem_bld);
}

//------Delayed data member builder for class Hep3Vector -------------------
void __CLHEP__Hep3Vector_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_390, Reflex::Literal("dx"), OffsetOf(__shadow__::__CLHEP__Hep3Vector, dx), ::Reflex::PROTECTED)
  .AddDataMember(type_390, Reflex::Literal("dy"), OffsetOf(__shadow__::__CLHEP__Hep3Vector, dy), ::Reflex::PROTECTED)
  .AddDataMember(type_390, Reflex::Literal("dz"), OffsetOf(__shadow__::__CLHEP__Hep3Vector, dz), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Hep3Vector -------------------
void __CLHEP__Hep3Vector_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_45), Reflex::Literal("operator()"), operator_4058, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_45), Reflex::Literal("operator[]"), operator_4059, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6080, type_45), Reflex::Literal("operator()"), operator_4060, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6080, type_45), Reflex::Literal("operator[]"), operator_4061, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("x"), method_4062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("y"), method_4063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("z"), method_4064, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_390), Reflex::Literal("setX"), method_4065, 0, "x1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_390), Reflex::Literal("setY"), method_4066, 0, "y1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_390), Reflex::Literal("setZ"), method_4067, 0, "z1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_390, type_390, type_390), Reflex::Literal("set"), method_4068, 0, "x1;y1;z1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("phi"), method_4069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("theta"), method_4070, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("cosTheta"), method_4071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("cos2Theta"), method_4072, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("mag2"), method_4073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("mag"), method_4074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_390), Reflex::Literal("setPhi"), method_4075, 0, "ph", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_390), Reflex::Literal("setTheta"), method_4076, 0, "th", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_390), Reflex::Literal("setMag"), method_4077, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("perp2"), method_4078, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("perp"), method_4079, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_390), Reflex::Literal("setPerp"), method_4080, 0, "r1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_390), Reflex::Literal("setCylTheta"), method_4081, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831), Reflex::Literal("perp2"), method_4082, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831), Reflex::Literal("perp"), method_4083, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9832, type_9831), Reflex::Literal("operator="), operator_4084, 0, "p", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_9831), Reflex::Literal("operator=="), operator_4085, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_9831), Reflex::Literal("operator!="), operator_4086, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_9831, type_390), Reflex::Literal("isNear"), method_4087, 0, ";epsilon=CLHEP::Hep3Vector::tolerance", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831), Reflex::Literal("howNear"), method_4088, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831), Reflex::Literal("deltaR"), method_4089, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9832, type_9831), Reflex::Literal("operator+="), operator_4090, 0, "p", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9832, type_9831), Reflex::Literal("operator-="), operator_4091, 0, "p", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016), Reflex::Literal("operator-"), operator_4092, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9832, type_390), Reflex::Literal("operator*="), operator_4093, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9832, type_390), Reflex::Literal("operator/="), operator_4094, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016), Reflex::Literal("unit"), method_4095, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016), Reflex::Literal("orthogonal"), method_4096, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831), Reflex::Literal("dot"), method_4097, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016, type_9831), Reflex::Literal("cross"), method_4098, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831), Reflex::Literal("angle"), method_4099, 0, "q", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("pseudoRapidity"), method_4100, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_390), Reflex::Literal("setEta"), method_4101, 0, "p", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_390), Reflex::Literal("setCylEta"), method_4102, 0, "p", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9832, type_390), Reflex::Literal("rotateX"), method_4103, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9832, type_390), Reflex::Literal("rotateY"), method_4104, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9832, type_390), Reflex::Literal("rotateZ"), method_4105, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9832, type_9831), Reflex::Literal("rotateUz"), method_4106, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9832, type_390, type_9831), Reflex::Literal("rotate"), method_4107, 0, ";", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9832, type_9833), Reflex::Literal("operator*="), operator_4108, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9832, type_9833), Reflex::Literal("transform"), method_4109, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_390, type_390, type_390), Reflex::Literal("setRThetaPhi"), method_4110, 0, "r1;theta1;phi1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_390, type_390, type_390), Reflex::Literal("setREtaPhi"), method_4111, 0, "r1;eta1;phi1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_390, type_390, type_390), Reflex::Literal("setRhoPhiZ"), method_4112, 0, "rho1;phi1;z1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_390, type_390, type_390), Reflex::Literal("setRhoPhiTheta"), method_4113, 0, "rho;phi;theta", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_390, type_390, type_390), Reflex::Literal("setRhoPhiEta"), method_4114, 0, "rho;phi;eta", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("getX"), method_4115, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("getY"), method_4116, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("getZ"), method_4117, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("getR"), method_4118, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("getTheta"), method_4119, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("getPhi"), method_4120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("r"), method_4121, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("rho"), method_4122, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("getRho"), method_4123, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("eta"), method_4124, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("getEta"), method_4125, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_390), Reflex::Literal("setR"), method_4126, 0, "r1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_390), Reflex::Literal("setRho"), method_4127, 0, "rho1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45, type_9831), Reflex::Literal("compare"), method_4128, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_9831), Reflex::Literal("operator>"), operator_4129, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_9831), Reflex::Literal("operator<"), operator_4130, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_9831), Reflex::Literal("operator>="), operator_4131, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_9831), Reflex::Literal("operator<="), operator_4132, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831), Reflex::Literal("diff2"), method_4133, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_390), Reflex::Literal("setTolerance"), method_4134, 0, "tol", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("getTolerance"), method_4135, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_9831, type_390), Reflex::Literal("isParallel"), method_4136, 0, "v;epsilon=CLHEP::Hep3Vector::tolerance", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_9831, type_390), Reflex::Literal("isOrthogonal"), method_4137, 0, "v;epsilon=CLHEP::Hep3Vector::tolerance", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831), Reflex::Literal("howParallel"), method_4138, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831), Reflex::Literal("howOrthogonal"), method_4139, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("beta"), method_4140, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("gamma"), method_4141, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("coLinearRapidity"), method_4142, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("angle"), method_4143, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831), Reflex::Literal("theta"), method_4144, 0, "q", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831), Reflex::Literal("cosTheta"), method_4145, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831), Reflex::Literal("cos2Theta"), method_4146, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016), Reflex::Literal("project"), method_4147, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016, type_9831), Reflex::Literal("project"), method_4148, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016), Reflex::Literal("perpPart"), method_4149, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016, type_9831), Reflex::Literal("perpPart"), method_4150, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390), Reflex::Literal("rapidity"), method_4151, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831), Reflex::Literal("rapidity"), method_4152, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831), Reflex::Literal("eta"), method_4153, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831), Reflex::Literal("polarAngle"), method_4154, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831), Reflex::Literal("deltaPhi"), method_4155, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831), Reflex::Literal("azimAngle"), method_4156, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831, type_9831), Reflex::Literal("polarAngle"), method_4157, 0, "v2;ref", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_390, type_9831, type_9831), Reflex::Literal("azimAngle"), method_4158, 0, "v2;ref", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9832, type_9831, type_390), Reflex::Literal("rotate"), method_4159, 0, "axis;delta", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9832, type_9834), Reflex::Literal("rotate"), method_4160, 0, "ax", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9832, type_9835), Reflex::Literal("rotate"), method_4161, 0, "e", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9832, type_390, type_390, type_390), Reflex::Literal("rotate"), method_4162, 0, "phi;theta;psi", ::Reflex::PUBLIC);
}
//------Stub functions for class G4VDigi -------------------------------
static  void operator_4173( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4VDigi*)o)->operator=)(*(const ::G4VDigi*)arg[0]);
  else   (((::G4VDigi*)o)->operator=)(*(const ::G4VDigi*)arg[0]);
}

static void constructor_4174( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4VDigi(*(const ::G4VDigi*)arg[0]);
  else ::new(mem) ::G4VDigi(*(const ::G4VDigi*)arg[0]);
}

static void constructor_4175( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4VDigi();
  else ::new(mem) ::G4VDigi();
}

static void destructor_4176(void*, void * o, const std::vector<void*>&, void *) {
(((::G4VDigi*)o)->::G4VDigi::~G4VDigi)();
}
static  void operator_4177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4int)((((const ::G4VDigi*)o)->operator==)(*(const ::G4VDigi*)arg[0]));
  else   (((const ::G4VDigi*)o)->operator==)(*(const ::G4VDigi*)arg[0]);
}

static  void method_4178( void*, void* o, const std::vector<void*>&, void*)
{
  (((::G4VDigi*)o)->Draw)();
}

static  void method_4179( void*, void* o, const std::vector<void*>&, void*)
{
  (((::G4VDigi*)o)->Print)();
}

static  void method_4180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::G4VDigi*)o)->GetAttDefs)());
  else   (((const ::G4VDigi*)o)->GetAttDefs)();
}

static  void method_4181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::G4VDigi*)o)->CreateAttValues)());
  else   (((const ::G4VDigi*)o)->CreateAttValues)();
}

static void method_newdel_1035( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::G4VDigi >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::G4VDigi >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::G4VDigi >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::G4VDigi >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::G4VDigi >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class G4VDigi -------------------------------
void __G4VDigi_db_datamem(Reflex::Class*);
void __G4VDigi_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __G4VDigi_datamem_bld(&__G4VDigi_db_datamem);
Reflex::GenreflexMemberBuilder __G4VDigi_funcmem_bld(&__G4VDigi_db_funcmem);
void __G4VDigi_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("G4VDigi"), typeid(::G4VDigi), sizeof(::G4VDigi), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9838, type_9839), Reflex::Literal("operator="), operator_4173, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9839), Reflex::Literal("G4VDigi"), constructor_4174, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("G4VDigi"), constructor_4175, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~G4VDigi"), destructor_4176, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1035, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__G4VDigi_funcmem_bld);
}

//------Delayed data member builder for class G4VDigi -------------------
void __G4VDigi_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class G4VDigi -------------------
void __G4VDigi_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231, type_9839), Reflex::Literal("operator=="), operator_4177, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("Draw"), method_4178, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("Print"), method_4179, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9840), Reflex::Literal("GetAttDefs"), method_4180, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9841), Reflex::Literal("CreateAttValues"), method_4181, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class OpNovicePMTHit -------------------------------
static void constructor_4792( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::OpNovicePMTHit();
  else ::new(mem) ::OpNovicePMTHit();
}

static void destructor_4793(void*, void * o, const std::vector<void*>&, void *) {
(((::OpNovicePMTHit*)o)->::OpNovicePMTHit::~OpNovicePMTHit)();
}
static void constructor_4794( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::OpNovicePMTHit(*(const ::OpNovicePMTHit*)arg[0]);
  else ::new(mem) ::OpNovicePMTHit(*(const ::OpNovicePMTHit*)arg[0]);
}

static  void operator_4795( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::OpNovicePMTHit*)o)->operator=)(*(const ::OpNovicePMTHit*)arg[0]);
  else   (((::OpNovicePMTHit*)o)->operator=)(*(const ::OpNovicePMTHit*)arg[0]);
}

static  void operator_4796( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4int)((((const ::OpNovicePMTHit*)o)->operator==)(*(const ::OpNovicePMTHit*)arg[0]));
  else   (((const ::OpNovicePMTHit*)o)->operator==)(*(const ::OpNovicePMTHit*)arg[0]);
}

static  void operator_4797( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNovicePMTHit*)o)->operator new)(*(::size_t*)arg[0]));
  else   (((::OpNovicePMTHit*)o)->operator new)(*(::size_t*)arg[0]);
}

static  void operator_4798( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->operator delete)((void*)arg[0]);
}

static  void method_4799( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNovicePMTHit*)o)->Draw)();
}

static  void method_4800( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNovicePMTHit*)o)->Print)();
}

static  void method_4801( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetDrawit)(*(::G4bool*)arg[0]);
}

static  void method_4802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4bool)((((::OpNovicePMTHit*)o)->GetDrawit)());
  else   (((::OpNovicePMTHit*)o)->GetDrawit)();
}

static  void method_4803( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNovicePMTHit*)o)->IncrementPhotons)();
}

static  void method_4804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNovicePMTHit*)o)->GetPhotonCount)());
  else   (((::OpNovicePMTHit*)o)->GetPhotonCount)();
}

static  void method_4805( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetPMTNumber)(*(::G4int*)arg[0]);
}

static  void method_4806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNovicePMTHit*)o)->GetPMTNumber)());
  else   (((::OpNovicePMTHit*)o)->GetPMTNumber)();
}

static  void method_4807( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetNPixels)(*(::G4int*)arg[0]);
}

static  void method_4808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNovicePMTHit*)o)->GetNPixels)());
  else   (((::OpNovicePMTHit*)o)->GetNPixels)();
}

static  void method_4809( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetHitData)(*(::G4double*)arg[0],
    *(::G4double*)arg[1],
    *(::G4double*)arg[2],
    *(::G4double*)arg[3]);
}

static  void method_4810( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4double)((((::OpNovicePMTHit*)o)->GetX)(*(int*)arg[0]));
  else   (((::OpNovicePMTHit*)o)->GetX)(*(int*)arg[0]);
}

static  void method_4811( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4double)((((::OpNovicePMTHit*)o)->GetY)(*(int*)arg[0]));
  else   (((::OpNovicePMTHit*)o)->GetY)(*(int*)arg[0]);
}

static  void method_4812( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4double)((((::OpNovicePMTHit*)o)->GetT)(*(int*)arg[0]));
  else   (((::OpNovicePMTHit*)o)->GetT)(*(int*)arg[0]);
}

static  void method_4813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4double)((((::OpNovicePMTHit*)o)->GetE)(*(int*)arg[0]));
  else   (((::OpNovicePMTHit*)o)->GetE)(*(int*)arg[0]);
}

static  void method_4814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4double)((((::OpNovicePMTHit*)o)->GetFirstHitTime)());
  else   (((::OpNovicePMTHit*)o)->GetFirstHitTime)();
}

static  void method_4815( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetFirstHitTime)(*(::G4double*)arg[0]);
}

static  void method_4816( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetPMTPhysVol)((::G4VPhysicalVolume*)arg[0]);
}

static  void method_4817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNovicePMTHit*)o)->GetPMTPhysVol)());
  else   (((::OpNovicePMTHit*)o)->GetPMTPhysVol)();
}

static  void method_4818( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetPMTPhysVolMother)((::G4VPhysicalVolume*)arg[0]);
}

static  void method_4819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNovicePMTHit*)o)->GetPMTPhysVolMother)());
  else   (((::OpNovicePMTHit*)o)->GetPMTPhysVolMother)();
}

static  void method_4820( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetDrawScaleMax)(*(::G4int*)arg[0]);
}

static  void method_4821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNovicePMTHit*)o)->GetDrawScaleMax)());
  else   (((::OpNovicePMTHit*)o)->GetDrawScaleMax)();
}

static  void method_4822( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetDrawScaleMin)(*(::G4int*)arg[0]);
}

static  void method_4823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNovicePMTHit*)o)->GetDrawScaleMin)());
  else   (((::OpNovicePMTHit*)o)->GetDrawScaleMin)();
}

static  void method_4824( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNovicePMTHit*)o)->SetName)(*(::G4String*)arg[0]);
}

static  void method_4825( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4String)((((::OpNovicePMTHit*)o)->GetName)());
  else   (((::OpNovicePMTHit*)o)->GetName)();
}

static void method_newdel_1659( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::OpNovicePMTHit >::new_np_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::OpNovicePMTHit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::OpNovicePMTHit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::OpNovicePMTHit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::OpNovicePMTHit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("G4VHit")), ::Reflex::BaseOffset< ::OpNovicePMTHit,::G4VHit >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class OpNovicePMTHit -------------------------------
void __OpNovicePMTHit_db_datamem(Reflex::Class*);
void __OpNovicePMTHit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __OpNovicePMTHit_datamem_bld(&__OpNovicePMTHit_db_datamem);
Reflex::GenreflexMemberBuilder __OpNovicePMTHit_funcmem_bld(&__OpNovicePMTHit_db_funcmem);
void __OpNovicePMTHit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("OpNovicePMTHit"), typeid(::OpNovicePMTHit), sizeof(::OpNovicePMTHit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1760, ::Reflex::BaseOffset< ::OpNovicePMTHit, ::G4VHit >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("OpNovicePMTHit"), constructor_4792, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~OpNovicePMTHit"), destructor_4793, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5272), Reflex::Literal("OpNovicePMTHit"), constructor_4794, 0, "right", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1659, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__OpNovicePMTHit_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__OpNovicePMTHit_funcmem_bld);
}

//------Delayed data member builder for class OpNovicePMTHit -------------------
void __OpNovicePMTHit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_231, Reflex::Literal("fPmtNumber"), OffsetOf(__shadow__::__OpNovicePMTHit, fPmtNumber), ::Reflex::PRIVATE)
  .AddDataMember(type_231, Reflex::Literal("fPhotons"), OffsetOf(__shadow__::__OpNovicePMTHit, fPhotons), ::Reflex::PRIVATE)
  .AddDataMember(type_231, Reflex::Literal("fNPixels"), OffsetOf(__shadow__::__OpNovicePMTHit, fNPixels), ::Reflex::PRIVATE)
  .AddDataMember(type_1847, Reflex::Literal("fFirstTime"), OffsetOf(__shadow__::__OpNovicePMTHit, fFirstTime), ::Reflex::PRIVATE)
  .AddDataMember(type_2223, Reflex::Literal("fName"), OffsetOf(__shadow__::__OpNovicePMTHit, fName), ::Reflex::PRIVATE)
  .AddDataMember(type_2364, Reflex::Literal("fTime"), OffsetOf(__shadow__::__OpNovicePMTHit, fTime), ::Reflex::PRIVATE)
  .AddDataMember(type_2364, Reflex::Literal("fEnergy"), OffsetOf(__shadow__::__OpNovicePMTHit, fEnergy), ::Reflex::PRIVATE)
  .AddDataMember(type_2364, Reflex::Literal("fX"), OffsetOf(__shadow__::__OpNovicePMTHit, fX), ::Reflex::PRIVATE)
  .AddDataMember(type_2364, Reflex::Literal("fY"), OffsetOf(__shadow__::__OpNovicePMTHit, fY), ::Reflex::PRIVATE)
  .AddDataMember(type_5846, Reflex::Literal("fPhysVolMother"), OffsetOf(__shadow__::__OpNovicePMTHit, fPhysVolMother), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_5846, Reflex::Literal("fPhysVol"), OffsetOf(__shadow__::__OpNovicePMTHit, fPhysVol), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_1086, Reflex::Literal("fDrawit"), OffsetOf(__shadow__::__OpNovicePMTHit, fDrawit), ::Reflex::PRIVATE)
  .AddDataMember(type_231, Reflex::Literal("fDrawScaleMin"), OffsetOf(__shadow__::__OpNovicePMTHit, fDrawScaleMin), ::Reflex::PRIVATE)
  .AddDataMember(type_231, Reflex::Literal("fDrawScaleMax"), OffsetOf(__shadow__::__OpNovicePMTHit, fDrawScaleMax), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class OpNovicePMTHit -------------------
void __OpNovicePMTHit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5272, type_5272), Reflex::Literal("operator="), operator_4795, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231, type_5272), Reflex::Literal("operator=="), operator_4796, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_1441), Reflex::Literal("operator new"), operator_4797, 0, "", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_613), Reflex::Literal("operator delete"), operator_4798, 0, "aHit", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("Draw"), method_4799, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("Print"), method_4800, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1086), Reflex::Literal("SetDrawit"), method_4801, 0, "b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1086), Reflex::Literal("GetDrawit"), method_4802, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("IncrementPhotons"), method_4803, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231), Reflex::Literal("GetPhotonCount"), method_4804, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_231), Reflex::Literal("SetPMTNumber"), method_4805, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231), Reflex::Literal("GetPMTNumber"), method_4806, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_231), Reflex::Literal("SetNPixels"), method_4807, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231), Reflex::Literal("GetNPixels"), method_4808, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1847, type_1847, type_1847, type_1847), Reflex::Literal("SetHitData"), method_4809, 0, "t;e;x;y", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1847, type_45), Reflex::Literal("GetX"), method_4810, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1847, type_45), Reflex::Literal("GetY"), method_4811, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1847, type_45), Reflex::Literal("GetT"), method_4812, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1847, type_45), Reflex::Literal("GetE"), method_4813, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1847), Reflex::Literal("GetFirstHitTime"), method_4814, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1847), Reflex::Literal("SetFirstHitTime"), method_4815, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_5846), Reflex::Literal("SetPMTPhysVol"), method_4816, 0, "physVol", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5846), Reflex::Literal("GetPMTPhysVol"), method_4817, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_5846), Reflex::Literal("SetPMTPhysVolMother"), method_4818, 0, "physVol", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5846), Reflex::Literal("GetPMTPhysVolMother"), method_4819, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_231), Reflex::Literal("SetDrawScaleMax"), method_4820, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231), Reflex::Literal("GetDrawScaleMax"), method_4821, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_231), Reflex::Literal("SetDrawScaleMin"), method_4822, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231), Reflex::Literal("GetDrawScaleMin"), method_4823, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_2223), Reflex::Literal("SetName"), method_4824, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2223), Reflex::Literal("GetName"), method_4825, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class G4VHit -------------------------------
static  void operator_4897( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4VHit*)o)->operator=)(*(const ::G4VHit*)arg[0]);
  else   (((::G4VHit*)o)->operator=)(*(const ::G4VHit*)arg[0]);
}

static void constructor_4898( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4VHit(*(const ::G4VHit*)arg[0]);
  else ::new(mem) ::G4VHit(*(const ::G4VHit*)arg[0]);
}

static void constructor_4899( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4VHit();
  else ::new(mem) ::G4VHit();
}

static void destructor_4900(void*, void * o, const std::vector<void*>&, void *) {
(((::G4VHit*)o)->::G4VHit::~G4VHit)();
}
static  void operator_4901( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4int)((((const ::G4VHit*)o)->operator==)(*(const ::G4VHit*)arg[0]));
  else   (((const ::G4VHit*)o)->operator==)(*(const ::G4VHit*)arg[0]);
}

static  void method_4902( void*, void* o, const std::vector<void*>&, void*)
{
  (((::G4VHit*)o)->Draw)();
}

static  void method_4903( void*, void* o, const std::vector<void*>&, void*)
{
  (((::G4VHit*)o)->Print)();
}

static  void method_4904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::G4VHit*)o)->GetAttDefs)());
  else   (((const ::G4VHit*)o)->GetAttDefs)();
}

static  void method_4905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::G4VHit*)o)->CreateAttValues)());
  else   (((const ::G4VHit*)o)->CreateAttValues)();
}

static void method_newdel_1760( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::G4VHit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::G4VHit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::G4VHit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::G4VHit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::G4VHit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class G4VHit -------------------------------
void __G4VHit_db_datamem(Reflex::Class*);
void __G4VHit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __G4VHit_datamem_bld(&__G4VHit_db_datamem);
Reflex::GenreflexMemberBuilder __G4VHit_funcmem_bld(&__G4VHit_db_funcmem);
void __G4VHit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("G4VHit"), typeid(::G4VHit), sizeof(::G4VHit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10814, type_10815), Reflex::Literal("operator="), operator_4897, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10815), Reflex::Literal("G4VHit"), constructor_4898, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("G4VHit"), constructor_4899, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~G4VHit"), destructor_4900, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1760, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__G4VHit_funcmem_bld);
}

//------Delayed data member builder for class G4VHit -------------------
void __G4VHit_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class G4VHit -------------------
void __G4VHit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231, type_10815), Reflex::Literal("operator=="), operator_4901, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("Draw"), method_4902, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("Print"), method_4903, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9840), Reflex::Literal("GetAttDefs"), method_4904, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9841), Reflex::Literal("CreateAttValues"), method_4905, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class G4String -------------------------------
static void constructor_5349( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4String();
  else ::new(mem) ::G4String();
}

static void constructor_5350( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4String(*(char*)arg[0]);
  else ::new(mem) ::G4String(*(char*)arg[0]);
}

static void constructor_5351( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4String((const char*)arg[0]);
  else ::new(mem) ::G4String((const char*)arg[0]);
}

static void constructor_5352( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4String((const char*)arg[0],
      *(::str_size*)arg[1]);
  else ::new(mem) ::G4String((const char*)arg[0],
      *(::str_size*)arg[1]);
}

static void constructor_5353( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4String(*(const ::G4String*)arg[0]);
  else ::new(mem) ::G4String(*(const ::G4String*)arg[0]);
}

static void constructor_5354( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4String(*(const ::G4SubString*)arg[0]);
  else ::new(mem) ::G4String(*(const ::G4SubString*)arg[0]);
}

static void constructor_5355( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4String(*(const ::std::string*)arg[0]);
  else ::new(mem) ::G4String(*(const ::std::string*)arg[0]);
}

static void destructor_5356(void*, void * o, const std::vector<void*>&, void *) {
(((::G4String*)o)->::G4String::~G4String)();
}
static  void operator_5357( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->operator=)(*(const ::G4String*)arg[0]);
  else   (((::G4String*)o)->operator=)(*(const ::G4String*)arg[0]);
}

static  void operator_5358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->operator=)(*(const ::std::string*)arg[0]);
  else   (((::G4String*)o)->operator=)(*(const ::std::string*)arg[0]);
}

static  void operator_5359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->operator=)((const char*)arg[0]);
  else   (((::G4String*)o)->operator=)((const char*)arg[0]);
}

static  void operator_5360( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (char)((((const ::G4String*)o)->operator())(*(::str_size*)arg[0]));
  else   (((const ::G4String*)o)->operator())(*(::str_size*)arg[0]);
}

static  void operator_5361( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->operator())(*(::str_size*)arg[0]);
  else   (((::G4String*)o)->operator())(*(::str_size*)arg[0]);
}

static  void operator_5362( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->operator+=)(*(const ::G4SubString*)arg[0]);
  else   (((::G4String*)o)->operator+=)(*(const ::G4SubString*)arg[0]);
}

static  void operator_5363( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->operator+=)((const char*)arg[0]);
  else   (((::G4String*)o)->operator+=)((const char*)arg[0]);
}

static  void operator_5364( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->operator+=)(*(const ::std::string*)arg[0]);
  else   (((::G4String*)o)->operator+=)(*(const ::std::string*)arg[0]);
}

static  void operator_5365( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->operator+=)(*(const char*)arg[0]);
  else   (((::G4String*)o)->operator+=)(*(const char*)arg[0]);
}

static  void operator_5366( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4bool)((((const ::G4String*)o)->operator==)(*(const ::G4String*)arg[0]));
  else   (((const ::G4String*)o)->operator==)(*(const ::G4String*)arg[0]);
}

static  void operator_5367( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4bool)((((const ::G4String*)o)->operator==)((const char*)arg[0]));
  else   (((const ::G4String*)o)->operator==)((const char*)arg[0]);
}

static  void operator_5368( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4bool)((((const ::G4String*)o)->operator!=)(*(const ::G4String*)arg[0]));
  else   (((const ::G4String*)o)->operator!=)(*(const ::G4String*)arg[0]);
}

static  void operator_5369( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4bool)((((const ::G4String*)o)->operator!=)((const char*)arg[0]));
  else   (((const ::G4String*)o)->operator!=)((const char*)arg[0]);
}

static  void converter_5370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::G4String*)o)->operator const char*)());
  else   (((const ::G4String*)o)->operator const char*)();
}

static  void operator_5371( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4SubString)((((::G4String*)o)->operator())(*(::str_size*)arg[0],
    *(::str_size*)arg[1]));
  else   (((::G4String*)o)->operator())(*(::str_size*)arg[0],
    *(::str_size*)arg[1]);
}

static  void method_5372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (G4int)((((const ::G4String*)o)->compareTo)((const char*)arg[0]));
    else     (((const ::G4String*)o)->compareTo)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (G4int)((((const ::G4String*)o)->compareTo)((const char*)arg[0],
      *(::G4String::caseCompare*)arg[1]));
    else     (((const ::G4String*)o)->compareTo)((const char*)arg[0],
      *(::G4String::caseCompare*)arg[1]);
  }
}

static  void method_5373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (G4int)((((const ::G4String*)o)->compareTo)(*(const ::G4String*)arg[0]));
    else     (((const ::G4String*)o)->compareTo)(*(const ::G4String*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (G4int)((((const ::G4String*)o)->compareTo)(*(const ::G4String*)arg[0],
      *(::G4String::caseCompare*)arg[1]));
    else     (((const ::G4String*)o)->compareTo)(*(const ::G4String*)arg[0],
      *(::G4String::caseCompare*)arg[1]);
  }
}

static  void method_5374( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->prepend)((const char*)arg[0]);
  else   (((::G4String*)o)->prepend)((const char*)arg[0]);
}

static  void method_5375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->append)(*(const ::G4String*)arg[0]);
  else   (((::G4String*)o)->append)(*(const ::G4String*)arg[0]);
}

static  void method_5376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->readLine)(*(::std::istream*)arg[0]);
    else     (((::G4String*)o)->readLine)(*(::std::istream*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->readLine)(*(::std::istream*)arg[0],
      *(::G4bool*)arg[1]);
    else     (((::G4String*)o)->readLine)(*(::std::istream*)arg[0],
      *(::G4bool*)arg[1]);
  }
}

static  void method_5377( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->replace)(*(unsigned int*)arg[0],
    *(unsigned int*)arg[1],
    (const char*)arg[2],
    *(unsigned int*)arg[3]);
  else   (((::G4String*)o)->replace)(*(unsigned int*)arg[0],
    *(unsigned int*)arg[1],
    (const char*)arg[2],
    *(unsigned int*)arg[3]);
}

static  void method_5378( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->replace)(*(::str_size*)arg[0],
    *(::str_size*)arg[1],
    (const char*)arg[2]);
  else   (((::G4String*)o)->replace)(*(::str_size*)arg[0],
    *(::str_size*)arg[1],
    (const char*)arg[2]);
}

static  void method_5379( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->remove)(*(::str_size*)arg[0]);
  else   (((::G4String*)o)->remove)(*(::str_size*)arg[0]);
}

static  void method_5380( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4String*)o)->remove)(*(::str_size*)arg[0],
    *(::str_size*)arg[1]);
  else   (((::G4String*)o)->remove)(*(::str_size*)arg[0],
    *(::str_size*)arg[1]);
}

static  void method_5381( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4int)((((const ::G4String*)o)->first)(*(char*)arg[0]));
  else   (((const ::G4String*)o)->first)(*(char*)arg[0]);
}

static  void method_5382( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4int)((((const ::G4String*)o)->last)(*(char*)arg[0]));
  else   (((const ::G4String*)o)->last)(*(char*)arg[0]);
}

static  void method_5383( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4bool)((((const ::G4String*)o)->contains)(*(const ::std::string*)arg[0]));
  else   (((const ::G4String*)o)->contains)(*(const ::std::string*)arg[0]);
}

static  void method_5384( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4bool)((((const ::G4String*)o)->contains)(*(char*)arg[0]));
  else   (((const ::G4String*)o)->contains)(*(char*)arg[0]);
}

static  void method_5385( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (G4String)((((::G4String*)o)->strip)());
    else     (((::G4String*)o)->strip)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (G4String)((((::G4String*)o)->strip)(*(::G4int*)arg[0]));
    else     (((::G4String*)o)->strip)(*(::G4int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (G4String)((((::G4String*)o)->strip)(*(::G4int*)arg[0],
      *(char*)arg[1]));
    else     (((::G4String*)o)->strip)(*(::G4int*)arg[0],
      *(char*)arg[1]);
  }
}

static  void method_5386( void*, void* o, const std::vector<void*>&, void*)
{
  (((::G4String*)o)->toLower)();
}

static  void method_5387( void*, void* o, const std::vector<void*>&, void*)
{
  (((::G4String*)o)->toUpper)();
}

static  void method_5388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4bool)((((const ::G4String*)o)->isNull)());
  else   (((const ::G4String*)o)->isNull)();
}

static  void method_5389( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (str_size)((((const ::G4String*)o)->index)((const char*)arg[0]));
    else     (((const ::G4String*)o)->index)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (str_size)((((const ::G4String*)o)->index)((const char*)arg[0],
      *(::G4int*)arg[1]));
    else     (((const ::G4String*)o)->index)((const char*)arg[0],
      *(::G4int*)arg[1]);
  }
}

static  void method_5390( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (str_size)((((const ::G4String*)o)->index)(*(char*)arg[0]));
    else     (((const ::G4String*)o)->index)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (str_size)((((const ::G4String*)o)->index)(*(char*)arg[0],
      *(::G4int*)arg[1]));
    else     (((const ::G4String*)o)->index)(*(char*)arg[0],
      *(::G4int*)arg[1]);
  }
}

static  void method_5391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (str_size)((((const ::G4String*)o)->index)(*(const ::G4String*)arg[0],
    *(::str_size*)arg[1],
    *(::str_size*)arg[2],
    *(::G4String::caseCompare*)arg[3]));
  else   (((const ::G4String*)o)->index)(*(const ::G4String*)arg[0],
    *(::str_size*)arg[1],
    *(::str_size*)arg[2],
    *(::G4String::caseCompare*)arg[3]);
}

static  void method_5392( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::G4String*)o)->data)());
  else   (((const ::G4String*)o)->data)();
}

static  void method_5393( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4int)((((const ::G4String*)o)->strcasecompare)((const char*)arg[0],
    (const char*)arg[1]));
  else   (((const ::G4String*)o)->strcasecompare)((const char*)arg[0],
    (const char*)arg[1]);
}

static  void method_5394( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (unsigned int)((((const ::G4String*)o)->hash)());
    else     (((const ::G4String*)o)->hash)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (unsigned int)((((const ::G4String*)o)->hash)(*(::G4String::caseCompare*)arg[0]));
    else     (((const ::G4String*)o)->hash)(*(::G4String::caseCompare*)arg[0]);
  }
}

static  void method_5395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::G4String*)o)->stlhash)());
  else   (((const ::G4String*)o)->stlhash)();
}

static void method_newdel_2223( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::G4String >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::G4String >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::G4String >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::G4String >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::G4String >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>")), ::Reflex::BaseOffset< ::G4String,::std::basic_string<char> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class G4String -------------------------------
void __G4String_db_datamem(Reflex::Class*);
void __G4String_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __G4String_datamem_bld(&__G4String_db_datamem);
Reflex::GenreflexMemberBuilder __G4String_funcmem_bld(&__G4String_db_funcmem);
void __G4String_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("G4String"), typeid(::G4String), sizeof(::G4String), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2383, ::Reflex::BaseOffset< ::G4String, ::std::basic_string<char> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2396, Reflex::Literal("G4String::std_string"))
  .AddEnum(Reflex::Literal("G4String::caseCompare"), Reflex::Literal("exact=0;ignoreCase=1"), &typeid(G4String::caseCompare), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("G4String::stripType"), Reflex::Literal("leading=0;trailing=1;both=2"), &typeid(G4String::stripType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("G4String"), constructor_5349, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_324), Reflex::Literal("G4String"), constructor_5350, 0, "ch", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2829), Reflex::Literal("G4String"), constructor_5351, 0, "astring", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2829, type_2243), Reflex::Literal("G4String"), constructor_5352, 0, "astring;len", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9697), Reflex::Literal("G4String"), constructor_5353, 0, "str", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10811), Reflex::Literal("G4String"), constructor_5354, 0, "str", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7943), Reflex::Literal("G4String"), constructor_5355, 0, "str", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~G4String"), destructor_5356, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2223, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__G4String_funcmem_bld);
}

//------Delayed data member builder for class G4String -------------------
void __G4String_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class G4String -------------------
void __G4String_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10813, type_9697), Reflex::Literal("operator="), operator_5357, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10813, type_7943), Reflex::Literal("operator="), operator_5358, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10813, type_2829), Reflex::Literal("operator="), operator_5359, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_324, type_2243), Reflex::Literal("operator()"), operator_5360, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5926, type_2243), Reflex::Literal("operator()"), operator_5361, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10813, type_10811), Reflex::Literal("operator+="), operator_5362, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10813, type_2829), Reflex::Literal("operator+="), operator_5363, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10813, type_7943), Reflex::Literal("operator+="), operator_5364, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10813, type_6549), Reflex::Literal("operator+="), operator_5365, 0, "ch", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1086, type_9697), Reflex::Literal("operator=="), operator_5366, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1086, type_2829), Reflex::Literal("operator=="), operator_5367, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1086, type_9697), Reflex::Literal("operator!="), operator_5368, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1086, type_2829), Reflex::Literal("operator!="), operator_5369, 0, "str", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2829), Reflex::Literal("operator const char*"), converter_5370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1751, type_2243, type_2243), Reflex::Literal("operator()"), operator_5371, 0, "start;extent", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231, type_2829, type_5347), Reflex::Literal("compareTo"), method_5372, 0, "str;mode=exact", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231, type_9697, type_5347), Reflex::Literal("compareTo"), method_5373, 0, "str;mode=exact", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10813, type_2829), Reflex::Literal("prepend"), method_5374, 0, "str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10813, type_9697), Reflex::Literal("append"), method_5375, 0, "str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10176, type_10176, type_1086), Reflex::Literal("readLine"), method_5376, 0, "strm;skipWhite=true", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10813, type_147, type_147, type_2829, type_147), Reflex::Literal("replace"), method_5377, 0, "start;nbytes;buff;n2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10813, type_2243, type_2243, type_2829), Reflex::Literal("replace"), method_5378, 0, "pos;n;str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10813, type_2243), Reflex::Literal("remove"), method_5379, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10813, type_2243, type_2243), Reflex::Literal("remove"), method_5380, 0, "pos;N", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231, type_324), Reflex::Literal("first"), method_5381, 0, "ch", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231, type_324), Reflex::Literal("last"), method_5382, 0, "ch", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1086, type_7943), Reflex::Literal("contains"), method_5383, 0, "str", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1086, type_324), Reflex::Literal("contains"), method_5384, 0, "ch", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2223, type_231, type_324), Reflex::Literal("strip"), method_5385, 0, "strip_Type=trailing;ch=' '", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("toLower"), method_5386, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("toUpper"), method_5387, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1086), Reflex::Literal("isNull"), method_5388, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2243, type_2829, type_231), Reflex::Literal("index"), method_5389, 0, "str;pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2243, type_324, type_231), Reflex::Literal("index"), method_5390, 0, "ch;pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2243, type_9697, type_2243, type_2243, type_5347), Reflex::Literal("index"), method_5391, 0, "str;ln;st;", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2829), Reflex::Literal("data"), method_5392, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_231, type_2829, type_2829), Reflex::Literal("strcasecompare"), method_5393, 0, "s1;s2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_147, type_5347), Reflex::Literal("hash"), method_5394, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_147), Reflex::Literal("stlhash"), method_5395, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<OpNoviceDigi*,std::allocator<OpNoviceDigi*> > -------------------------------
static void constructor_5962( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNoviceDigi*>();
  else ::new(mem) ::std::vector<OpNoviceDigi*>();
}

static void constructor_5963( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNoviceDigi*>(*(const ::std::allocator<OpNoviceDigi*>*)arg[0]);
  else ::new(mem) ::std::vector<OpNoviceDigi*>(*(const ::std::allocator<OpNoviceDigi*>*)arg[0]);
}

static void constructor_5964( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNoviceDigi*>(*(::size_t*)arg[0]);
  else ::new(mem) ::std::vector<OpNoviceDigi*>(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNoviceDigi*>(*(::size_t*)arg[0],
      *(::OpNoviceDigi* const*)arg[1]);
  else ::new(mem) ::std::vector<OpNoviceDigi*>(*(::size_t*)arg[0],
      *(::OpNoviceDigi* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNoviceDigi*>(*(::size_t*)arg[0],
      *(::OpNoviceDigi* const*)arg[1],
      *(const ::std::allocator<OpNoviceDigi*>*)arg[2]);
  else ::new(mem) ::std::vector<OpNoviceDigi*>(*(::size_t*)arg[0],
      *(::OpNoviceDigi* const*)arg[1],
      *(const ::std::allocator<OpNoviceDigi*>*)arg[2]);
  }
}

static void constructor_5965( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNoviceDigi*>(*(const ::std::vector<OpNoviceDigi*>*)arg[0]);
  else ::new(mem) ::std::vector<OpNoviceDigi*>(*(const ::std::vector<OpNoviceDigi*>*)arg[0]);
}

static void destructor_5966(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<OpNoviceDigi*>*)o)->::std::vector<OpNoviceDigi*>::~vector)();
}
static  void operator_5967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNoviceDigi*>*)o)->operator=)(*(const ::std::vector<OpNoviceDigi*>*)arg[0]);
  else   (((::std::vector<OpNoviceDigi*>*)o)->operator=)(*(const ::std::vector<OpNoviceDigi*>*)arg[0]);
}

static  void method_5968( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNoviceDigi*>*)o)->assign)(*(::size_t*)arg[0],
    *(::OpNoviceDigi* const*)arg[1]);
}

static  void method_5969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >)((((::std::vector<OpNoviceDigi*>*)o)->begin)());
  else   (((::std::vector<OpNoviceDigi*>*)o)->begin)();
}

static  void method_5970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNoviceDigi* const*,std::vector<OpNoviceDigi*> >)((((const ::std::vector<OpNoviceDigi*>*)o)->begin)());
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->begin)();
}

static  void method_5971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >)((((::std::vector<OpNoviceDigi*>*)o)->end)());
  else   (((::std::vector<OpNoviceDigi*>*)o)->end)();
}

static  void method_5972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNoviceDigi* const*,std::vector<OpNoviceDigi*> >)((((const ::std::vector<OpNoviceDigi*>*)o)->end)());
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->end)();
}

static  void method_5977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<OpNoviceDigi*>*)o)->size)());
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->size)();
}

static  void method_5978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<OpNoviceDigi*>*)o)->max_size)());
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->max_size)();
}

static  void method_5979( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<OpNoviceDigi*>*)o)->resize)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<OpNoviceDigi*>*)o)->resize)(*(::size_t*)arg[0],
      (::OpNoviceDigi*)arg[1]);
  }
}

static  void method_5980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<OpNoviceDigi*>*)o)->capacity)());
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->capacity)();
}

static  void method_5981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<OpNoviceDigi*>*)o)->empty)());
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->empty)();
}

static  void method_5982( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNoviceDigi*>*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void operator_5983( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNoviceDigi*>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((::std::vector<OpNoviceDigi*>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void operator_5984( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<OpNoviceDigi*>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_5986( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNoviceDigi*>*)o)->at)(*(::size_t*)arg[0]);
  else   (((::std::vector<OpNoviceDigi*>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_5987( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<OpNoviceDigi*>*)o)->at)(*(::size_t*)arg[0]);
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_5988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNoviceDigi*>*)o)->front)();
  else   (((::std::vector<OpNoviceDigi*>*)o)->front)();
}

static  void method_5989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<OpNoviceDigi*>*)o)->front)();
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->front)();
}

static  void method_5990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNoviceDigi*>*)o)->back)();
  else   (((::std::vector<OpNoviceDigi*>*)o)->back)();
}

static  void method_5991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<OpNoviceDigi*>*)o)->back)();
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->back)();
}

static  void method_5992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<OpNoviceDigi*>*)o)->data)());
  else   (((::std::vector<OpNoviceDigi*>*)o)->data)();
}

static  void method_5993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<OpNoviceDigi*>*)o)->data)());
  else   (((const ::std::vector<OpNoviceDigi*>*)o)->data)();
}

static  void method_5994( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNoviceDigi*>*)o)->push_back)(*(::OpNoviceDigi* const*)arg[0]);
}

static  void method_5995( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<OpNoviceDigi*>*)o)->pop_back)();
}

static  void method_5996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >)((((::std::vector<OpNoviceDigi*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >*)arg[0],
    *(::OpNoviceDigi* const*)arg[1]));
  else   (((::std::vector<OpNoviceDigi*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >*)arg[0],
    *(::OpNoviceDigi* const*)arg[1]);
}

static  void method_5997( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNoviceDigi*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >*)arg[0],
    *(::size_t*)arg[1],
    *(::OpNoviceDigi* const*)arg[2]);
}

static  void method_5998( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >)((((::std::vector<OpNoviceDigi*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >*)arg[0]));
  else   (((::std::vector<OpNoviceDigi*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >*)arg[0]);
}

static  void method_5999( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >)((((::std::vector<OpNoviceDigi*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >*)arg[1]));
  else   (((::std::vector<OpNoviceDigi*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<OpNoviceDigi**,std::vector<OpNoviceDigi*> >*)arg[1]);
}

static  void method_6000( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNoviceDigi*>*)o)->swap)(*(::std::vector<OpNoviceDigi*>*)arg[0]);
}

static  void method_6001( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<OpNoviceDigi*>*)o)->clear)();
}

static void method_newdel_2361( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<OpNoviceDigi*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<OpNoviceDigi*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<OpNoviceDigi*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<OpNoviceDigi*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<OpNoviceDigi*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<OpNoviceDigi*,std::allocator<OpNoviceDigi*> >")), ::Reflex::BaseOffset< ::std::vector<OpNoviceDigi*>,::std::_Vector_base<OpNoviceDigi*,std::allocator<OpNoviceDigi*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<OpNoviceDigi*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<OpNoviceDigi*> >::Generate();
}

//------Dictionary for class vector<OpNoviceDigi*,std::allocator<OpNoviceDigi*> > -------------------------------
void __std__vector_OpNoviceDigip__db_datamem(Reflex::Class*);
void __std__vector_OpNoviceDigip__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_OpNoviceDigip__datamem_bld(&__std__vector_OpNoviceDigip__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_OpNoviceDigip__funcmem_bld(&__std__vector_OpNoviceDigip__db_funcmem);
void __std__vector_OpNoviceDigip__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<OpNoviceDigi*>"), typeid(::std::vector<OpNoviceDigi*>), sizeof(::std::vector<OpNoviceDigi*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2683, ::Reflex::BaseOffset< ::std::vector<OpNoviceDigi*>, ::std::_Vector_base<OpNoviceDigi*,std::allocator<OpNoviceDigi*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_5210, Reflex::Literal("std::vector<OpNoviceDigi*>::_Alloc_value_type"))
  .AddTypedef(type_2683, Reflex::Literal("std::vector<OpNoviceDigi*>::_Base"))
  .AddTypedef(type_2485, Reflex::Literal("std::vector<OpNoviceDigi*>::_Tp_alloc_type"))
  .AddTypedef(type_5210, Reflex::Literal("std::vector<OpNoviceDigi*>::value_type"))
  .AddTypedef(type_5947, Reflex::Literal("std::vector<OpNoviceDigi*>::pointer"))
  .AddTypedef(type_5949, Reflex::Literal("std::vector<OpNoviceDigi*>::const_pointer"))
  .AddTypedef(type_5951, Reflex::Literal("std::vector<OpNoviceDigi*>::reference"))
  .AddTypedef(type_5953, Reflex::Literal("std::vector<OpNoviceDigi*>::const_reference"))
  .AddTypedef(type_3298, Reflex::Literal("std::vector<OpNoviceDigi*>::iterator"))
  .AddTypedef(type_3299, Reflex::Literal("std::vector<OpNoviceDigi*>::const_iterator"))
  .AddTypedef(type_2584, Reflex::Literal("std::vector<OpNoviceDigi*>::const_reverse_iterator"))
  .AddTypedef(type_2585, Reflex::Literal("std::vector<OpNoviceDigi*>::reverse_iterator"))
  .AddTypedef(type_1441, Reflex::Literal("std::vector<OpNoviceDigi*>::size_type"))
  .AddTypedef(type_1141, Reflex::Literal("std::vector<OpNoviceDigi*>::difference_type"))
  .AddTypedef(type_2485, Reflex::Literal("std::vector<OpNoviceDigi*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5962, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10996), Reflex::Literal("vector"), constructor_5963, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1441, type_5953, type_10996), Reflex::Literal("vector"), constructor_5964, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10997), Reflex::Literal("vector"), constructor_5965, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5966, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2361, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_OpNoviceDigip__funcmem_bld);
}

//------Delayed data member builder for class vector<OpNoviceDigi*,std::allocator<OpNoviceDigi*> > -------------------
void __std__vector_OpNoviceDigip__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<OpNoviceDigi*,std::allocator<OpNoviceDigi*> > -------------------
void __std__vector_OpNoviceDigip__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10998, type_10997), Reflex::Literal("operator="), operator_5967, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441, type_5953), Reflex::Literal("assign"), method_5968, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3298), Reflex::Literal("begin"), method_5969, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3299), Reflex::Literal("begin"), method_5970, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3298), Reflex::Literal("end"), method_5971, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3299), Reflex::Literal("end"), method_5972, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("size"), method_5977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("max_size"), method_5978, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441, type_5210), Reflex::Literal("resize"), method_5979, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("capacity"), method_5980, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980), Reflex::Literal("empty"), method_5981, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441), Reflex::Literal("reserve"), method_5982, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5951, type_1441), Reflex::Literal("operator[]"), operator_5983, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5953, type_1441), Reflex::Literal("operator[]"), operator_5984, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5951, type_1441), Reflex::Literal("at"), method_5986, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5953, type_1441), Reflex::Literal("at"), method_5987, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5951), Reflex::Literal("front"), method_5988, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5953), Reflex::Literal("front"), method_5989, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5951), Reflex::Literal("back"), method_5990, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5953), Reflex::Literal("back"), method_5991, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5947), Reflex::Literal("data"), method_5992, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5949), Reflex::Literal("data"), method_5993, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_5953), Reflex::Literal("push_back"), method_5994, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("pop_back"), method_5995, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3298, type_3298, type_5953), Reflex::Literal("insert"), method_5996, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_3298, type_1441, type_5953), Reflex::Literal("insert"), method_5997, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3298, type_3298), Reflex::Literal("erase"), method_5998, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3298, type_3298, type_3298), Reflex::Literal("erase"), method_5999, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_10998), Reflex::Literal("swap"), method_6000, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("clear"), method_6001, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<OpNovicePMTHit*,std::allocator<OpNovicePMTHit*> > -------------------------------
static void constructor_6027( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNovicePMTHit*>();
  else ::new(mem) ::std::vector<OpNovicePMTHit*>();
}

static void constructor_6028( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNovicePMTHit*>(*(const ::std::allocator<OpNovicePMTHit*>*)arg[0]);
  else ::new(mem) ::std::vector<OpNovicePMTHit*>(*(const ::std::allocator<OpNovicePMTHit*>*)arg[0]);
}

static void constructor_6029( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNovicePMTHit*>(*(::size_t*)arg[0]);
  else ::new(mem) ::std::vector<OpNovicePMTHit*>(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNovicePMTHit*>(*(::size_t*)arg[0],
      *(::OpNovicePMTHit* const*)arg[1]);
  else ::new(mem) ::std::vector<OpNovicePMTHit*>(*(::size_t*)arg[0],
      *(::OpNovicePMTHit* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNovicePMTHit*>(*(::size_t*)arg[0],
      *(::OpNovicePMTHit* const*)arg[1],
      *(const ::std::allocator<OpNovicePMTHit*>*)arg[2]);
  else ::new(mem) ::std::vector<OpNovicePMTHit*>(*(::size_t*)arg[0],
      *(::OpNovicePMTHit* const*)arg[1],
      *(const ::std::allocator<OpNovicePMTHit*>*)arg[2]);
  }
}

static void constructor_6030( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<OpNovicePMTHit*>(*(const ::std::vector<OpNovicePMTHit*>*)arg[0]);
  else ::new(mem) ::std::vector<OpNovicePMTHit*>(*(const ::std::vector<OpNovicePMTHit*>*)arg[0]);
}

static void destructor_6031(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<OpNovicePMTHit*>*)o)->::std::vector<OpNovicePMTHit*>::~vector)();
}
static  void operator_6032( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNovicePMTHit*>*)o)->operator=)(*(const ::std::vector<OpNovicePMTHit*>*)arg[0]);
  else   (((::std::vector<OpNovicePMTHit*>*)o)->operator=)(*(const ::std::vector<OpNovicePMTHit*>*)arg[0]);
}

static  void method_6033( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNovicePMTHit*>*)o)->assign)(*(::size_t*)arg[0],
    *(::OpNovicePMTHit* const*)arg[1]);
}

static  void method_6034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >)((((::std::vector<OpNovicePMTHit*>*)o)->begin)());
  else   (((::std::vector<OpNovicePMTHit*>*)o)->begin)();
}

static  void method_6035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNovicePMTHit* const*,std::vector<OpNovicePMTHit*> >)((((const ::std::vector<OpNovicePMTHit*>*)o)->begin)());
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->begin)();
}

static  void method_6036( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >)((((::std::vector<OpNovicePMTHit*>*)o)->end)());
  else   (((::std::vector<OpNovicePMTHit*>*)o)->end)();
}

static  void method_6037( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNovicePMTHit* const*,std::vector<OpNovicePMTHit*> >)((((const ::std::vector<OpNovicePMTHit*>*)o)->end)());
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->end)();
}

static  void method_6042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<OpNovicePMTHit*>*)o)->size)());
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->size)();
}

static  void method_6043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<OpNovicePMTHit*>*)o)->max_size)());
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->max_size)();
}

static  void method_6044( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<OpNovicePMTHit*>*)o)->resize)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<OpNovicePMTHit*>*)o)->resize)(*(::size_t*)arg[0],
      (::OpNovicePMTHit*)arg[1]);
  }
}

static  void method_6045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<OpNovicePMTHit*>*)o)->capacity)());
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->capacity)();
}

static  void method_6046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<OpNovicePMTHit*>*)o)->empty)());
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->empty)();
}

static  void method_6047( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNovicePMTHit*>*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void operator_6048( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNovicePMTHit*>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((::std::vector<OpNovicePMTHit*>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void operator_6049( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<OpNovicePMTHit*>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_6051( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNovicePMTHit*>*)o)->at)(*(::size_t*)arg[0]);
  else   (((::std::vector<OpNovicePMTHit*>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_6052( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<OpNovicePMTHit*>*)o)->at)(*(::size_t*)arg[0]);
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_6053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNovicePMTHit*>*)o)->front)();
  else   (((::std::vector<OpNovicePMTHit*>*)o)->front)();
}

static  void method_6054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<OpNovicePMTHit*>*)o)->front)();
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->front)();
}

static  void method_6055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<OpNovicePMTHit*>*)o)->back)();
  else   (((::std::vector<OpNovicePMTHit*>*)o)->back)();
}

static  void method_6056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<OpNovicePMTHit*>*)o)->back)();
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->back)();
}

static  void method_6057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<OpNovicePMTHit*>*)o)->data)());
  else   (((::std::vector<OpNovicePMTHit*>*)o)->data)();
}

static  void method_6058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<OpNovicePMTHit*>*)o)->data)());
  else   (((const ::std::vector<OpNovicePMTHit*>*)o)->data)();
}

static  void method_6059( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNovicePMTHit*>*)o)->push_back)(*(::OpNovicePMTHit* const*)arg[0]);
}

static  void method_6060( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<OpNovicePMTHit*>*)o)->pop_back)();
}

static  void method_6061( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >)((((::std::vector<OpNovicePMTHit*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >*)arg[0],
    *(::OpNovicePMTHit* const*)arg[1]));
  else   (((::std::vector<OpNovicePMTHit*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >*)arg[0],
    *(::OpNovicePMTHit* const*)arg[1]);
}

static  void method_6062( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNovicePMTHit*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >*)arg[0],
    *(::size_t*)arg[1],
    *(::OpNovicePMTHit* const*)arg[2]);
}

static  void method_6063( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >)((((::std::vector<OpNovicePMTHit*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >*)arg[0]));
  else   (((::std::vector<OpNovicePMTHit*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >*)arg[0]);
}

static  void method_6064( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >)((((::std::vector<OpNovicePMTHit*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >*)arg[1]));
  else   (((::std::vector<OpNovicePMTHit*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<OpNovicePMTHit**,std::vector<OpNovicePMTHit*> >*)arg[1]);
}

static  void method_6065( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<OpNovicePMTHit*>*)o)->swap)(*(::std::vector<OpNovicePMTHit*>*)arg[0]);
}

static  void method_6066( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<OpNovicePMTHit*>*)o)->clear)();
}

static void method_newdel_2362( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<OpNovicePMTHit*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<OpNovicePMTHit*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<OpNovicePMTHit*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<OpNovicePMTHit*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<OpNovicePMTHit*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x13( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<OpNovicePMTHit*,std::allocator<OpNovicePMTHit*> >")), ::Reflex::BaseOffset< ::std::vector<OpNovicePMTHit*>,::std::_Vector_base<OpNovicePMTHit*,std::allocator<OpNovicePMTHit*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<OpNovicePMTHit*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<OpNovicePMTHit*> >::Generate();
}

//------Dictionary for class vector<OpNovicePMTHit*,std::allocator<OpNovicePMTHit*> > -------------------------------
void __std__vector_OpNovicePMTHitp__db_datamem(Reflex::Class*);
void __std__vector_OpNovicePMTHitp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_OpNovicePMTHitp__datamem_bld(&__std__vector_OpNovicePMTHitp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_OpNovicePMTHitp__funcmem_bld(&__std__vector_OpNovicePMTHitp__db_funcmem);
void __std__vector_OpNovicePMTHitp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<OpNovicePMTHit*>"), typeid(::std::vector<OpNovicePMTHit*>), sizeof(::std::vector<OpNovicePMTHit*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2684, ::Reflex::BaseOffset< ::std::vector<OpNovicePMTHit*>, ::std::_Vector_base<OpNovicePMTHit*,std::allocator<OpNovicePMTHit*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_5266, Reflex::Literal("std::vector<OpNovicePMTHit*>::_Alloc_value_type"))
  .AddTypedef(type_2684, Reflex::Literal("std::vector<OpNovicePMTHit*>::_Base"))
  .AddTypedef(type_2486, Reflex::Literal("std::vector<OpNovicePMTHit*>::_Tp_alloc_type"))
  .AddTypedef(type_5266, Reflex::Literal("std::vector<OpNovicePMTHit*>::value_type"))
  .AddTypedef(type_6012, Reflex::Literal("std::vector<OpNovicePMTHit*>::pointer"))
  .AddTypedef(type_6014, Reflex::Literal("std::vector<OpNovicePMTHit*>::const_pointer"))
  .AddTypedef(type_6016, Reflex::Literal("std::vector<OpNovicePMTHit*>::reference"))
  .AddTypedef(type_6018, Reflex::Literal("std::vector<OpNovicePMTHit*>::const_reference"))
  .AddTypedef(type_3300, Reflex::Literal("std::vector<OpNovicePMTHit*>::iterator"))
  .AddTypedef(type_3301, Reflex::Literal("std::vector<OpNovicePMTHit*>::const_iterator"))
  .AddTypedef(type_2586, Reflex::Literal("std::vector<OpNovicePMTHit*>::const_reverse_iterator"))
  .AddTypedef(type_2587, Reflex::Literal("std::vector<OpNovicePMTHit*>::reverse_iterator"))
  .AddTypedef(type_1441, Reflex::Literal("std::vector<OpNovicePMTHit*>::size_type"))
  .AddTypedef(type_1141, Reflex::Literal("std::vector<OpNovicePMTHit*>::difference_type"))
  .AddTypedef(type_2486, Reflex::Literal("std::vector<OpNovicePMTHit*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6027, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11000), Reflex::Literal("vector"), constructor_6028, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1441, type_6018, type_11000), Reflex::Literal("vector"), constructor_6029, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11001), Reflex::Literal("vector"), constructor_6030, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6031, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2362, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_OpNovicePMTHitp__funcmem_bld);
}

//------Delayed data member builder for class vector<OpNovicePMTHit*,std::allocator<OpNovicePMTHit*> > -------------------
void __std__vector_OpNovicePMTHitp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<OpNovicePMTHit*,std::allocator<OpNovicePMTHit*> > -------------------
void __std__vector_OpNovicePMTHitp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11002, type_11001), Reflex::Literal("operator="), operator_6032, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441, type_6018), Reflex::Literal("assign"), method_6033, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3300), Reflex::Literal("begin"), method_6034, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3301), Reflex::Literal("begin"), method_6035, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3300), Reflex::Literal("end"), method_6036, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3301), Reflex::Literal("end"), method_6037, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("size"), method_6042, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("max_size"), method_6043, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441, type_5266), Reflex::Literal("resize"), method_6044, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("capacity"), method_6045, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980), Reflex::Literal("empty"), method_6046, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441), Reflex::Literal("reserve"), method_6047, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6016, type_1441), Reflex::Literal("operator[]"), operator_6048, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6018, type_1441), Reflex::Literal("operator[]"), operator_6049, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6016, type_1441), Reflex::Literal("at"), method_6051, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6018, type_1441), Reflex::Literal("at"), method_6052, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6016), Reflex::Literal("front"), method_6053, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6018), Reflex::Literal("front"), method_6054, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6016), Reflex::Literal("back"), method_6055, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6018), Reflex::Literal("back"), method_6056, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6012), Reflex::Literal("data"), method_6057, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6014), Reflex::Literal("data"), method_6058, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_6018), Reflex::Literal("push_back"), method_6059, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("pop_back"), method_6060, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3300, type_3300, type_6018), Reflex::Literal("insert"), method_6061, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_3300, type_1441, type_6018), Reflex::Literal("insert"), method_6062, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3300, type_3300), Reflex::Literal("erase"), method_6063, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3300, type_3300, type_3300), Reflex::Literal("erase"), method_6064, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_11002), Reflex::Literal("swap"), method_6065, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("clear"), method_6066, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------------------
static void constructor_6581( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>();
  else ::new(mem) ::std::basic_string<char>();
}

static void constructor_6582( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::allocator<char>*)arg[0]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::allocator<char>*)arg[0]);
}

static void constructor_6583( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0]);
}

static void constructor_6584( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1],
      *(::size_t*)arg[2]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1],
      *(::size_t*)arg[2]);
  }
}

static void constructor_6585( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1],
      *(::size_t*)arg[2],
      *(const ::std::allocator<char>*)arg[3]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1],
      *(::size_t*)arg[2],
      *(const ::std::allocator<char>*)arg[3]);
}

static void constructor_6586( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::size_t*)arg[1]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::size_t*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::size_t*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  }
}

static void constructor_6587( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(const ::std::allocator<char>*)arg[1]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(const ::std::allocator<char>*)arg[1]);
  }
}

static void constructor_6588( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(::size_t*)arg[0],
      *(char*)arg[1]);
  else ::new(mem) ::std::basic_string<char>(*(::size_t*)arg[0],
      *(char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(::size_t*)arg[0],
      *(char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  else ::new(mem) ::std::basic_string<char>(*(::size_t*)arg[0],
      *(char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  }
}

static void destructor_6589(void*, void * o, const std::vector<void*>&, void *) {
(((::std::basic_string<char>*)o)->::std::basic_string<char>::~basic_string)();
}
static  void operator_6590( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void operator_6591( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)((const char*)arg[0]);
}

static  void operator_6592( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)(*(char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)(*(char*)arg[0]);
}

static  void method_6593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->begin)());
  else   (((::std::basic_string<char>*)o)->begin)();
}

static  void method_6594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >)((((const ::std::basic_string<char>*)o)->begin)());
  else   (((const ::std::basic_string<char>*)o)->begin)();
}

static  void method_6595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->end)());
  else   (((::std::basic_string<char>*)o)->end)();
}

static  void method_6596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >)((((const ::std::basic_string<char>*)o)->end)());
  else   (((const ::std::basic_string<char>*)o)->end)();
}

static  void method_6601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->size)());
  else   (((const ::std::basic_string<char>*)o)->size)();
}

static  void method_6602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->length)());
  else   (((const ::std::basic_string<char>*)o)->length)();
}

static  void method_6603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->max_size)());
  else   (((const ::std::basic_string<char>*)o)->max_size)();
}

static  void method_6604( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->resize)(*(::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_6605( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->resize)(*(::size_t*)arg[0]);
}

static  void method_6606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->capacity)());
  else   (((const ::std::basic_string<char>*)o)->capacity)();
}

static  void method_6607( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::std::basic_string<char>*)o)->reserve)();
  }
  else if ( arg.size() == 1 ) { 
    (((::std::basic_string<char>*)o)->reserve)(*(::size_t*)arg[0]);
  }
}

static  void method_6608( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::basic_string<char>*)o)->clear)();
}

static  void method_6609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::basic_string<char>*)o)->empty)());
  else   (((const ::std::basic_string<char>*)o)->empty)();
}

static  void operator_6610( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::basic_string<char>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((const ::std::basic_string<char>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void operator_6611( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_6612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::basic_string<char>*)o)->at)(*(::size_t*)arg[0]);
  else   (((const ::std::basic_string<char>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_6613( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->at)(*(::size_t*)arg[0]);
  else   (((::std::basic_string<char>*)o)->at)(*(::size_t*)arg[0]);
}

static  void operator_6614( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void operator_6615( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)((const char*)arg[0]);
}

static  void operator_6616( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)(*(char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)(*(char*)arg[0]);
}

static  void method_6617( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_6618( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_6619( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)((const char*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::std::basic_string<char>*)o)->append)((const char*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_6620( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->append)((const char*)arg[0]);
}

static  void method_6621( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(::size_t*)arg[0],
    *(char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->append)(*(::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_6622( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->push_back)(*(char*)arg[0]);
}

static  void method_6623( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_6624( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_6625( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)((const char*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::std::basic_string<char>*)o)->assign)((const char*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_6626( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->assign)((const char*)arg[0]);
}

static  void method_6627( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(::size_t*)arg[0],
    *(char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->assign)(*(::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_6628( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::size_t*)arg[1],
    *(char*)arg[2]);
}

static  void method_6629( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_6630( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1],
    *(::size_t*)arg[2],
    *(::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1],
    *(::size_t*)arg[2],
    *(::size_t*)arg[3]);
}

static  void method_6631( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    (const char*)arg[1],
    *(::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    (const char*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_6632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    (const char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_6633( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(char*)arg[2]);
}

static  void method_6634( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(char*)arg[1]));
  else   (((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(char*)arg[1]);
}

static  void method_6635( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)();
    else     (((::std::basic_string<char>*)o)->erase)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)(*(::size_t*)arg[0]);
    else     (((::std::basic_string<char>*)o)->erase)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)(*(::size_t*)arg[0],
      *(::size_t*)arg[1]);
    else     (((::std::basic_string<char>*)o)->erase)(*(::size_t*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6636( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0]));
  else   (((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0]);
}

static  void method_6637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1]));
  else   (((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1]);
}

static  void method_6638( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_6639( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::size_t*)arg[3],
    *(::size_t*)arg[4]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::size_t*)arg[3],
    *(::size_t*)arg[4]);
}

static  void method_6640( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2],
    *(::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2],
    *(::size_t*)arg[3]);
}

static  void method_6641( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2]);
}

static  void method_6642( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2],
    *(char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2],
    *(char*)arg[3]);
}

static  void method_6643( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_6644( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    *(::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    *(::size_t*)arg[3]);
}

static  void method_6645( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2]);
}

static  void method_6646( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::size_t*)arg[2],
    *(char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::size_t*)arg[2],
    *(char*)arg[3]);
}

static  void method_6647( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (char*)arg[2],
    (char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (char*)arg[2],
    (char*)arg[3]);
}

static  void method_6648( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    (const char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    (const char*)arg[3]);
}

static  void method_6649( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[3]);
}

static  void method_6650( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[3]);
}

static  void method_6654( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::size_t*)arg[1],
      *(::size_t*)arg[2]));
    else     (((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::size_t*)arg[1],
      *(::size_t*)arg[2]);
  }
}

static  void method_6655( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->swap)(*(::std::basic_string<char>*)arg[0]);
}

static  void method_6656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::basic_string<char>*)o)->c_str)());
  else   (((const ::std::basic_string<char>*)o)->c_str)();
}

static  void method_6657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::basic_string<char>*)o)->data)());
  else   (((const ::std::basic_string<char>*)o)->data)();
}

static  void method_6658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<char>)((((const ::std::basic_string<char>*)o)->get_allocator)());
  else   (((const ::std::basic_string<char>*)o)->get_allocator)();
}

static  void method_6659( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_6660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6662( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6663( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_6665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6667( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6668( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_6669( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6670( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6671( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6672( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_6673( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6674( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6675( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6676( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_6677( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6678( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6679( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6680( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
    *(::size_t*)arg[1],
    *(::size_t*)arg[2]);
}

static  void method_6681( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6682( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6683( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)());
    else     (((const ::std::basic_string<char>*)o)->substr)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)(*(::size_t*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->substr)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)(*(::size_t*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->substr)(*(::size_t*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_6684( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_6685( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_6686( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::size_t*)arg[3],
    *(::size_t*)arg[4]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::size_t*)arg[3],
    *(::size_t*)arg[4]);
}

static  void method_6687( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)((const char*)arg[0]));
  else   (((const ::std::basic_string<char>*)o)->compare)((const char*)arg[0]);
}

static  void method_6688( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2]);
}

static  void method_6689( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2],
    *(::size_t*)arg[3]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::size_t*)arg[0],
    *(::size_t*)arg[1],
    (const char*)arg[2],
    *(::size_t*)arg[3]);
}

static void method_newdel_2383( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------------------
void __std__basic_string_char__db_datamem(Reflex::Class*);
void __std__basic_string_char__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__basic_string_char__datamem_bld(&__std__basic_string_char__db_datamem);
Reflex::GenreflexMemberBuilder __std__basic_string_char__funcmem_bld(&__std__basic_string_char__db_funcmem);
void __std__basic_string_char__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::basic_string<char>"), typeid(::std::basic_string<char>), sizeof(::std::basic_string<char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_2493, Reflex::Literal("std::basic_string<char>::_CharT_alloc_type"))
  .AddTypedef(type_2543, Reflex::Literal("std::basic_string<char>::traits_type"))
  .AddTypedef(type_324, Reflex::Literal("std::basic_string<char>::value_type"))
  .AddTypedef(type_2493, Reflex::Literal("std::basic_string<char>::allocator_type"))
  .AddTypedef(type_1441, Reflex::Literal("std::basic_string<char>::size_type"))
  .AddTypedef(type_1141, Reflex::Literal("std::basic_string<char>::difference_type"))
  .AddTypedef(type_5926, Reflex::Literal("std::basic_string<char>::reference"))
  .AddTypedef(type_6549, Reflex::Literal("std::basic_string<char>::const_reference"))
  .AddTypedef(type_1888, Reflex::Literal("std::basic_string<char>::pointer"))
  .AddTypedef(type_2829, Reflex::Literal("std::basic_string<char>::const_pointer"))
  .AddTypedef(type_3314, Reflex::Literal("std::basic_string<char>::iterator"))
  .AddTypedef(type_3317, Reflex::Literal("std::basic_string<char>::const_iterator"))
  .AddTypedef(type_2606, Reflex::Literal("std::basic_string<char>::const_reverse_iterator"))
  .AddTypedef(type_2607, Reflex::Literal("std::basic_string<char>::reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("basic_string"), constructor_6581, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11071), Reflex::Literal("basic_string"), constructor_6582, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8035), Reflex::Literal("basic_string"), constructor_6583, 0, "__str", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8035, type_1441, type_1441), Reflex::Literal("basic_string"), constructor_6584, 0, "__str;__pos;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8035, type_1441, type_1441, type_11071), Reflex::Literal("basic_string"), constructor_6585, 0, "__str;__pos;__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2829, type_1441, type_11071), Reflex::Literal("basic_string"), constructor_6586, 0, "__s;__n;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2829, type_11071), Reflex::Literal("basic_string"), constructor_6587, 0, "__s;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1441, type_324, type_11071), Reflex::Literal("basic_string"), constructor_6588, 0, "__n;__c;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~basic_string"), destructor_6589, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2383, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__basic_string_char__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__basic_string_char__funcmem_bld);
}

//------Delayed data member builder for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------
void __std__basic_string_char__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6559, Reflex::Literal("_M_dataplus"), OffsetOf(__shadow__::__std__basic_string_char_, _M_dataplus), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------
void __std__basic_string_char__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_8035), Reflex::Literal("operator="), operator_6590, 0, "__str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_2829), Reflex::Literal("operator="), operator_6591, 0, "__s", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_324), Reflex::Literal("operator="), operator_6592, 0, "__c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3314), Reflex::Literal("begin"), method_6593, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3317), Reflex::Literal("begin"), method_6594, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3314), Reflex::Literal("end"), method_6595, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3317), Reflex::Literal("end"), method_6596, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("size"), method_6601, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("length"), method_6602, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("max_size"), method_6603, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441, type_324), Reflex::Literal("resize"), method_6604, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441), Reflex::Literal("resize"), method_6605, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("capacity"), method_6606, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_1441), Reflex::Literal("reserve"), method_6607, 0, "__res=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136), Reflex::Literal("clear"), method_6608, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980), Reflex::Literal("empty"), method_6609, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6549, type_1441), Reflex::Literal("operator[]"), operator_6610, 0, "__pos", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5926, type_1441), Reflex::Literal("operator[]"), operator_6611, 0, "__pos", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6549, type_1441), Reflex::Literal("at"), method_6612, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5926, type_1441), Reflex::Literal("at"), method_6613, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_8035), Reflex::Literal("operator+="), operator_6614, 0, "__str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_2829), Reflex::Literal("operator+="), operator_6615, 0, "__s", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_324), Reflex::Literal("operator+="), operator_6616, 0, "__c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_8035), Reflex::Literal("append"), method_6617, 0, "__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_8035, type_1441, type_1441), Reflex::Literal("append"), method_6618, 0, "__str;__pos;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_2829, type_1441), Reflex::Literal("append"), method_6619, 0, "__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_2829), Reflex::Literal("append"), method_6620, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_1441, type_324), Reflex::Literal("append"), method_6621, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_324), Reflex::Literal("push_back"), method_6622, 0, "__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_8035), Reflex::Literal("assign"), method_6623, 0, "__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_8035, type_1441, type_1441), Reflex::Literal("assign"), method_6624, 0, "__str;__pos;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_2829, type_1441), Reflex::Literal("assign"), method_6625, 0, "__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_2829), Reflex::Literal("assign"), method_6626, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_1441, type_324), Reflex::Literal("assign"), method_6627, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_3314, type_1441, type_324), Reflex::Literal("insert"), method_6628, 0, "__p;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_1441, type_8035), Reflex::Literal("insert"), method_6629, 0, "__pos1;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_1441, type_8035, type_1441, type_1441), Reflex::Literal("insert"), method_6630, 0, "__pos1;__str;__pos2;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_1441, type_2829, type_1441), Reflex::Literal("insert"), method_6631, 0, "__pos;__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_1441, type_2829), Reflex::Literal("insert"), method_6632, 0, "__pos;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_1441, type_1441, type_324), Reflex::Literal("insert"), method_6633, 0, "__pos;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3314, type_3314, type_324), Reflex::Literal("insert"), method_6634, 0, "__p;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_1441, type_1441), Reflex::Literal("erase"), method_6635, 0, "__pos=0;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3314, type_3314), Reflex::Literal("erase"), method_6636, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3314, type_3314, type_3314), Reflex::Literal("erase"), method_6637, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_1441, type_1441, type_8035), Reflex::Literal("replace"), method_6638, 0, "__pos;__n;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_1441, type_1441, type_8035, type_1441, type_1441), Reflex::Literal("replace"), method_6639, 0, "__pos1;__n1;__str;__pos2;__n2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_1441, type_1441, type_2829, type_1441), Reflex::Literal("replace"), method_6640, 0, "__pos;__n1;__s;__n2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_1441, type_1441, type_2829), Reflex::Literal("replace"), method_6641, 0, "__pos;__n1;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_1441, type_1441, type_1441, type_324), Reflex::Literal("replace"), method_6642, 0, "__pos;__n1;__n2;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_3314, type_3314, type_8035), Reflex::Literal("replace"), method_6643, 0, "__i1;__i2;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_3314, type_3314, type_2829, type_1441), Reflex::Literal("replace"), method_6644, 0, "__i1;__i2;__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_3314, type_3314, type_2829), Reflex::Literal("replace"), method_6645, 0, "__i1;__i2;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_3314, type_3314, type_1441, type_324), Reflex::Literal("replace"), method_6646, 0, "__i1;__i2;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_3314, type_3314, type_1888, type_1888), Reflex::Literal("replace"), method_6647, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_3314, type_3314, type_2829, type_2829), Reflex::Literal("replace"), method_6648, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_3314, type_3314, type_3314, type_3314), Reflex::Literal("replace"), method_6649, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_3314, type_3314, type_3317, type_3317), Reflex::Literal("replace"), method_6650, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_1888, type_1441, type_1441), Reflex::Literal("copy"), method_6654, 0, "__s;__n;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_136, type_7950), Reflex::Literal("swap"), method_6655, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2829), Reflex::Literal("c_str"), method_6656, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2829), Reflex::Literal("data"), method_6657, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2493), Reflex::Literal("get_allocator"), method_6658, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2829, type_1441, type_1441), Reflex::Literal("find"), method_6659, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_8035, type_1441), Reflex::Literal("find"), method_6660, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2829, type_1441), Reflex::Literal("find"), method_6661, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_324, type_1441), Reflex::Literal("find"), method_6662, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_8035, type_1441), Reflex::Literal("rfind"), method_6663, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2829, type_1441, type_1441), Reflex::Literal("rfind"), method_6664, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2829, type_1441), Reflex::Literal("rfind"), method_6665, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_324, type_1441), Reflex::Literal("rfind"), method_6666, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_8035, type_1441), Reflex::Literal("find_first_of"), method_6667, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2829, type_1441, type_1441), Reflex::Literal("find_first_of"), method_6668, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2829, type_1441), Reflex::Literal("find_first_of"), method_6669, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_324, type_1441), Reflex::Literal("find_first_of"), method_6670, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_8035, type_1441), Reflex::Literal("find_last_of"), method_6671, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2829, type_1441, type_1441), Reflex::Literal("find_last_of"), method_6672, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2829, type_1441), Reflex::Literal("find_last_of"), method_6673, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_324, type_1441), Reflex::Literal("find_last_of"), method_6674, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_8035, type_1441), Reflex::Literal("find_first_not_of"), method_6675, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2829, type_1441, type_1441), Reflex::Literal("find_first_not_of"), method_6676, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2829, type_1441), Reflex::Literal("find_first_not_of"), method_6677, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_324, type_1441), Reflex::Literal("find_first_not_of"), method_6678, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_8035, type_1441), Reflex::Literal("find_last_not_of"), method_6679, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2829, type_1441, type_1441), Reflex::Literal("find_last_not_of"), method_6680, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_2829, type_1441), Reflex::Literal("find_last_not_of"), method_6681, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_324, type_1441), Reflex::Literal("find_last_not_of"), method_6682, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2383, type_1441, type_1441), Reflex::Literal("substr"), method_6683, 0, "__pos=0;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45, type_8035), Reflex::Literal("compare"), method_6684, 0, "__str", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45, type_1441, type_1441, type_8035), Reflex::Literal("compare"), method_6685, 0, "__pos;__n;__str", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45, type_1441, type_1441, type_8035, type_1441, type_1441), Reflex::Literal("compare"), method_6686, 0, "__pos1;__n1;__str;__pos2;__n2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45, type_2829), Reflex::Literal("compare"), method_6687, 0, "__s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45, type_1441, type_1441, type_2829), Reflex::Literal("compare"), method_6688, 0, "__pos;__n1;__s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45, type_1441, type_1441, type_2829, type_1441), Reflex::Literal("compare"), method_6689, 0, "__pos;__n1;__s;__n2", ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __OpNoviceDigi_dict(); 
      __CLHEP__Hep3Vector_dict(); 
      __G4VDigi_dict(); 
      __OpNovicePMTHit_dict(); 
      __G4VHit_dict(); 
      __G4String_dict(); 
      __std__vector_OpNoviceDigip__dict(); 
      __std__vector_OpNovicePMTHitp__dict(); 
      __std__basic_string_char__dict(); 
    }
    ~Dictionaries() {
      type_486.Unload(); // class OpNoviceDigi 
      type_1016.Unload(); // class CLHEP::Hep3Vector 
      type_1035.Unload(); // class G4VDigi 
      type_1659.Unload(); // class OpNovicePMTHit 
      type_1760.Unload(); // class G4VHit 
      type_2223.Unload(); // class G4String 
      type_2361.Unload(); // class std::vector<OpNoviceDigi*> 
      type_2362.Unload(); // class std::vector<OpNovicePMTHit*> 
      type_2383.Unload(); // class std::basic_string<char> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
