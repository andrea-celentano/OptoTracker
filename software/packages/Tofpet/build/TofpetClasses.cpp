// Generated at Wed Nov 16 23:36:44 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/usr/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/usr/bin/c++"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic "
  GCCXML_EXECUTABLE="/usr/bin/gccxml_cc1plus"
  GCCXML_CPP="/usr/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__FLT_MIN__='1.17549435e-38F' -D__CHAR_BIT__='8' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='4.9406564584124654e-324' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__LP64__='1' -D__GNUC_PATCHLEVEL__='7' -D__DEC64_MAX_EXP__='385' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__unix='1' -D__LDBL_MAX_EXP__='16384' -D__linux__='1' -D__SCHAR_MAX__='127' -D__DBL_DIG__='15' -D_FORTIFY_SOURCE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209290e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__SIZEOF_LONG__='8' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='1.7976931348623157e+308' -D__DBL_HAS_INFINITY__='1' -D__DEC32_MIN_EXP__='(-94)' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__DBL_MIN__='2.2250738585072014e-308' -D__FLT_MIN_10_EXP__='(-37)' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__DBL_HAS_DENORM__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.4.7 20120313 (Red Hat 4.4.7-17)"' -D__DEC64_EPSILON__='1E-15DD' -D__DEC128_MIN_EXP__='(-6142)' -Dunix='1' -D__SIZE_TYPE__='long unsigned int' -D__ELF__='1' -D__FLT_RADIX__='2' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__GNUC_RH_RELEASE__='17' -D__k8='1' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__DEC64_MANT_DIG__='16' -D__DEC32_MAX_EXP__='97' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__k8__='1' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__DEC64_MIN_EXP__='(-382)' -D__FLT_DIG__='6' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__FLT_MAX_EXP__='128' -D__DBL_MANT_DIG__='53' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__SSP__='1' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='2.2204460492503131e-16' -D_LP64='1' -D__SIZEOF_WCHAR_T__='4' -D__DEC_EVAL_METHOD__='2' -D__INTMAX_MAX__='9223372036854775807L' -D__FLT_DENORM_MIN__='1.40129846e-45F' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282347e+38F' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='4' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__GNUC_GNU_INLINE__='1' -D_GNU_SOURCE='1' -iwrapper"/usr/share/gccxml-0.9/GCC/4.4" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/backward" -isystem"/usr/local/include" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/usr/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.4.7 20120313 (Red Hat 4.4.7-17)
Copyright (C) 2010 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/work/OptoTracker/software/packages/Tofpet/include/TofpetClasses.hh"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::Type type_135 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_948 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_227 = ::Reflex::TypeBuilder(Reflex::Literal("TH1D"));
  ::Reflex::Type type_237 = ::Reflex::TypeBuilder(Reflex::Literal("TH2D"));
  ::Reflex::Type type_617 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_177 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_97 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1752 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_179 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_992 = ::Reflex::TypeBuilder(Reflex::Literal("TList"));
  ::Reflex::Type type_964 = ::Reflex::TypeBuilder(Reflex::Literal("TLine"));
  ::Reflex::Type type_220 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_1845 = ::Reflex::TypeBuilder(Reflex::Literal("TClass"));
  ::Reflex::Type type_805 = ::Reflex::TypeBuilder(Reflex::Literal("TBuffer"));
  ::Reflex::Type type_1660 = ::Reflex::TypeBuilder(Reflex::Literal("TGraph"));
  ::Reflex::Type type_2105 = ::Reflex::TypeBuilder(Reflex::Literal("TObject"));
  ::Reflex::Type type_2369 = ::Reflex::TypeBuilder(Reflex::Literal("TCanvas"));
  ::Reflex::Type type_259 = ::Reflex::TypeBuilder(Reflex::Literal("TGWindow"));
  ::Reflex::Type type_2298 = ::Reflex::TypeBuilder(Reflex::Literal("TGCanvas"));
  ::Reflex::Type type_300 = ::Reflex::TypeBuilder(Reflex::Literal("TTofpetRun"));
  ::Reflex::Type type_1809 = ::Reflex::TypeBuilder(Reflex::Literal("long long"));
  ::Reflex::Type type_2704 = ::Reflex::TypeBuilder(Reflex::Literal("TTofpetHit"));
  ::Reflex::Type type_2613 = ::Reflex::TypeBuilder(Reflex::Literal("TGMainFrame"));
  ::Reflex::Type type_194 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_32 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_1151 = ::Reflex::TypeBuilder(Reflex::Literal("TEventHeader"));
  ::Reflex::Type type_1757 = ::Reflex::TypeBuilder(Reflex::Literal("TGTextButton"));
  ::Reflex::Type type_2003 = ::Reflex::TypeBuilder(Reflex::Literal("TGNumberEntry"));
  ::Reflex::Type type_296 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_2965 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<int>"));
  ::Reflex::Type type_400 = ::Reflex::TypeBuilder(Reflex::Literal("TMemberInspector"));
  ::Reflex::Type type_2749 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_2928 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,int>"));
  ::Reflex::Type type_1663 = ::Reflex::TypeBuilder(Reflex::Literal("TRealSetupHandler"));
  ::Reflex::Type type_1354 = ::Reflex::TypeBuilder(Reflex::Literal("TGHorizontalFrame"));
  ::Reflex::Type type_3019 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<int,int>"));
  ::Reflex::Type type_1096 = ::Reflex::TypeBuilder(Reflex::Literal("TTofpetEventHeader"));
  ::Reflex::Type type_2925 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,TH1D*>"));
  ::Reflex::Type type_2923 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,TH2D*>"));
  ::Reflex::Type type_2344 = ::Reflex::TypeBuilder(Reflex::Literal("TTofpetSetupHandler"));
  ::Reflex::Type type_1547 = ::Reflex::TypeBuilder(Reflex::Literal("TRootEmbeddedCanvas"));
  ::Reflex::Type type_2929 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,double>"));
  ::Reflex::Type type_2924 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,TGraph*>"));
  ::Reflex::Type type_2776 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_3020 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const int,int>"));
  ::Reflex::Type type_3010 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const int,TH2D*>"));
  ::Reflex::Type type_3009 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const int,TH1D*>"));
  ::Reflex::Type type_1637 = ::Reflex::TypeBuilder(Reflex::Literal("TTofpetThresholdCalibration"));
  ::Reflex::Type type_3021 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const int,double>"));
  ::Reflex::Type type_3008 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const int,TGraph*>"));
  ::Reflex::Type type_2516 = ::Reflex::TypeBuilder(Reflex::Literal("TTofpetThresholdCalibrationGui"));
  ::Reflex::Type type_2966 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<std::pair<int,int> >"));
  ::Reflex::Type type_2930 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,std::vector<int> >"));
  ::Reflex::Type type_2752 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<int,int> >"));
  ::Reflex::Type type_2931 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::pair<int,int>,int>"));
  ::Reflex::Type type_2927 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,std::pair<int,int> >"));
  ::Reflex::Type type_2926 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,std::basic_string<char> >"));
  ::Reflex::Type type_3023 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const int,std::vector<int> >"));
  ::Reflex::Type type_3039 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::pair<int,int>,int>"));
  ::Reflex::Type type_3016 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const int,std::pair<int,int> >"));
  ::Reflex::Type type_3110 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const int,int> >"));
  ::Reflex::Type type_3105 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const int,TH2D*> >"));
  ::Reflex::Type type_3104 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const int,TH1D*> >"));
  ::Reflex::Type type_3111 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const int,double> >"));
  ::Reflex::Type type_3103 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const int,TGraph*> >"));
  ::Reflex::Type type_3012 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const int,std::basic_string<char> >"));
  ::Reflex::Type type_2798 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const int,int> >"));
  ::Reflex::Type type_2794 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const int,TH2D*> >"));
  ::Reflex::Type type_2796 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const int,TH1D*> >"));
  ::Reflex::Type type_2797 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const int,double> >"));
  ::Reflex::Type type_2795 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const int,TGraph*> >"));
  ::Reflex::Type type_3262 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const int,int> >"));
  ::Reflex::Type type_3113 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const int,std::vector<int> > >"));
  ::Reflex::Type type_3120 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::pair<int,int>,int> >"));
  ::Reflex::Type type_3258 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const int,TH2D*> >"));
  ::Reflex::Type type_3260 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const int,TH1D*> >"));
  ::Reflex::Type type_3109 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const int,std::pair<int,int> > >"));
  ::Reflex::Type type_3261 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const int,double> >"));
  ::Reflex::Type type_3259 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const int,TGraph*> >"));
  ::Reflex::Type type_3107 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const int,std::basic_string<char> > >"));
  ::Reflex::Type type_2793 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > >"));
  ::Reflex::Type type_2799 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >"));
  ::Reflex::Type type_2792 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > >"));
  ::Reflex::Type type_3042 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,int> >,bool>"));
  ::Reflex::Type type_3028 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,TH2D*> >,bool>"));
  ::Reflex::Type type_3034 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,TH1D*> >,bool>"));
  ::Reflex::Type type_3038 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,double> >,bool>"));
  ::Reflex::Type type_3031 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,TGraph*> >,bool>"));
  ::Reflex::Type type_3257 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const int,std::vector<int> > >"));
  ::Reflex::Type type_2791 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > >"));
  ::Reflex::Type type_3263 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> >"));
  ::Reflex::Type type_3256 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const int,std::pair<int,int> > >"));
  ::Reflex::Type type_3201 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const int,int> > >"));
  ::Reflex::Type type_3193 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const int,TH2D*> > >"));
  ::Reflex::Type type_3197 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const int,TH1D*> > >"));
  ::Reflex::Type type_3255 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const int,std::basic_string<char> > >"));
  ::Reflex::Type type_3199 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const int,double> > >"));
  ::Reflex::Type type_3195 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const int,TGraph*> > >"));
  ::Reflex::Type type_3200 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const int,int> > >"));
  ::Reflex::Type type_3025 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > >,bool>"));
  ::Reflex::Type type_3045 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >,bool>"));
  ::Reflex::Type type_3192 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const int,TH2D*> > >"));
  ::Reflex::Type type_3196 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const int,TH1D*> > >"));
  ::Reflex::Type type_3018 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > >,bool>"));
  ::Reflex::Type type_3198 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const int,double> > >"));
  ::Reflex::Type type_3194 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const int,TGraph*> > >"));
  ::Reflex::Type type_3014 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > >,bool>"));
  ::Reflex::Type type_3191 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > > >"));
  ::Reflex::Type type_3207 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> > >"));
  ::Reflex::Type type_3189 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > > >"));
  ::Reflex::Type type_3190 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const int,std::vector<int> > > >"));
  ::Reflex::Type type_3187 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > > >"));
  ::Reflex::Type type_3206 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> > >"));
  ::Reflex::Type type_3188 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const int,std::pair<int,int> > > >"));
  ::Reflex::Type type_3186 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const int,std::basic_string<char> > > >"));
  ::Reflex::Type type_3041 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,int> >,std::_Rb_tree_iterator<std::pair<const int,int> > >"));
  ::Reflex::Type type_3027 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,TH2D*> >,std::_Rb_tree_iterator<std::pair<const int,TH2D*> > >"));
  ::Reflex::Type type_3033 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,TH1D*> >,std::_Rb_tree_iterator<std::pair<const int,TH1D*> > >"));
  ::Reflex::Type type_3037 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,double> >,std::_Rb_tree_iterator<std::pair<const int,double> > >"));
  ::Reflex::Type type_3030 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,TGraph*> >,std::_Rb_tree_iterator<std::pair<const int,TGraph*> > >"));
  ::Reflex::Type type_3040 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const int,int> >,std::_Rb_tree_const_iterator<std::pair<const int,int> > >"));
  ::Reflex::Type type_3026 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const int,TH2D*> >,std::_Rb_tree_const_iterator<std::pair<const int,TH2D*> > >"));
  ::Reflex::Type type_3032 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const int,TH1D*> >,std::_Rb_tree_const_iterator<std::pair<const int,TH1D*> > >"));
  ::Reflex::Type type_3036 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const int,double> >,std::_Rb_tree_const_iterator<std::pair<const int,double> > >"));
  ::Reflex::Type type_3029 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const int,TGraph*> >,std::_Rb_tree_const_iterator<std::pair<const int,TGraph*> > >"));
  ::Reflex::Type type_3024 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > >,std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > > >"));
  ::Reflex::Type type_3044 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >,std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> > >"));
  ::Reflex::Type type_3017 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > >,std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > > >"));
  ::Reflex::Type type_3057 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<int,std::pair<const int,int>,std::_Select1st<std::pair<const int,int> >,std::less<int>,std::allocator<std::pair<const int,int> > >"));
  ::Reflex::Type type_3053 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<int,std::pair<const int,TH2D*>,std::_Select1st<std::pair<const int,TH2D*> >,std::less<int>,std::allocator<std::pair<const int,TH2D*> > >"));
  ::Reflex::Type type_3055 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<int,std::pair<const int,TH1D*>,std::_Select1st<std::pair<const int,TH1D*> >,std::less<int>,std::allocator<std::pair<const int,TH1D*> > >"));
  ::Reflex::Type type_3022 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const int,std::vector<int> > >,std::_Rb_tree_const_iterator<std::pair<const int,std::vector<int> > > >"));
  ::Reflex::Type type_3013 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > >,std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > > >"));
  ::Reflex::Type type_3056 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<int,std::pair<const int,double>,std::_Select1st<std::pair<const int,double> >,std::less<int>,std::allocator<std::pair<const int,double> > >"));
  ::Reflex::Type type_3043 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> >,std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> > >"));
  ::Reflex::Type type_3015 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const int,std::pair<int,int> > >,std::_Rb_tree_const_iterator<std::pair<const int,std::pair<int,int> > > >"));
  ::Reflex::Type type_3054 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<int,std::pair<const int,TGraph*>,std::_Select1st<std::pair<const int,TGraph*> >,std::less<int>,std::allocator<std::pair<const int,TGraph*> > >"));
  ::Reflex::Type type_3011 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const int,std::basic_string<char> > >,std::_Rb_tree_const_iterator<std::pair<const int,std::basic_string<char> > > >"));
  ::Reflex::Type type_3052 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<int,std::pair<const int,std::vector<int> >,std::_Select1st<std::pair<const int,std::vector<int> > >,std::less<int>,std::allocator<std::pair<const int,std::vector<int> > > >"));
  ::Reflex::Type type_3051 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<int,std::pair<const int,std::pair<int,int> >,std::_Select1st<std::pair<const int,std::pair<int,int> > >,std::less<int>,std::allocator<std::pair<const int,std::pair<int,int> > > >"));
  ::Reflex::Type type_3050 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<int,std::pair<const int,std::basic_string<char> >,std::_Select1st<std::pair<const int,std::basic_string<char> > >,std::less<int>,std::allocator<std::pair<const int,std::basic_string<char> > > >"));
  ::Reflex::Type type_3058 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::pair<int,int>,std::pair<const std::pair<int,int>,int>,std::_Select1st<std::pair<const std::pair<int,int>,int> >,std::less<std::pair<int,int> >,std::allocator<std::pair<const std::pair<int,int>,int> > >"));
  ::Reflex::Type type_15621 = ::Reflex::ReferenceBuilder(type_300);
  ::Reflex::Type type_300c = ::Reflex::ConstBuilder(type_300);
  ::Reflex::Type type_15622 = ::Reflex::ReferenceBuilder(type_300c);
  ::Reflex::Type type_744 = ::Reflex::PointerBuilder(type_1845);
  ::Reflex::Type type_948c = ::Reflex::ConstBuilder(type_948);
  ::Reflex::Type type_3361 = ::Reflex::PointerBuilder(type_948c);
  ::Reflex::Type type_2386 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Version_t"), type_179);
  ::Reflex::Type type_15486 = ::Reflex::ReferenceBuilder(type_400);
  ::Reflex::Type type_4973 = ::Reflex::ReferenceBuilder(type_805);
  ::Reflex::Type type_15824 = ::Reflex::ReferenceBuilder(type_1096);
  ::Reflex::Type type_1096c = ::Reflex::ConstBuilder(type_1096);
  ::Reflex::Type type_15825 = ::Reflex::ReferenceBuilder(type_1096c);
  ::Reflex::Type type_15488 = ::Reflex::PointerBuilder(type_992);
  ::Reflex::Type type_16579 = ::Reflex::PointerBuilder(type_2516);
  ::Reflex::Type type_16580 = ::Reflex::ReferenceBuilder(type_1637);
  ::Reflex::Type type_1637c = ::Reflex::ConstBuilder(type_1637);
  ::Reflex::Type type_16581 = ::Reflex::ReferenceBuilder(type_1637c);
  ::Reflex::Type type_12275 = ::Reflex::PointerBuilder(type_227);
  ::Reflex::Type type_12212 = ::Reflex::PointerBuilder(type_1660);
  ::Reflex::Type type_12149 = ::Reflex::PointerBuilder(type_237);
  ::Reflex::Type type_2786 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2776);
  ::Reflex::Type type_15725 = ::Reflex::PointerBuilder(type_2369);
  ::Reflex::Type type_16582 = ::Reflex::ReferenceBuilder(type_2923);
  ::Reflex::Type type_16583 = ::Reflex::ReferenceBuilder(type_2925);
  ::Reflex::Type type_16584 = ::Reflex::ReferenceBuilder(type_2924);
  ::Reflex::Type type_2925c = ::Reflex::ConstBuilder(type_2925);
  ::Reflex::Type type_16585 = ::Reflex::ReferenceBuilder(type_2925c);
  ::Reflex::Type type_2923c = ::Reflex::ConstBuilder(type_2923);
  ::Reflex::Type type_16586 = ::Reflex::ReferenceBuilder(type_2923c);
  ::Reflex::Type type_2924c = ::Reflex::ConstBuilder(type_2924);
  ::Reflex::Type type_16587 = ::Reflex::ReferenceBuilder(type_2924c);
  ::Reflex::Type type_16824 = ::Reflex::ReferenceBuilder(type_2344);
  ::Reflex::Type type_2344c = ::Reflex::ConstBuilder(type_2344);
  ::Reflex::Type type_16825 = ::Reflex::ReferenceBuilder(type_2344c);
  ::Reflex::Type type_16903 = ::Reflex::PointerBuilder(type_1637);
  ::Reflex::Type type_16904 = ::Reflex::PointerBuilder(type_2613);
  ::Reflex::Type type_16905 = ::Reflex::PointerBuilder(type_1547);
  ::Reflex::Type type_16906 = ::Reflex::PointerBuilder(type_1757);
  ::Reflex::Type type_16907 = ::Reflex::PointerBuilder(type_1354);
  ::Reflex::Type type_16908 = ::Reflex::PointerBuilder(type_2003);
  ::Reflex::Type type_16909 = ::Reflex::PointerBuilder(type_964);
  ::Reflex::Type type_259c = ::Reflex::ConstBuilder(type_259);
  ::Reflex::Type type_15535 = ::Reflex::PointerBuilder(type_259c);
  ::Reflex::Type type_2566 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("UInt_t"), type_194);
  ::Reflex::Type type_1012 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Long_t"), type_177);
  ::Reflex::Type type_16949 = ::Reflex::ReferenceBuilder(type_2704);
  ::Reflex::Type type_2704c = ::Reflex::ConstBuilder(type_2704);
  ::Reflex::Type type_16950 = ::Reflex::ReferenceBuilder(type_2704c);
  ::Reflex::Type type_12158 = ::Reflex::PointerBuilder(type_3010);
  ::Reflex::Type type_3010c = ::Reflex::ConstBuilder(type_3010);
  ::Reflex::Type type_12160 = ::Reflex::PointerBuilder(type_3010c);
  ::Reflex::Type type_12162 = ::Reflex::ReferenceBuilder(type_3010);
  ::Reflex::Type type_12164 = ::Reflex::ReferenceBuilder(type_3010c);
  ::Reflex::Type type_1821 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_32);
  ::Reflex::Type type_715 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("ptrdiff_t"), type_177);
  ::Reflex::Type type_2965c = ::Reflex::ConstBuilder(type_2965);
  ::Reflex::Type type_17288 = ::Reflex::ReferenceBuilder(type_2965c);
  ::Reflex::Type type_3105c = ::Reflex::ConstBuilder(type_3105);
  ::Reflex::Type type_17289 = ::Reflex::ReferenceBuilder(type_3105c);
  ::Reflex::Type type_17290 = ::Reflex::ReferenceBuilder(type_12149);
  ::Reflex::Type type_135c = ::Reflex::ConstBuilder(type_135);
  ::Reflex::Type type_10740 = ::Reflex::ReferenceBuilder(type_135c);
  ::Reflex::Type type_12149c = ::Reflex::ConstBuilder(type_12149);
  ::Reflex::Type type_17291 = ::Reflex::ReferenceBuilder(type_12149c);
  ::Reflex::Type type_12221 = ::Reflex::PointerBuilder(type_3008);
  ::Reflex::Type type_3008c = ::Reflex::ConstBuilder(type_3008);
  ::Reflex::Type type_12223 = ::Reflex::PointerBuilder(type_3008c);
  ::Reflex::Type type_12225 = ::Reflex::ReferenceBuilder(type_3008);
  ::Reflex::Type type_12227 = ::Reflex::ReferenceBuilder(type_3008c);
  ::Reflex::Type type_3103c = ::Reflex::ConstBuilder(type_3103);
  ::Reflex::Type type_17293 = ::Reflex::ReferenceBuilder(type_3103c);
  ::Reflex::Type type_17294 = ::Reflex::ReferenceBuilder(type_12212);
  ::Reflex::Type type_12212c = ::Reflex::ConstBuilder(type_12212);
  ::Reflex::Type type_17295 = ::Reflex::ReferenceBuilder(type_12212c);
  ::Reflex::Type type_12284 = ::Reflex::PointerBuilder(type_3009);
  ::Reflex::Type type_3009c = ::Reflex::ConstBuilder(type_3009);
  ::Reflex::Type type_12286 = ::Reflex::PointerBuilder(type_3009c);
  ::Reflex::Type type_12288 = ::Reflex::ReferenceBuilder(type_3009);
  ::Reflex::Type type_12290 = ::Reflex::ReferenceBuilder(type_3009c);
  ::Reflex::Type type_3104c = ::Reflex::ConstBuilder(type_3104);
  ::Reflex::Type type_17297 = ::Reflex::ReferenceBuilder(type_3104c);
  ::Reflex::Type type_17298 = ::Reflex::ReferenceBuilder(type_12275);
  ::Reflex::Type type_12275c = ::Reflex::ConstBuilder(type_12275);
  ::Reflex::Type type_17299 = ::Reflex::ReferenceBuilder(type_12275c);
  ::Reflex::Type type_12346 = ::Reflex::PointerBuilder(type_3012);
  ::Reflex::Type type_3012c = ::Reflex::ConstBuilder(type_3012);
  ::Reflex::Type type_12348 = ::Reflex::PointerBuilder(type_3012c);
  ::Reflex::Type type_12350 = ::Reflex::ReferenceBuilder(type_3012);
  ::Reflex::Type type_12352 = ::Reflex::ReferenceBuilder(type_3012c);
  ::Reflex::Type type_3107c = ::Reflex::ConstBuilder(type_3107);
  ::Reflex::Type type_17301 = ::Reflex::ReferenceBuilder(type_3107c);
  ::Reflex::Type type_2926c = ::Reflex::ConstBuilder(type_2926);
  ::Reflex::Type type_17302 = ::Reflex::ReferenceBuilder(type_2926c);
  ::Reflex::Type type_17303 = ::Reflex::ReferenceBuilder(type_2926);
  ::Reflex::Type type_11615 = ::Reflex::ReferenceBuilder(type_2776);
  ::Reflex::Type type_2776c = ::Reflex::ConstBuilder(type_2776);
  ::Reflex::Type type_14882 = ::Reflex::ReferenceBuilder(type_2776c);
  ::Reflex::Type type_12408 = ::Reflex::PointerBuilder(type_3016);
  ::Reflex::Type type_3016c = ::Reflex::ConstBuilder(type_3016);
  ::Reflex::Type type_12410 = ::Reflex::PointerBuilder(type_3016c);
  ::Reflex::Type type_12412 = ::Reflex::ReferenceBuilder(type_3016);
  ::Reflex::Type type_12414 = ::Reflex::ReferenceBuilder(type_3016c);
  ::Reflex::Type type_3109c = ::Reflex::ConstBuilder(type_3109);
  ::Reflex::Type type_17305 = ::Reflex::ReferenceBuilder(type_3109c);
  ::Reflex::Type type_2927c = ::Reflex::ConstBuilder(type_2927);
  ::Reflex::Type type_17306 = ::Reflex::ReferenceBuilder(type_2927c);
  ::Reflex::Type type_17307 = ::Reflex::ReferenceBuilder(type_2927);
  ::Reflex::Type type_10867 = ::Reflex::ReferenceBuilder(type_3019);
  ::Reflex::Type type_3019c = ::Reflex::ConstBuilder(type_3019);
  ::Reflex::Type type_10869 = ::Reflex::ReferenceBuilder(type_3019c);
  ::Reflex::Type type_12470 = ::Reflex::PointerBuilder(type_3020);
  ::Reflex::Type type_3020c = ::Reflex::ConstBuilder(type_3020);
  ::Reflex::Type type_12472 = ::Reflex::PointerBuilder(type_3020c);
  ::Reflex::Type type_12474 = ::Reflex::ReferenceBuilder(type_3020);
  ::Reflex::Type type_12476 = ::Reflex::ReferenceBuilder(type_3020c);
  ::Reflex::Type type_3110c = ::Reflex::ConstBuilder(type_3110);
  ::Reflex::Type type_17309 = ::Reflex::ReferenceBuilder(type_3110c);
  ::Reflex::Type type_2928c = ::Reflex::ConstBuilder(type_2928);
  ::Reflex::Type type_17310 = ::Reflex::ReferenceBuilder(type_2928c);
  ::Reflex::Type type_17311 = ::Reflex::ReferenceBuilder(type_2928);
  ::Reflex::Type type_10738 = ::Reflex::ReferenceBuilder(type_135);
  ::Reflex::Type type_12532 = ::Reflex::PointerBuilder(type_3021);
  ::Reflex::Type type_3021c = ::Reflex::ConstBuilder(type_3021);
  ::Reflex::Type type_12534 = ::Reflex::PointerBuilder(type_3021c);
  ::Reflex::Type type_12536 = ::Reflex::ReferenceBuilder(type_3021);
  ::Reflex::Type type_12538 = ::Reflex::ReferenceBuilder(type_3021c);
  ::Reflex::Type type_3111c = ::Reflex::ConstBuilder(type_3111);
  ::Reflex::Type type_17313 = ::Reflex::ReferenceBuilder(type_3111c);
  ::Reflex::Type type_2929c = ::Reflex::ConstBuilder(type_2929);
  ::Reflex::Type type_17314 = ::Reflex::ReferenceBuilder(type_2929c);
  ::Reflex::Type type_17315 = ::Reflex::ReferenceBuilder(type_2929);
  ::Reflex::Type type_10802 = ::Reflex::ReferenceBuilder(type_220);
  ::Reflex::Type type_220c = ::Reflex::ConstBuilder(type_220);
  ::Reflex::Type type_10804 = ::Reflex::ReferenceBuilder(type_220c);
  ::Reflex::Type type_12594 = ::Reflex::PointerBuilder(type_3023);
  ::Reflex::Type type_3023c = ::Reflex::ConstBuilder(type_3023);
  ::Reflex::Type type_12596 = ::Reflex::PointerBuilder(type_3023c);
  ::Reflex::Type type_12598 = ::Reflex::ReferenceBuilder(type_3023);
  ::Reflex::Type type_12600 = ::Reflex::ReferenceBuilder(type_3023c);
  ::Reflex::Type type_3113c = ::Reflex::ConstBuilder(type_3113);
  ::Reflex::Type type_17317 = ::Reflex::ReferenceBuilder(type_3113c);
  ::Reflex::Type type_2930c = ::Reflex::ConstBuilder(type_2930);
  ::Reflex::Type type_17318 = ::Reflex::ReferenceBuilder(type_2930c);
  ::Reflex::Type type_17319 = ::Reflex::ReferenceBuilder(type_2930);
  ::Reflex::Type type_17041 = ::Reflex::ReferenceBuilder(type_2749);
  ::Reflex::Type type_2749c = ::Reflex::ConstBuilder(type_2749);
  ::Reflex::Type type_17040 = ::Reflex::ReferenceBuilder(type_2749c);
  ::Reflex::Type type_12656 = ::Reflex::PointerBuilder(type_3039);
  ::Reflex::Type type_3039c = ::Reflex::ConstBuilder(type_3039);
  ::Reflex::Type type_12658 = ::Reflex::PointerBuilder(type_3039c);
  ::Reflex::Type type_12660 = ::Reflex::ReferenceBuilder(type_3039);
  ::Reflex::Type type_12662 = ::Reflex::ReferenceBuilder(type_3039c);
  ::Reflex::Type type_2966c = ::Reflex::ConstBuilder(type_2966);
  ::Reflex::Type type_17321 = ::Reflex::ReferenceBuilder(type_2966c);
  ::Reflex::Type type_3120c = ::Reflex::ConstBuilder(type_3120);
  ::Reflex::Type type_17322 = ::Reflex::ReferenceBuilder(type_3120c);
  ::Reflex::Type type_2931c = ::Reflex::ConstBuilder(type_2931);
  ::Reflex::Type type_17323 = ::Reflex::ReferenceBuilder(type_2931c);
  ::Reflex::Type type_17324 = ::Reflex::ReferenceBuilder(type_2931);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __TTofpetRun
#undef __TTofpetRun
#endif
class __TTofpetRun : public ::TObject {
  public:
  __TTofpetRun();
  virtual ~__TTofpetRun() throw();
  ::std::vector<std::pair<int,int> > m_pairs;
  ::std::map<std::pair<int,int>,int> m_pairsNevents;
  ::std::vector<int> m_steps1;
  ::std::vector<int> m_steps2;
};
#ifdef __TTofpetEventHeader
#undef __TTofpetEventHeader
#endif
class __TTofpetEventHeader : public ::TEventHeader {
  public:
  __TTofpetEventHeader();
  virtual ~__TTofpetEventHeader() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  int m_step1;
  int m_step2;
};
#ifdef __TTofpetThresholdCalibration
#undef __TTofpetThresholdCalibration
#endif
class __TTofpetThresholdCalibration : public ::TObject {
  public:
  __TTofpetThresholdCalibration();
  virtual ~__TTofpetThresholdCalibration() throw();
  ::std::map<int,TH1D*> m_hRateRaw;
  ::std::map<int,TH1D*> m_hRateDerived;
  ::std::map<int,TGraph*> m_gThr;
  ::std::map<int,TGraph*> m_gRateVsThr;
  ::std::map<int,TH2D*> m_hToTvsThr;
  ::std::map<int,TH1D*> m_hToT;
  ::std::map<int,std::vector<int> > m_transitions;
  ::std::map<int,double> m_rateSinglePhe;
  ::std::map<int,int> m_RawThresholds;
  ::std::map<int,std::pair<int,int> > m_Thresholds;
  ::std::map<int,std::basic_string<char> > m_ThresholdsDate;
  void* m_c_interactive;
  void* m_TTofpetThresholdCalibrationGui;
};
#ifdef __TTofpetSetupHandler
#undef __TTofpetSetupHandler
#endif
class __TTofpetSetupHandler : public ::TRealSetupHandler {
  public:
  __TTofpetSetupHandler();
  virtual ~__TTofpetSetupHandler() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
};
#ifdef __TTofpetThresholdCalibrationGui
#undef __TTofpetThresholdCalibrationGui
#endif
class __TTofpetThresholdCalibrationGui : public ::TGCanvas {
  public:
  __TTofpetThresholdCalibrationGui();
  virtual ~__TTofpetThresholdCalibrationGui() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  void* m_TTofpetThresholdCalibration;
  void* fMain;
  void* fEcanvas;
  void* fNext;
  void* fPrev;
  void* fSave;
  void* fNextAndSave;
  void* fFrame;
  void* fThr;
  void* fCh;
  void* lThr1;
  void* lThr2;
  void* lThr3;
  void* lThr4;
  void* m_canvas;
  int m_curChannel;
  int m_curThr;
};
#ifdef __TTofpetHit
#undef __TTofpetHit
#endif
class __TTofpetHit : public ::TObject {
  public:
  __TTofpetHit();
  virtual ~__TTofpetHit() throw();
  short m_channel;
  short m_xi;
  short m_yi;
  short m_detector;
  unsigned short m_tac;
  double m_channelIdleTime;
  double m_tacIdleTime;
  float m_energy;
  float m_ToT;
  float m_TQT;
  float m_TQE;
  long long m_time;
};
#ifdef __std__map_int_TH2Dp_
#undef __std__map_int_TH2Dp_
#endif
class __std__map_int_TH2Dp_ {
  public:
  __std__map_int_TH2Dp_();
  ::std::_Rb_tree<int,std::pair<const int,TH2D*>,std::_Select1st<std::pair<const int,TH2D*> >,std::less<int>,std::allocator<std::pair<const int,TH2D*> > > _M_t;
};
#ifdef __std__map_int_TGraphp_
#undef __std__map_int_TGraphp_
#endif
class __std__map_int_TGraphp_ {
  public:
  __std__map_int_TGraphp_();
  ::std::_Rb_tree<int,std::pair<const int,TGraph*>,std::_Select1st<std::pair<const int,TGraph*> >,std::less<int>,std::allocator<std::pair<const int,TGraph*> > > _M_t;
};
#ifdef __std__map_int_TH1Dp_
#undef __std__map_int_TH1Dp_
#endif
class __std__map_int_TH1Dp_ {
  public:
  __std__map_int_TH1Dp_();
  ::std::_Rb_tree<int,std::pair<const int,TH1D*>,std::_Select1st<std::pair<const int,TH1D*> >,std::less<int>,std::allocator<std::pair<const int,TH1D*> > > _M_t;
};
#ifdef __std__map_int_std__basic_string_char_s_
#undef __std__map_int_std__basic_string_char_s_
#endif
class __std__map_int_std__basic_string_char_s_ {
  public:
  __std__map_int_std__basic_string_char_s_();
  ::std::_Rb_tree<int,std::pair<const int,std::basic_string<char> >,std::_Select1st<std::pair<const int,std::basic_string<char> > >,std::less<int>,std::allocator<std::pair<const int,std::basic_string<char> > > > _M_t;
};
#ifdef __std__map_int_std__pair_int_int_s_
#undef __std__map_int_std__pair_int_int_s_
#endif
class __std__map_int_std__pair_int_int_s_ {
  public:
  __std__map_int_std__pair_int_int_s_();
  ::std::_Rb_tree<int,std::pair<const int,std::pair<int,int> >,std::_Select1st<std::pair<const int,std::pair<int,int> > >,std::less<int>,std::allocator<std::pair<const int,std::pair<int,int> > > > _M_t;
};
#ifdef __std__map_int_int_
#undef __std__map_int_int_
#endif
class __std__map_int_int_ {
  public:
  __std__map_int_int_();
  ::std::_Rb_tree<int,std::pair<const int,int>,std::_Select1st<std::pair<const int,int> >,std::less<int>,std::allocator<std::pair<const int,int> > > _M_t;
};
#ifdef __std__map_int_double_
#undef __std__map_int_double_
#endif
class __std__map_int_double_ {
  public:
  __std__map_int_double_();
  ::std::_Rb_tree<int,std::pair<const int,double>,std::_Select1st<std::pair<const int,double> >,std::less<int>,std::allocator<std::pair<const int,double> > > _M_t;
};
#ifdef __std__map_int_std__vector_int_s_
#undef __std__map_int_std__vector_int_s_
#endif
class __std__map_int_std__vector_int_s_ {
  public:
  __std__map_int_std__vector_int_s_();
  ::std::_Rb_tree<int,std::pair<const int,std::vector<int> >,std::_Select1st<std::pair<const int,std::vector<int> > >,std::less<int>,std::allocator<std::pair<const int,std::vector<int> > > > _M_t;
};
#ifdef __std__map_std__pair_int_int__int_
#undef __std__map_std__pair_int_int__int_
#endif
class __std__map_std__pair_int_int__int_ {
  public:
  __std__map_std__pair_int_int__int_();
  ::std::_Rb_tree<std::pair<int,int>,std::pair<const std::pair<int,int>,int>,std::_Select1st<std::pair<const std::pair<int,int>,int> >,std::less<std::pair<int,int> >,std::allocator<std::pair<const std::pair<int,int>,int> > > _M_t;
};
}


#endif // __CINT__
namespace {
} // unnamed namespace

#ifndef G__DICTIONARY
# define G__DICTIONARY
#endif
#include "TClass.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "RtypesImp.h"
#include "TIsAProxy.h"
atomic_TClass_ptr TTofpetRun::fgIsA(0);
TClass* ::TTofpetRun::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TTofpetRun");
   }
   return fgIsA;
}
const char * ::TTofpetRun::Class_Name() {return "TTofpetRun";}
void ::TTofpetRun::Dictionary() {}
const char *::TTofpetRun::ImplFileName() {return "";}
int ::TTofpetRun::ImplFileLine() {return 1;}
void ::TTofpetRun::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TTofpetRun::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_pairs", &m_pairs);
   R__insp.InspectMember("std::vector<std::pair<int,int> >", (void*)&m_pairs, "m_pairs.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_pairsNevents", &m_pairsNevents);
   R__insp.InspectMember("std::map<std::pair<int,int>,int>", (void*)&m_pairsNevents, "m_pairsNevents.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_steps1", &m_steps1);
   R__insp.InspectMember("std::vector<int>", (void*)&m_steps1, "m_steps1.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_steps2", &m_steps2);
   R__insp.InspectMember("std::vector<int>", (void*)&m_steps2, "m_steps2.", false);
   TObject::ShowMembers(R__insp);
}
void ::TTofpetRun::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TTofpetRun::Class(),this);
   } else {
      b.WriteClassBuffer(::TTofpetRun::Class(),this);
   }
}

atomic_TClass_ptr TTofpetEventHeader::fgIsA(0);
TClass* ::TTofpetEventHeader::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TTofpetEventHeader");
   }
   return fgIsA;
}
const char * ::TTofpetEventHeader::Class_Name() {return "TTofpetEventHeader";}
void ::TTofpetEventHeader::Dictionary() {}
const char *::TTofpetEventHeader::ImplFileName() {return "";}
int ::TTofpetEventHeader::ImplFileLine() {return 1;}
void ::TTofpetEventHeader::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TTofpetEventHeader::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_step1", &m_step1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_step2", &m_step2);
   TEventHeader::ShowMembers(R__insp);
}
void ::TTofpetEventHeader::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TTofpetEventHeader::Class(),this);
   } else {
      b.WriteClassBuffer(::TTofpetEventHeader::Class(),this);
   }
}

atomic_TClass_ptr TTofpetThresholdCalibration::fgIsA(0);
TClass* ::TTofpetThresholdCalibration::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TTofpetThresholdCalibration");
   }
   return fgIsA;
}
const char * ::TTofpetThresholdCalibration::Class_Name() {return "TTofpetThresholdCalibration";}
void ::TTofpetThresholdCalibration::Dictionary() {}
const char *::TTofpetThresholdCalibration::ImplFileName() {return "";}
int ::TTofpetThresholdCalibration::ImplFileLine() {return 1;}
void ::TTofpetThresholdCalibration::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TTofpetThresholdCalibration::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_hRateRaw", &m_hRateRaw);
   R__insp.InspectMember("std::map<int,TH1D*>", (void*)&m_hRateRaw, "m_hRateRaw.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_hRateDerived", &m_hRateDerived);
   R__insp.InspectMember("std::map<int,TH1D*>", (void*)&m_hRateDerived, "m_hRateDerived.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_gThr", &m_gThr);
   R__insp.InspectMember("std::map<int,TGraph*>", (void*)&m_gThr, "m_gThr.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_gRateVsThr", &m_gRateVsThr);
   R__insp.InspectMember("std::map<int,TGraph*>", (void*)&m_gRateVsThr, "m_gRateVsThr.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_hToTvsThr", &m_hToTvsThr);
   R__insp.InspectMember("std::map<int,TH2D*>", (void*)&m_hToTvsThr, "m_hToTvsThr.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_hToT", &m_hToT);
   R__insp.InspectMember("std::map<int,TH1D*>", (void*)&m_hToT, "m_hToT.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_transitions", &m_transitions);
   R__insp.InspectMember("std::map<int,std::vector<int> >", (void*)&m_transitions, "m_transitions.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_rateSinglePhe", &m_rateSinglePhe);
   R__insp.InspectMember("std::map<int,double>", (void*)&m_rateSinglePhe, "m_rateSinglePhe.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_RawThresholds", &m_RawThresholds);
   R__insp.InspectMember("std::map<int,int>", (void*)&m_RawThresholds, "m_RawThresholds.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Thresholds", &m_Thresholds);
   R__insp.InspectMember("std::map<int,std::pair<int,int> >", (void*)&m_Thresholds, "m_Thresholds.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_ThresholdsDate", &m_ThresholdsDate);
   R__insp.InspectMember("std::map<int,std::basic_string<char> >", (void*)&m_ThresholdsDate, "m_ThresholdsDate.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_c_interactive", &m_c_interactive);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_TTofpetThresholdCalibrationGui", &m_TTofpetThresholdCalibrationGui);
   TObject::ShowMembers(R__insp);
}
void ::TTofpetThresholdCalibration::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TTofpetThresholdCalibration::Class(),this);
   } else {
      b.WriteClassBuffer(::TTofpetThresholdCalibration::Class(),this);
   }
}

atomic_TClass_ptr TTofpetSetupHandler::fgIsA(0);
TClass* ::TTofpetSetupHandler::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TTofpetSetupHandler");
   }
   return fgIsA;
}
const char * ::TTofpetSetupHandler::Class_Name() {return "TTofpetSetupHandler";}
void ::TTofpetSetupHandler::Dictionary() {}
const char *::TTofpetSetupHandler::ImplFileName() {return "";}
int ::TTofpetSetupHandler::ImplFileLine() {return 1;}
void ::TTofpetSetupHandler::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TTofpetSetupHandler::IsA();
   if (R__cl || R__insp.IsA()) { }
   TRealSetupHandler::ShowMembers(R__insp);
}
void ::TTofpetSetupHandler::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TTofpetSetupHandler::Class(),this);
   } else {
      b.WriteClassBuffer(::TTofpetSetupHandler::Class(),this);
   }
}

atomic_TClass_ptr TTofpetThresholdCalibrationGui::fgIsA(0);
TClass* ::TTofpetThresholdCalibrationGui::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TTofpetThresholdCalibrationGui");
   }
   return fgIsA;
}
const char * ::TTofpetThresholdCalibrationGui::Class_Name() {return "TTofpetThresholdCalibrationGui";}
void ::TTofpetThresholdCalibrationGui::Dictionary() {}
const char *::TTofpetThresholdCalibrationGui::ImplFileName() {return "";}
int ::TTofpetThresholdCalibrationGui::ImplFileLine() {return 1;}
void ::TTofpetThresholdCalibrationGui::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TTofpetThresholdCalibrationGui::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_TTofpetThresholdCalibration", &m_TTofpetThresholdCalibration);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*fMain", &fMain);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*fEcanvas", &fEcanvas);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*fNext", &fNext);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*fPrev", &fPrev);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*fSave", &fSave);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*fNextAndSave", &fNextAndSave);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*fFrame", &fFrame);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*fThr", &fThr);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*fCh", &fCh);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*lThr1", &lThr1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*lThr2", &lThr2);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*lThr3", &lThr3);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*lThr4", &lThr4);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_canvas", &m_canvas);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_curChannel", &m_curChannel);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_curThr", &m_curThr);
   TGCanvas::ShowMembers(R__insp);
}
void ::TTofpetThresholdCalibrationGui::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TTofpetThresholdCalibrationGui::Class(),this);
   } else {
      b.WriteClassBuffer(::TTofpetThresholdCalibrationGui::Class(),this);
   }
}

atomic_TClass_ptr TTofpetHit::fgIsA(0);
TClass* ::TTofpetHit::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TTofpetHit");
   }
   return fgIsA;
}
const char * ::TTofpetHit::Class_Name() {return "TTofpetHit";}
void ::TTofpetHit::Dictionary() {}
const char *::TTofpetHit::ImplFileName() {return "";}
int ::TTofpetHit::ImplFileLine() {return 1;}
void ::TTofpetHit::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TTofpetHit::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_channel", &m_channel);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_xi", &m_xi);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_yi", &m_yi);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_detector", &m_detector);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_tac", &m_tac);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_channelIdleTime", &m_channelIdleTime);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_tacIdleTime", &m_tacIdleTime);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_energy", &m_energy);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_ToT", &m_ToT);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_TQT", &m_TQT);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_TQE", &m_TQE);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_time", &m_time);
   TObject::ShowMembers(R__insp);
}
void ::TTofpetHit::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TTofpetHit::Class(),this);
   } else {
      b.WriteClassBuffer(::TTofpetHit::Class(),this);
   }
}


namespace {
//------Stub functions for class TTofpetRun -------------------------------
static  void operator_4766( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TTofpetRun*)o)->operator=)(*(const ::TTofpetRun*)arg[0]);
  else   (((::TTofpetRun*)o)->operator=)(*(const ::TTofpetRun*)arg[0]);
}

static void constructor_4767( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetRun(*(const ::TTofpetRun*)arg[0]);
  else ::new(mem) ::TTofpetRun(*(const ::TTofpetRun*)arg[0]);
}

static void constructor_4768( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetRun();
  else ::new(mem) ::TTofpetRun();
}

static  void method_4769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetRun*)o)->getNsteps)());
  else   (((const ::TTofpetRun*)o)->getNsteps)();
}

static  void method_4770( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetRun*)o)->getNsteps1)());
  else   (((const ::TTofpetRun*)o)->getNsteps1)();
}

static  void method_4771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetRun*)o)->getNsteps2)());
  else   (((const ::TTofpetRun*)o)->getNsteps2)();
}

static  void method_4772( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::TTofpetRun*)o)->addPair)(*(int*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::TTofpetRun*)o)->addPair)(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
  }
}

static  void method_4773( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<int,int>)((((const ::TTofpetRun*)o)->getPair)(*(int*)arg[0]));
  else   (((const ::TTofpetRun*)o)->getPair)(*(int*)arg[0]);
}

static  void method_4774( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetRun*)o)->getStep1)(*(int*)arg[0]));
  else   (((const ::TTofpetRun*)o)->getStep1)(*(int*)arg[0]);
}

static  void method_4775( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetRun*)o)->getStep2)(*(int*)arg[0]));
  else   (((const ::TTofpetRun*)o)->getStep2)(*(int*)arg[0]);
}

static  void method_4776( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetRun*)o)->getStepID)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TTofpetRun*)o)->getStepID)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_4777( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetRun*)o)->getStep1ID)(*(int*)arg[0]));
  else   (((const ::TTofpetRun*)o)->getStep1ID)(*(int*)arg[0]);
}

static  void method_4778( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetRun*)o)->getStepNevents)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TTofpetRun*)o)->getStepNevents)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_4779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetRun*)o)->Class)());
  else   (((::TTofpetRun*)o)->Class)();
}

static  void method_4780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetRun*)o)->Class_Name)());
  else   (((::TTofpetRun*)o)->Class_Name)();
}

static  void method_4781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TTofpetRun*)o)->Class_Version)());
  else   (((::TTofpetRun*)o)->Class_Version)();
}

static  void method_4782( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetRun*)o)->Dictionary)();
}

static  void method_4783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetRun*)o)->IsA)());
  else   (((const ::TTofpetRun*)o)->IsA)();
}

static  void method_4784( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetRun*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4785( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetRun*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4786( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetRun*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetRun*)o)->DeclFileName)());
  else   (((::TTofpetRun*)o)->DeclFileName)();
}

static  void method_4788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetRun*)o)->ImplFileLine)());
  else   (((::TTofpetRun*)o)->ImplFileLine)();
}

static  void method_4789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetRun*)o)->ImplFileName)());
  else   (((::TTofpetRun*)o)->ImplFileName)();
}

static  void method_4790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetRun*)o)->DeclFileLine)());
  else   (((::TTofpetRun*)o)->DeclFileLine)();
}

static void destructor_4791(void*, void * o, const std::vector<void*>&, void *) {
((::TTofpetRun*)o)->::TTofpetRun::~TTofpetRun();
}
static void method_newdel_300( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TTofpetRun >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TTofpetRun >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TTofpetRun >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TTofpetRun >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TTofpetRun >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TTofpetRun,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TTofpetRun -------------------------------
void __TTofpetRun_db_datamem(Reflex::Class*);
void __TTofpetRun_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TTofpetRun_datamem_bld(&__TTofpetRun_db_datamem);
Reflex::GenreflexMemberBuilder __TTofpetRun_funcmem_bld(&__TTofpetRun_db_funcmem);
void __TTofpetRun_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TTofpetRun"), typeid(::TTofpetRun), sizeof(::TTofpetRun), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TTofpetRun::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2105, ::Reflex::BaseOffset< ::TTofpetRun, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15621, type_15622), Reflex::Literal("operator="), operator_4766, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15622), Reflex::Literal("TTofpetRun"), constructor_4767, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TTofpetRun"), constructor_4768, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TTofpetRun"), destructor_4791, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_300, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TTofpetRun_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TTofpetRun_funcmem_bld);
}

//------Delayed data member builder for class TTofpetRun -------------------
void __TTofpetRun_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2752, Reflex::Literal("m_pairs"), OffsetOf(__shadow__::__TTofpetRun, m_pairs), ::Reflex::PRIVATE)
  .AddDataMember(type_2931, Reflex::Literal("m_pairsNevents"), OffsetOf(__shadow__::__TTofpetRun, m_pairsNevents), ::Reflex::PRIVATE)
  .AddDataMember(type_2749, Reflex::Literal("m_steps1"), OffsetOf(__shadow__::__TTofpetRun, m_steps1), ::Reflex::PRIVATE)
  .AddDataMember(type_2749, Reflex::Literal("m_steps2"), OffsetOf(__shadow__::__TTofpetRun, m_steps2), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TTofpetRun -------------------
void __TTofpetRun_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("getNsteps"), method_4769, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("getNsteps1"), method_4770, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("getNsteps2"), method_4771, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_135, type_135, type_135), Reflex::Literal("addPair"), method_4772, 0, "step1;step2;N=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3019, type_135), Reflex::Literal("getPair"), method_4773, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135), Reflex::Literal("getStep1"), method_4774, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135), Reflex::Literal("getStep2"), method_4775, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135, type_135), Reflex::Literal("getStepID"), method_4776, 0, "step1;step2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135), Reflex::Literal("getStep1ID"), method_4777, 0, "step1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135, type_135), Reflex::Literal("getStepNevents"), method_4778, 0, "step1;step2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_744), Reflex::Literal("Class"), method_4779, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3361), Reflex::Literal("Class_Name"), method_4780, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2386), Reflex::Literal("Class_Version"), method_4781, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("Dictionary"), method_4782, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_744), Reflex::Literal("IsA"), method_4783, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_15486), Reflex::Literal("ShowMembers"), method_4784, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_4973), Reflex::Literal("Streamer"), method_4785, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_4973), Reflex::Literal("StreamerNVirtual"), method_4786, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3361), Reflex::Literal("DeclFileName"), method_4787, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("ImplFileLine"), method_4788, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3361), Reflex::Literal("ImplFileName"), method_4789, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("DeclFileLine"), method_4790, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TTofpetEventHeader -------------------------------
static  void operator_6427( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TTofpetEventHeader*)o)->operator=)(*(const ::TTofpetEventHeader*)arg[0]);
  else   (((::TTofpetEventHeader*)o)->operator=)(*(const ::TTofpetEventHeader*)arg[0]);
}

static void constructor_6428( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetEventHeader(*(const ::TTofpetEventHeader*)arg[0]);
  else ::new(mem) ::TTofpetEventHeader(*(const ::TTofpetEventHeader*)arg[0]);
}

static void constructor_6429( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetEventHeader();
  else ::new(mem) ::TTofpetEventHeader();
}

static void destructor_6430(void*, void * o, const std::vector<void*>&, void *) {
((::TTofpetEventHeader*)o)->::TTofpetEventHeader::~TTofpetEventHeader();
}
static  void method_6431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetEventHeader*)o)->getStep1)());
  else   (((const ::TTofpetEventHeader*)o)->getStep1)();
}

static  void method_6432( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetEventHeader*)o)->setStep1)(*(int*)arg[0]);
}

static  void method_6433( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetEventHeader*)o)->getStep2)());
  else   (((const ::TTofpetEventHeader*)o)->getStep2)();
}

static  void method_6434( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetEventHeader*)o)->setStep2)(*(int*)arg[0]);
}

static  void method_6435( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetEventHeader*)o)->Class)());
  else   (((::TTofpetEventHeader*)o)->Class)();
}

static  void method_6436( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetEventHeader*)o)->Class_Name)());
  else   (((::TTofpetEventHeader*)o)->Class_Name)();
}

static  void method_6437( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TTofpetEventHeader*)o)->Class_Version)());
  else   (((::TTofpetEventHeader*)o)->Class_Version)();
}

static  void method_6438( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetEventHeader*)o)->Dictionary)();
}

static  void method_6439( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetEventHeader*)o)->IsA)());
  else   (((const ::TTofpetEventHeader*)o)->IsA)();
}

static  void method_6440( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetEventHeader*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_6441( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetEventHeader*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_6442( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetEventHeader*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_6443( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetEventHeader*)o)->DeclFileName)());
  else   (((::TTofpetEventHeader*)o)->DeclFileName)();
}

static  void method_6444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetEventHeader*)o)->ImplFileLine)());
  else   (((::TTofpetEventHeader*)o)->ImplFileLine)();
}

static  void method_6445( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetEventHeader*)o)->ImplFileName)());
  else   (((::TTofpetEventHeader*)o)->ImplFileName)();
}

static  void method_6446( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetEventHeader*)o)->DeclFileLine)());
  else   (((::TTofpetEventHeader*)o)->DeclFileLine)();
}

static void method_newdel_1096( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TTofpetEventHeader >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TTofpetEventHeader >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TTofpetEventHeader >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TTofpetEventHeader >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TTofpetEventHeader >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TEventHeader")), ::Reflex::BaseOffset< ::TTofpetEventHeader,::TEventHeader >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TTofpetEventHeader,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TTofpetEventHeader -------------------------------
void __TTofpetEventHeader_db_datamem(Reflex::Class*);
void __TTofpetEventHeader_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TTofpetEventHeader_datamem_bld(&__TTofpetEventHeader_db_datamem);
Reflex::GenreflexMemberBuilder __TTofpetEventHeader_funcmem_bld(&__TTofpetEventHeader_db_funcmem);
void __TTofpetEventHeader_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TTofpetEventHeader"), typeid(::TTofpetEventHeader), sizeof(::TTofpetEventHeader), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TTofpetEventHeader::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1151, ::Reflex::BaseOffset< ::TTofpetEventHeader, ::TEventHeader >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15824, type_15825), Reflex::Literal("operator="), operator_6427, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15825), Reflex::Literal("TTofpetEventHeader"), constructor_6428, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TTofpetEventHeader"), constructor_6429, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TTofpetEventHeader"), destructor_6430, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1096, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TTofpetEventHeader_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TTofpetEventHeader_funcmem_bld);
}

//------Delayed data member builder for class TTofpetEventHeader -------------------
void __TTofpetEventHeader_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_135, Reflex::Literal("m_step1"), OffsetOf(__shadow__::__TTofpetEventHeader, m_step1), ::Reflex::PRIVATE)
  .AddDataMember(type_135, Reflex::Literal("m_step2"), OffsetOf(__shadow__::__TTofpetEventHeader, m_step2), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TTofpetEventHeader -------------------
void __TTofpetEventHeader_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("getStep1"), method_6431, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_135), Reflex::Literal("setStep1"), method_6432, 0, "step1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("getStep2"), method_6433, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_135), Reflex::Literal("setStep2"), method_6434, 0, "step2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_744), Reflex::Literal("Class"), method_6435, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3361), Reflex::Literal("Class_Name"), method_6436, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2386), Reflex::Literal("Class_Version"), method_6437, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("Dictionary"), method_6438, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_744), Reflex::Literal("IsA"), method_6439, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_15486), Reflex::Literal("ShowMembers"), method_6440, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_4973), Reflex::Literal("Streamer"), method_6441, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_4973), Reflex::Literal("StreamerNVirtual"), method_6442, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3361), Reflex::Literal("DeclFileName"), method_6443, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("ImplFileLine"), method_6444, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3361), Reflex::Literal("ImplFileName"), method_6445, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("DeclFileLine"), method_6446, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TTofpetThresholdCalibration -------------------------------
static  void operator_7311( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TTofpetThresholdCalibration*)o)->operator=)(*(const ::TTofpetThresholdCalibration*)arg[0]);
  else   (((::TTofpetThresholdCalibration*)o)->operator=)(*(const ::TTofpetThresholdCalibration*)arg[0]);
}

static void constructor_7312( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetThresholdCalibration(*(const ::TTofpetThresholdCalibration*)arg[0]);
  else ::new(mem) ::TTofpetThresholdCalibration(*(const ::TTofpetThresholdCalibration*)arg[0]);
}

static void constructor_7313( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetThresholdCalibration();
  else ::new(mem) ::TTofpetThresholdCalibration();
}

static void destructor_7314(void*, void * o, const std::vector<void*>&, void *) {
((::TTofpetThresholdCalibration*)o)->::TTofpetThresholdCalibration::~TTofpetThresholdCalibration();
}
static  void method_7318( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibration*)o)->addhRateRaw)(*(int*)arg[0],
    (::TH1D*)arg[1]));
  else   (((::TTofpetThresholdCalibration*)o)->addhRateRaw)(*(int*)arg[0],
    (::TH1D*)arg[1]);
}

static  void method_7319( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibration*)o)->addhRateDerived)(*(int*)arg[0],
    (::TH1D*)arg[1]));
  else   (((::TTofpetThresholdCalibration*)o)->addhRateDerived)(*(int*)arg[0],
    (::TH1D*)arg[1]);
}

static  void method_7320( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibration*)o)->addgThr)(*(int*)arg[0],
    (::TGraph*)arg[1]));
  else   (((::TTofpetThresholdCalibration*)o)->addgThr)(*(int*)arg[0],
    (::TGraph*)arg[1]);
}

static  void method_7321( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibration*)o)->addgRateVsThr)(*(int*)arg[0],
    (::TGraph*)arg[1]));
  else   (((::TTofpetThresholdCalibration*)o)->addgRateVsThr)(*(int*)arg[0],
    (::TGraph*)arg[1]);
}

static  void method_7322( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibration*)o)->addhToT)(*(int*)arg[0],
    (::TH1D*)arg[1]));
  else   (((::TTofpetThresholdCalibration*)o)->addhToT)(*(int*)arg[0],
    (::TH1D*)arg[1]);
}

static  void method_7323( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibration*)o)->addhToTvsThr)(*(int*)arg[0],
    (::TH2D*)arg[1]));
  else   (((::TTofpetThresholdCalibration*)o)->addhToTvsThr)(*(int*)arg[0],
    (::TH2D*)arg[1]);
}

static  void method_7327( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetThresholdCalibration*)o)->gethRateRaw)(*(int*)arg[0]));
  else   (((const ::TTofpetThresholdCalibration*)o)->gethRateRaw)(*(int*)arg[0]);
}

static  void method_7328( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetThresholdCalibration*)o)->gethRateDerived)(*(int*)arg[0]));
  else   (((const ::TTofpetThresholdCalibration*)o)->gethRateDerived)(*(int*)arg[0]);
}

static  void method_7329( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetThresholdCalibration*)o)->getgThr)(*(int*)arg[0]));
  else   (((const ::TTofpetThresholdCalibration*)o)->getgThr)(*(int*)arg[0]);
}

static  void method_7330( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetThresholdCalibration*)o)->getgRateVsThr)(*(int*)arg[0]));
  else   (((const ::TTofpetThresholdCalibration*)o)->getgRateVsThr)(*(int*)arg[0]);
}

static  void method_7331( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetThresholdCalibration*)o)->gethToTvsThr)(*(int*)arg[0]));
  else   (((const ::TTofpetThresholdCalibration*)o)->gethToTvsThr)(*(int*)arg[0]);
}

static  void method_7332( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetThresholdCalibration*)o)->gethToT)(*(int*)arg[0]));
  else   (((const ::TTofpetThresholdCalibration*)o)->gethToT)(*(int*)arg[0]);
}

static  void method_7335( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::TTofpetThresholdCalibration*)o)->printhRateRaw)();
}

static  void method_7336( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::TTofpetThresholdCalibration*)o)->printhRateDerived)();
}

static  void method_7337( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::TTofpetThresholdCalibration*)o)->printgThr)();
}

static  void method_7338( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetThresholdCalibration*)o)->computeRateDerived)(*(int*)arg[0]);
}

static  void method_7339( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetThresholdCalibration*)o)->computeThresholds)(*(int*)arg[0]);
}

static  void method_7340( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetThresholdCalibration*)o)->getNtransitions)(*(int*)arg[0]));
  else   (((const ::TTofpetThresholdCalibration*)o)->getNtransitions)(*(int*)arg[0]);
}

static  void method_7341( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetThresholdCalibration*)o)->getTransition)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TTofpetThresholdCalibration*)o)->getTransition)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_7342( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TTofpetThresholdCalibration*)o)->printTransitions)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_7343( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::TTofpetThresholdCalibration*)o)->hasFinalThreshold)(*(int*)arg[0]));
  else   (((const ::TTofpetThresholdCalibration*)o)->hasFinalThreshold)(*(int*)arg[0]);
}

static  void method_7344( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (int)((((const ::TTofpetThresholdCalibration*)o)->getThreshold)(*(int*)arg[0]));
    else     (((const ::TTofpetThresholdCalibration*)o)->getThreshold)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (int)((((const ::TTofpetThresholdCalibration*)o)->getThreshold)(*(int*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::TTofpetThresholdCalibration*)o)->getThreshold)(*(int*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_7345( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::TTofpetThresholdCalibration*)o)->setThreshold)(*(int*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::TTofpetThresholdCalibration*)o)->setThreshold)(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
  }
}

static  void method_7346( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::TTofpetThresholdCalibration*)o)->dumpThresholds)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::TTofpetThresholdCalibration*)o)->dumpThresholds)(*(::std::string*)arg[0]);
  }
}

static  void method_7347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibration*)o)->getChannels)());
  else   (((::TTofpetThresholdCalibration*)o)->getChannels)();
}

static  void method_7348( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetThresholdCalibration*)o)->computeThresholdFromRateTransitions)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TTofpetThresholdCalibration*)o)->computeThresholdFromRateTransitions)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_7349( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TTofpetThresholdCalibration*)o)->printThresholds)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_7350( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetThresholdCalibration*)o)->getDAQRunThreshold)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TTofpetThresholdCalibration*)o)->getDAQRunThreshold)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_7351( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetThresholdCalibration*)o)->getInteractiveCanvas)(*(int*)arg[0]));
  else   (((::TTofpetThresholdCalibration*)o)->getInteractiveCanvas)(*(int*)arg[0]);
}

static  void method_7352( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibration*)o)->decideThresholdDummy)(*(int*)arg[0]));
  else   (((::TTofpetThresholdCalibration*)o)->decideThresholdDummy)(*(int*)arg[0]);
}

static  void method_7353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibration*)o)->decideThresholds)());
  else   (((::TTofpetThresholdCalibration*)o)->decideThresholds)();
}

static  void method_7354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetThresholdCalibration*)o)->Class)());
  else   (((::TTofpetThresholdCalibration*)o)->Class)();
}

static  void method_7355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetThresholdCalibration*)o)->Class_Name)());
  else   (((::TTofpetThresholdCalibration*)o)->Class_Name)();
}

static  void method_7356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TTofpetThresholdCalibration*)o)->Class_Version)());
  else   (((::TTofpetThresholdCalibration*)o)->Class_Version)();
}

static  void method_7357( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetThresholdCalibration*)o)->Dictionary)();
}

static  void method_7358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetThresholdCalibration*)o)->IsA)());
  else   (((const ::TTofpetThresholdCalibration*)o)->IsA)();
}

static  void method_7359( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetThresholdCalibration*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_7360( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetThresholdCalibration*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_7361( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetThresholdCalibration*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_7362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetThresholdCalibration*)o)->DeclFileName)());
  else   (((::TTofpetThresholdCalibration*)o)->DeclFileName)();
}

static  void method_7363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibration*)o)->ImplFileLine)());
  else   (((::TTofpetThresholdCalibration*)o)->ImplFileLine)();
}

static  void method_7364( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetThresholdCalibration*)o)->ImplFileName)());
  else   (((::TTofpetThresholdCalibration*)o)->ImplFileName)();
}

static  void method_7365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibration*)o)->DeclFileLine)());
  else   (((::TTofpetThresholdCalibration*)o)->DeclFileLine)();
}

static  void method_7315( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibration*)o)->addObject<TH2D>)(*(int*)arg[0],
    (::TH2D*)arg[1],
    *(::std::map<int,TH2D*>*)arg[2]));
  else   (((::TTofpetThresholdCalibration*)o)->addObject<TH2D>)(*(int*)arg[0],
    (::TH2D*)arg[1],
    *(::std::map<int,TH2D*>*)arg[2]);
}

static  void method_7316( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibration*)o)->addObject<TH1D>)(*(int*)arg[0],
    (::TH1D*)arg[1],
    *(::std::map<int,TH1D*>*)arg[2]));
  else   (((::TTofpetThresholdCalibration*)o)->addObject<TH1D>)(*(int*)arg[0],
    (::TH1D*)arg[1],
    *(::std::map<int,TH1D*>*)arg[2]);
}

static  void method_7317( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibration*)o)->addObject<TGraph>)(*(int*)arg[0],
    (::TGraph*)arg[1],
    *(::std::map<int,TGraph*>*)arg[2]));
  else   (((::TTofpetThresholdCalibration*)o)->addObject<TGraph>)(*(int*)arg[0],
    (::TGraph*)arg[1],
    *(::std::map<int,TGraph*>*)arg[2]);
}

static  void method_7324( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetThresholdCalibration*)o)->getObject<TH1D>)(*(int*)arg[0],
    *(const ::std::map<int,TH1D*>*)arg[1]));
  else   (((const ::TTofpetThresholdCalibration*)o)->getObject<TH1D>)(*(int*)arg[0],
    *(const ::std::map<int,TH1D*>*)arg[1]);
}

static  void method_7325( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetThresholdCalibration*)o)->getObject<TH2D>)(*(int*)arg[0],
    *(const ::std::map<int,TH2D*>*)arg[1]));
  else   (((const ::TTofpetThresholdCalibration*)o)->getObject<TH2D>)(*(int*)arg[0],
    *(const ::std::map<int,TH2D*>*)arg[1]);
}

static  void method_7326( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetThresholdCalibration*)o)->getObject<TGraph>)(*(int*)arg[0],
    *(const ::std::map<int,TGraph*>*)arg[1]));
  else   (((const ::TTofpetThresholdCalibration*)o)->getObject<TGraph>)(*(int*)arg[0],
    *(const ::std::map<int,TGraph*>*)arg[1]);
}

static  void method_7333( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TTofpetThresholdCalibration*)o)->printObject<TGraph>)(*(const ::std::map<int,TGraph*>*)arg[0]);
}

static  void method_7334( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TTofpetThresholdCalibration*)o)->printObject<TH1D>)(*(const ::std::map<int,TH1D*>*)arg[0]);
}

static void method_newdel_1637( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TTofpetThresholdCalibration >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TTofpetThresholdCalibration >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TTofpetThresholdCalibration >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TTofpetThresholdCalibration >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TTofpetThresholdCalibration >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TTofpetThresholdCalibration,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TTofpetThresholdCalibration -------------------------------
void __TTofpetThresholdCalibration_db_datamem(Reflex::Class*);
void __TTofpetThresholdCalibration_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TTofpetThresholdCalibration_datamem_bld(&__TTofpetThresholdCalibration_db_datamem);
Reflex::GenreflexMemberBuilder __TTofpetThresholdCalibration_funcmem_bld(&__TTofpetThresholdCalibration_db_funcmem);
void __TTofpetThresholdCalibration_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TTofpetThresholdCalibration"), typeid(::TTofpetThresholdCalibration), sizeof(::TTofpetThresholdCalibration), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TTofpetThresholdCalibration::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2105, ::Reflex::BaseOffset< ::TTofpetThresholdCalibration, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16580, type_16581), Reflex::Literal("operator="), operator_7311, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16581), Reflex::Literal("TTofpetThresholdCalibration"), constructor_7312, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TTofpetThresholdCalibration"), constructor_7313, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TTofpetThresholdCalibration"), destructor_7314, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1637, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TTofpetThresholdCalibration_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TTofpetThresholdCalibration_funcmem_bld);
}

//------Delayed data member builder for class TTofpetThresholdCalibration -------------------
void __TTofpetThresholdCalibration_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2925, Reflex::Literal("m_hRateRaw"), OffsetOf(__shadow__::__TTofpetThresholdCalibration, m_hRateRaw), ::Reflex::PRIVATE)
  .AddDataMember(type_2925, Reflex::Literal("m_hRateDerived"), OffsetOf(__shadow__::__TTofpetThresholdCalibration, m_hRateDerived), ::Reflex::PRIVATE)
  .AddDataMember(type_2924, Reflex::Literal("m_gThr"), OffsetOf(__shadow__::__TTofpetThresholdCalibration, m_gThr), ::Reflex::PRIVATE)
  .AddDataMember(type_2924, Reflex::Literal("m_gRateVsThr"), OffsetOf(__shadow__::__TTofpetThresholdCalibration, m_gRateVsThr), ::Reflex::PRIVATE)
  .AddDataMember(type_2923, Reflex::Literal("m_hToTvsThr"), OffsetOf(__shadow__::__TTofpetThresholdCalibration, m_hToTvsThr), ::Reflex::PRIVATE)
  .AddDataMember(type_2925, Reflex::Literal("m_hToT"), OffsetOf(__shadow__::__TTofpetThresholdCalibration, m_hToT), ::Reflex::PRIVATE)
  .AddDataMember(type_2930, Reflex::Literal("m_transitions"), OffsetOf(__shadow__::__TTofpetThresholdCalibration, m_transitions), ::Reflex::PRIVATE)
  .AddDataMember(type_2929, Reflex::Literal("m_rateSinglePhe"), OffsetOf(__shadow__::__TTofpetThresholdCalibration, m_rateSinglePhe), ::Reflex::PRIVATE)
  .AddDataMember(type_2928, Reflex::Literal("m_RawThresholds"), OffsetOf(__shadow__::__TTofpetThresholdCalibration, m_RawThresholds), ::Reflex::PRIVATE)
  .AddDataMember(type_2927, Reflex::Literal("m_Thresholds"), OffsetOf(__shadow__::__TTofpetThresholdCalibration, m_Thresholds), ::Reflex::PRIVATE)
  .AddDataMember(type_2926, Reflex::Literal("m_ThresholdsDate"), OffsetOf(__shadow__::__TTofpetThresholdCalibration, m_ThresholdsDate), ::Reflex::PRIVATE)
  .AddDataMember(type_15488, Reflex::Literal("m_c_interactive"), OffsetOf(__shadow__::__TTofpetThresholdCalibration, m_c_interactive), ::Reflex::PRIVATE)
  .AddDataMember(type_16579, Reflex::Literal("m_TTofpetThresholdCalibrationGui"), OffsetOf(__shadow__::__TTofpetThresholdCalibration, m_TTofpetThresholdCalibrationGui), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class TTofpetThresholdCalibration -------------------
void __TTofpetThresholdCalibration_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135, type_12275), Reflex::Literal("addhRateRaw"), method_7318, 0, "ch;h", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135, type_12275), Reflex::Literal("addhRateDerived"), method_7319, 0, "ch;h", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135, type_12212), Reflex::Literal("addgThr"), method_7320, 0, "ch;g", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135, type_12212), Reflex::Literal("addgRateVsThr"), method_7321, 0, "ch;g", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135, type_12275), Reflex::Literal("addhToT"), method_7322, 0, "ch;h", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135, type_12149), Reflex::Literal("addhToTvsThr"), method_7323, 0, "ch;h", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12275, type_135), Reflex::Literal("gethRateRaw"), method_7327, 0, "ch", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12275, type_135), Reflex::Literal("gethRateDerived"), method_7328, 0, "ch", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12212, type_135), Reflex::Literal("getgThr"), method_7329, 0, "ch", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12212, type_135), Reflex::Literal("getgRateVsThr"), method_7330, 0, "ch", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12149, type_135), Reflex::Literal("gethToTvsThr"), method_7331, 0, "ch", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12275, type_135), Reflex::Literal("gethToT"), method_7332, 0, "ch", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("printhRateRaw"), method_7335, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("printhRateDerived"), method_7336, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("printgThr"), method_7337, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_135), Reflex::Literal("computeRateDerived"), method_7338, 0, "ch", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_135), Reflex::Literal("computeThresholds"), method_7339, 0, "ch", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135), Reflex::Literal("getNtransitions"), method_7340, 0, "ch", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135, type_135), Reflex::Literal("getTransition"), method_7341, 0, "ch;nphe", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_135, type_135), Reflex::Literal("printTransitions"), method_7342, 0, "nphe1;nphe2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_617, type_135), Reflex::Literal("hasFinalThreshold"), method_7343, 0, "ch", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135, type_617), Reflex::Literal("getThreshold"), method_7344, 0, "ch;forceRaw=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_135, type_135, type_135), Reflex::Literal("setThreshold"), method_7345, 0, "ch;thr;nphe=2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2786), Reflex::Literal("dumpThresholds"), method_7346, 0, "fname=\"thr.dat\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("getChannels"), method_7347, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135, type_135), Reflex::Literal("computeThresholdFromRateTransitions"), method_7348, 0, "ch;nphe", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_135, type_135), Reflex::Literal("printThresholds"), method_7349, 0, "nphe1;nphe2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135, type_135), Reflex::Literal("getDAQRunThreshold"), method_7350, 0, "ch;step2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15725, type_135), Reflex::Literal("getInteractiveCanvas"), method_7351, 0, "ch", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135), Reflex::Literal("decideThresholdDummy"), method_7352, 0, "ch", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("decideThresholds"), method_7353, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_744), Reflex::Literal("Class"), method_7354, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3361), Reflex::Literal("Class_Name"), method_7355, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2386), Reflex::Literal("Class_Version"), method_7356, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("Dictionary"), method_7357, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_744), Reflex::Literal("IsA"), method_7358, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_15486), Reflex::Literal("ShowMembers"), method_7359, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_4973), Reflex::Literal("Streamer"), method_7360, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_4973), Reflex::Literal("StreamerNVirtual"), method_7361, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3361), Reflex::Literal("DeclFileName"), method_7362, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("ImplFileLine"), method_7363, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3361), Reflex::Literal("ImplFileName"), method_7364, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("DeclFileLine"), method_7365, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135, type_12149, type_16582), Reflex::Literal("addObject<TH2D>"), method_7315, 0, "ch;obj;map", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135, type_12275, type_16583), Reflex::Literal("addObject<TH1D>"), method_7316, 0, "ch;obj;map", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135, type_135, type_12212, type_16584), Reflex::Literal("addObject<TGraph>"), method_7317, 0, "ch;obj;map", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12275, type_135, type_16585), Reflex::Literal("getObject<TH1D>"), method_7324, 0, "ch;map", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12149, type_135, type_16586), Reflex::Literal("getObject<TH2D>"), method_7325, 0, "ch;map", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12212, type_135, type_16587), Reflex::Literal("getObject<TGraph>"), method_7326, 0, "ch;map", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_16587), Reflex::Literal("printObject<TGraph>"), method_7333, 0, "map", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_16585), Reflex::Literal("printObject<TH1D>"), method_7334, 0, "map", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class TTofpetSetupHandler -------------------------------
static  void operator_8815( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TTofpetSetupHandler*)o)->operator=)(*(const ::TTofpetSetupHandler*)arg[0]);
  else   (((::TTofpetSetupHandler*)o)->operator=)(*(const ::TTofpetSetupHandler*)arg[0]);
}

static void constructor_8816( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetSetupHandler(*(const ::TTofpetSetupHandler*)arg[0]);
  else ::new(mem) ::TTofpetSetupHandler(*(const ::TTofpetSetupHandler*)arg[0]);
}

static void constructor_8817( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetSetupHandler();
  else ::new(mem) ::TTofpetSetupHandler();
}

static void constructor_8818( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetSetupHandler(*(::std::string*)arg[0]);
  else ::new(mem) ::TTofpetSetupHandler(*(::std::string*)arg[0]);
}

static  void method_8819( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetSetupHandler*)o)->processLine)(*(::std::string*)arg[0]);
}

static  void method_8820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetSetupHandler*)o)->Class)());
  else   (((::TTofpetSetupHandler*)o)->Class)();
}

static  void method_8821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetSetupHandler*)o)->Class_Name)());
  else   (((::TTofpetSetupHandler*)o)->Class_Name)();
}

static  void method_8822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TTofpetSetupHandler*)o)->Class_Version)());
  else   (((::TTofpetSetupHandler*)o)->Class_Version)();
}

static  void method_8823( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetSetupHandler*)o)->Dictionary)();
}

static  void method_8824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetSetupHandler*)o)->IsA)());
  else   (((const ::TTofpetSetupHandler*)o)->IsA)();
}

static  void method_8825( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetSetupHandler*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_8826( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetSetupHandler*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_8827( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetSetupHandler*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_8828( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetSetupHandler*)o)->DeclFileName)());
  else   (((::TTofpetSetupHandler*)o)->DeclFileName)();
}

static  void method_8829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetSetupHandler*)o)->ImplFileLine)());
  else   (((::TTofpetSetupHandler*)o)->ImplFileLine)();
}

static  void method_8830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetSetupHandler*)o)->ImplFileName)());
  else   (((::TTofpetSetupHandler*)o)->ImplFileName)();
}

static  void method_8831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetSetupHandler*)o)->DeclFileLine)());
  else   (((::TTofpetSetupHandler*)o)->DeclFileLine)();
}

static void destructor_8832(void*, void * o, const std::vector<void*>&, void *) {
((::TTofpetSetupHandler*)o)->::TTofpetSetupHandler::~TTofpetSetupHandler();
}
static void method_newdel_2344( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TTofpetSetupHandler >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TTofpetSetupHandler >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TTofpetSetupHandler >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TTofpetSetupHandler >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TTofpetSetupHandler >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TRealSetupHandler")), ::Reflex::BaseOffset< ::TTofpetSetupHandler,::TRealSetupHandler >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TTofpetSetupHandler,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TTofpetSetupHandler -------------------------------
void __TTofpetSetupHandler_db_datamem(Reflex::Class*);
void __TTofpetSetupHandler_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TTofpetSetupHandler_datamem_bld(&__TTofpetSetupHandler_db_datamem);
Reflex::GenreflexMemberBuilder __TTofpetSetupHandler_funcmem_bld(&__TTofpetSetupHandler_db_funcmem);
void __TTofpetSetupHandler_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TTofpetSetupHandler"), typeid(::TTofpetSetupHandler), sizeof(::TTofpetSetupHandler), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TTofpetSetupHandler::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1663, ::Reflex::BaseOffset< ::TTofpetSetupHandler, ::TRealSetupHandler >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16824, type_16825), Reflex::Literal("operator="), operator_8815, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16825), Reflex::Literal("TTofpetSetupHandler"), constructor_8816, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TTofpetSetupHandler"), constructor_8817, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2786), Reflex::Literal("TTofpetSetupHandler"), constructor_8818, 0, "fname", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TTofpetSetupHandler"), destructor_8832, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2344, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__TTofpetSetupHandler_funcmem_bld);
}

//------Delayed data member builder for class TTofpetSetupHandler -------------------
void __TTofpetSetupHandler_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class TTofpetSetupHandler -------------------
void __TTofpetSetupHandler_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2786), Reflex::Literal("processLine"), method_8819, 0, "line", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_744), Reflex::Literal("Class"), method_8820, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3361), Reflex::Literal("Class_Name"), method_8821, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2386), Reflex::Literal("Class_Version"), method_8822, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("Dictionary"), method_8823, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_744), Reflex::Literal("IsA"), method_8824, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_15486), Reflex::Literal("ShowMembers"), method_8825, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_4973), Reflex::Literal("Streamer"), method_8826, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_4973), Reflex::Literal("StreamerNVirtual"), method_8827, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3361), Reflex::Literal("DeclFileName"), method_8828, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("ImplFileLine"), method_8829, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3361), Reflex::Literal("ImplFileName"), method_8830, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("DeclFileLine"), method_8831, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TTofpetThresholdCalibrationGui -------------------------------
static void constructor_9610( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetThresholdCalibrationGui((::TTofpetThresholdCalibration*)arg[0],
      (const ::TGWindow*)arg[1],
      *(::UInt_t*)arg[2],
      *(::UInt_t*)arg[3]);
  else ::new(mem) ::TTofpetThresholdCalibrationGui((::TTofpetThresholdCalibration*)arg[0],
      (const ::TGWindow*)arg[1],
      *(::UInt_t*)arg[2],
      *(::UInt_t*)arg[3]);
}

static void constructor_9611( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetThresholdCalibrationGui();
  else ::new(mem) ::TTofpetThresholdCalibrationGui();
}

static  void method_9612( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetThresholdCalibrationGui*)o)->Start)();
}

static  void method_9613( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetThresholdCalibrationGui*)o)->Prev)();
}

static  void method_9614( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetThresholdCalibrationGui*)o)->Next)();
}

static  void method_9615( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetThresholdCalibrationGui*)o)->Refresh)();
}

static  void method_9616( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::TTofpetThresholdCalibrationGui*)o)->Save)();
  }
  else if ( arg.size() == 1 ) { 
    (((::TTofpetThresholdCalibrationGui*)o)->Save)(*(int*)arg[0]);
  }
}

static  void method_9617( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetThresholdCalibrationGui*)o)->NextAndSave)();
}

static  void method_9618( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetThresholdCalibrationGui*)o)->RefreshThrWidgetValue)();
}

static  void method_9619( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetThresholdCalibrationGui*)o)->RefreshChWidgetValue)();
}

static  void method_9620( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetThresholdCalibrationGui*)o)->fThrChanged)();
}

static  void method_9621( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetThresholdCalibrationGui*)o)->GoToChannel)(*(::Long_t*)arg[0]);
}

static  void method_9622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetThresholdCalibrationGui*)o)->Class)());
  else   (((::TTofpetThresholdCalibrationGui*)o)->Class)();
}

static  void method_9623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetThresholdCalibrationGui*)o)->Class_Name)());
  else   (((::TTofpetThresholdCalibrationGui*)o)->Class_Name)();
}

static  void method_9624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TTofpetThresholdCalibrationGui*)o)->Class_Version)());
  else   (((::TTofpetThresholdCalibrationGui*)o)->Class_Version)();
}

static  void method_9625( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetThresholdCalibrationGui*)o)->Dictionary)();
}

static  void method_9626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetThresholdCalibrationGui*)o)->IsA)());
  else   (((const ::TTofpetThresholdCalibrationGui*)o)->IsA)();
}

static  void method_9627( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetThresholdCalibrationGui*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_9628( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetThresholdCalibrationGui*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_9629( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetThresholdCalibrationGui*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_9630( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetThresholdCalibrationGui*)o)->DeclFileName)());
  else   (((::TTofpetThresholdCalibrationGui*)o)->DeclFileName)();
}

static  void method_9631( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibrationGui*)o)->ImplFileLine)());
  else   (((::TTofpetThresholdCalibrationGui*)o)->ImplFileLine)();
}

static  void method_9632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetThresholdCalibrationGui*)o)->ImplFileName)());
  else   (((::TTofpetThresholdCalibrationGui*)o)->ImplFileName)();
}

static  void method_9633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibrationGui*)o)->DeclFileLine)());
  else   (((::TTofpetThresholdCalibrationGui*)o)->DeclFileLine)();
}

static void destructor_9634(void*, void * o, const std::vector<void*>&, void *) {
((::TTofpetThresholdCalibrationGui*)o)->::TTofpetThresholdCalibrationGui::~TTofpetThresholdCalibrationGui();
}
static void method_newdel_2516( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TTofpetThresholdCalibrationGui >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TTofpetThresholdCalibrationGui >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TTofpetThresholdCalibrationGui >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TTofpetThresholdCalibrationGui >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TTofpetThresholdCalibrationGui >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TGCanvas")), ::Reflex::BaseOffset< ::TTofpetThresholdCalibrationGui,::TGCanvas >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TGFrame")), ::Reflex::BaseOffset< ::TTofpetThresholdCalibrationGui,::TGFrame >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TGWindow")), ::Reflex::BaseOffset< ::TTofpetThresholdCalibrationGui,::TGWindow >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TGObject")), ::Reflex::BaseOffset< ::TTofpetThresholdCalibrationGui,::TGObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TTofpetThresholdCalibrationGui,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TQObject")), ::Reflex::BaseOffset< ::TTofpetThresholdCalibrationGui,::TQObject >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TTofpetThresholdCalibrationGui -------------------------------
void __TTofpetThresholdCalibrationGui_db_datamem(Reflex::Class*);
void __TTofpetThresholdCalibrationGui_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TTofpetThresholdCalibrationGui_datamem_bld(&__TTofpetThresholdCalibrationGui_db_datamem);
Reflex::GenreflexMemberBuilder __TTofpetThresholdCalibrationGui_funcmem_bld(&__TTofpetThresholdCalibrationGui_db_funcmem);
void __TTofpetThresholdCalibrationGui_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TTofpetThresholdCalibrationGui"), typeid(::TTofpetThresholdCalibrationGui), sizeof(::TTofpetThresholdCalibrationGui), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TTofpetThresholdCalibrationGui::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2298, ::Reflex::BaseOffset< ::TTofpetThresholdCalibrationGui, ::TGCanvas >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16903, type_15535, type_2566, type_2566), Reflex::Literal("TTofpetThresholdCalibrationGui"), constructor_9610, 0, "TofpetThresholdCalibration;p;w;h", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TTofpetThresholdCalibrationGui"), constructor_9611, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TTofpetThresholdCalibrationGui"), destructor_9634, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2516, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TTofpetThresholdCalibrationGui_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TTofpetThresholdCalibrationGui_funcmem_bld);
}

//------Delayed data member builder for class TTofpetThresholdCalibrationGui -------------------
void __TTofpetThresholdCalibrationGui_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_16903, Reflex::Literal("m_TTofpetThresholdCalibration"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationGui, m_TTofpetThresholdCalibration), ::Reflex::PRIVATE)
  .AddDataMember(type_16904, Reflex::Literal("fMain"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationGui, fMain), ::Reflex::PRIVATE)
  .AddDataMember(type_16905, Reflex::Literal("fEcanvas"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationGui, fEcanvas), ::Reflex::PRIVATE)
  .AddDataMember(type_16906, Reflex::Literal("fNext"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationGui, fNext), ::Reflex::PRIVATE)
  .AddDataMember(type_16906, Reflex::Literal("fPrev"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationGui, fPrev), ::Reflex::PRIVATE)
  .AddDataMember(type_16906, Reflex::Literal("fSave"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationGui, fSave), ::Reflex::PRIVATE)
  .AddDataMember(type_16906, Reflex::Literal("fNextAndSave"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationGui, fNextAndSave), ::Reflex::PRIVATE)
  .AddDataMember(type_16907, Reflex::Literal("fFrame"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationGui, fFrame), ::Reflex::PRIVATE)
  .AddDataMember(type_16908, Reflex::Literal("fThr"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationGui, fThr), ::Reflex::PRIVATE)
  .AddDataMember(type_16908, Reflex::Literal("fCh"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationGui, fCh), ::Reflex::PRIVATE)
  .AddDataMember(type_16909, Reflex::Literal("lThr1"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationGui, lThr1), ::Reflex::PRIVATE)
  .AddDataMember(type_16909, Reflex::Literal("lThr2"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationGui, lThr2), ::Reflex::PRIVATE)
  .AddDataMember(type_16909, Reflex::Literal("lThr3"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationGui, lThr3), ::Reflex::PRIVATE)
  .AddDataMember(type_16909, Reflex::Literal("lThr4"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationGui, lThr4), ::Reflex::PRIVATE)
  .AddDataMember(type_15725, Reflex::Literal("m_canvas"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationGui, m_canvas), ::Reflex::PRIVATE)
  .AddDataMember(type_135, Reflex::Literal("m_curChannel"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationGui, m_curChannel), ::Reflex::PRIVATE)
  .AddDataMember(type_135, Reflex::Literal("m_curThr"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationGui, m_curThr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TTofpetThresholdCalibrationGui -------------------
void __TTofpetThresholdCalibrationGui_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("Start"), method_9612, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("Prev"), method_9613, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("Next"), method_9614, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("Refresh"), method_9615, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_135), Reflex::Literal("Save"), method_9616, 0, "nphe=2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("NextAndSave"), method_9617, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("RefreshThrWidgetValue"), method_9618, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("RefreshChWidgetValue"), method_9619, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("fThrChanged"), method_9620, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_1012), Reflex::Literal("GoToChannel"), method_9621, 0, "ch", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_744), Reflex::Literal("Class"), method_9622, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3361), Reflex::Literal("Class_Name"), method_9623, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2386), Reflex::Literal("Class_Version"), method_9624, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("Dictionary"), method_9625, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_744), Reflex::Literal("IsA"), method_9626, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_15486), Reflex::Literal("ShowMembers"), method_9627, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_4973), Reflex::Literal("Streamer"), method_9628, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_4973), Reflex::Literal("StreamerNVirtual"), method_9629, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3361), Reflex::Literal("DeclFileName"), method_9630, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("ImplFileLine"), method_9631, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3361), Reflex::Literal("ImplFileName"), method_9632, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("DeclFileLine"), method_9633, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TTofpetHit -------------------------------
static  void operator_10420( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TTofpetHit*)o)->operator=)(*(const ::TTofpetHit*)arg[0]);
  else   (((::TTofpetHit*)o)->operator=)(*(const ::TTofpetHit*)arg[0]);
}

static void constructor_10421( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetHit(*(const ::TTofpetHit*)arg[0]);
  else ::new(mem) ::TTofpetHit(*(const ::TTofpetHit*)arg[0]);
}

static void constructor_10422( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetHit();
  else ::new(mem) ::TTofpetHit();
}

static void destructor_10423(void*, void * o, const std::vector<void*>&, void *) {
((::TTofpetHit*)o)->::TTofpetHit::~TTofpetHit();
}
static  void method_10424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::TTofpetHit*)o)->getChannel)());
  else   (((const ::TTofpetHit*)o)->getChannel)();
}

static  void method_10425( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setChannel)(*(short*)arg[0]);
}

static  void method_10426( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TTofpetHit*)o)->getChannelIdleTime)());
  else   (((const ::TTofpetHit*)o)->getChannelIdleTime)();
}

static  void method_10427( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setChannelIdleTime)(*(double*)arg[0]);
}

static  void method_10428( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::TTofpetHit*)o)->getDetector)());
  else   (((const ::TTofpetHit*)o)->getDetector)();
}

static  void method_10429( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setDetector)(*(short*)arg[0]);
}

static  void method_10430( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::TTofpetHit*)o)->getEnergy)());
  else   (((const ::TTofpetHit*)o)->getEnergy)();
}

static  void method_10431( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setEnergy)(*(float*)arg[0]);
}

static  void method_10432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::TTofpetHit*)o)->getToT)());
  else   (((const ::TTofpetHit*)o)->getToT)();
}

static  void method_10433( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setTot)(*(float*)arg[0]);
}

static  void method_10434( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TTofpetHit*)o)->getTacIdleTime)());
  else   (((const ::TTofpetHit*)o)->getTacIdleTime)();
}

static  void method_10435( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setTacIdleTime)(*(double*)arg[0]);
}

static  void method_10436( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::TTofpetHit*)o)->getTqe)());
  else   (((const ::TTofpetHit*)o)->getTqe)();
}

static  void method_10437( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setTqe)(*(float*)arg[0]);
}

static  void method_10438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::TTofpetHit*)o)->getTqt)());
  else   (((const ::TTofpetHit*)o)->getTqt)();
}

static  void method_10439( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setTqt)(*(float*)arg[0]);
}

static  void method_10440( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::TTofpetHit*)o)->getXi)());
  else   (((const ::TTofpetHit*)o)->getXi)();
}

static  void method_10441( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setXi)(*(short*)arg[0]);
}

static  void method_10442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::TTofpetHit*)o)->getYi)());
  else   (((const ::TTofpetHit*)o)->getYi)();
}

static  void method_10443( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setYi)(*(short*)arg[0]);
}

static  void method_10444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::TTofpetHit*)o)->getTime)());
  else   (((const ::TTofpetHit*)o)->getTime)();
}

static  void method_10445( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setTime)(*(long long*)arg[0]);
}

static  void method_10446( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->setTac)(*(unsigned short*)arg[0]);
}

static  void method_10447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((::TTofpetHit*)o)->getTac)());
  else   (((::TTofpetHit*)o)->getTac)();
}

static  void method_10448( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetHit*)o)->Class)());
  else   (((::TTofpetHit*)o)->Class)();
}

static  void method_10449( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetHit*)o)->Class_Name)());
  else   (((::TTofpetHit*)o)->Class_Name)();
}

static  void method_10450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TTofpetHit*)o)->Class_Version)());
  else   (((::TTofpetHit*)o)->Class_Version)();
}

static  void method_10451( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetHit*)o)->Dictionary)();
}

static  void method_10452( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetHit*)o)->IsA)());
  else   (((const ::TTofpetHit*)o)->IsA)();
}

static  void method_10453( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_10454( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_10455( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetHit*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_10456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetHit*)o)->DeclFileName)());
  else   (((::TTofpetHit*)o)->DeclFileName)();
}

static  void method_10457( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetHit*)o)->ImplFileLine)());
  else   (((::TTofpetHit*)o)->ImplFileLine)();
}

static  void method_10458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetHit*)o)->ImplFileName)());
  else   (((::TTofpetHit*)o)->ImplFileName)();
}

static  void method_10459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetHit*)o)->DeclFileLine)());
  else   (((::TTofpetHit*)o)->DeclFileLine)();
}

static void method_newdel_2704( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TTofpetHit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TTofpetHit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TTofpetHit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TTofpetHit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TTofpetHit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TTofpetHit,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TTofpetHit -------------------------------
void __TTofpetHit_db_datamem(Reflex::Class*);
void __TTofpetHit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TTofpetHit_datamem_bld(&__TTofpetHit_db_datamem);
Reflex::GenreflexMemberBuilder __TTofpetHit_funcmem_bld(&__TTofpetHit_db_funcmem);
void __TTofpetHit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TTofpetHit"), typeid(::TTofpetHit), sizeof(::TTofpetHit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TTofpetHit::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2105, ::Reflex::BaseOffset< ::TTofpetHit, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16949, type_16950), Reflex::Literal("operator="), operator_10420, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16950), Reflex::Literal("TTofpetHit"), constructor_10421, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TTofpetHit"), constructor_10422, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TTofpetHit"), destructor_10423, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2704, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TTofpetHit_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TTofpetHit_funcmem_bld);
}

//------Delayed data member builder for class TTofpetHit -------------------
void __TTofpetHit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_179, Reflex::Literal("m_channel"), OffsetOf(__shadow__::__TTofpetHit, m_channel), ::Reflex::PRIVATE)
  .AddDataMember(type_179, Reflex::Literal("m_xi"), OffsetOf(__shadow__::__TTofpetHit, m_xi), ::Reflex::PRIVATE)
  .AddDataMember(type_179, Reflex::Literal("m_yi"), OffsetOf(__shadow__::__TTofpetHit, m_yi), ::Reflex::PRIVATE)
  .AddDataMember(type_179, Reflex::Literal("m_detector"), OffsetOf(__shadow__::__TTofpetHit, m_detector), ::Reflex::PRIVATE)
  .AddDataMember(type_296, Reflex::Literal("m_tac"), OffsetOf(__shadow__::__TTofpetHit, m_tac), ::Reflex::PRIVATE)
  .AddDataMember(type_220, Reflex::Literal("m_channelIdleTime"), OffsetOf(__shadow__::__TTofpetHit, m_channelIdleTime), ::Reflex::PRIVATE)
  .AddDataMember(type_220, Reflex::Literal("m_tacIdleTime"), OffsetOf(__shadow__::__TTofpetHit, m_tacIdleTime), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("m_energy"), OffsetOf(__shadow__::__TTofpetHit, m_energy), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("m_ToT"), OffsetOf(__shadow__::__TTofpetHit, m_ToT), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("m_TQT"), OffsetOf(__shadow__::__TTofpetHit, m_TQT), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("m_TQE"), OffsetOf(__shadow__::__TTofpetHit, m_TQE), ::Reflex::PRIVATE)
  .AddDataMember(type_1809, Reflex::Literal("m_time"), OffsetOf(__shadow__::__TTofpetHit, m_time), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TTofpetHit -------------------
void __TTofpetHit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_179), Reflex::Literal("getChannel"), method_10424, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_179), Reflex::Literal("setChannel"), method_10425, 0, "channel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_220), Reflex::Literal("getChannelIdleTime"), method_10426, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_220), Reflex::Literal("setChannelIdleTime"), method_10427, 0, "channelIdleTime", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_179), Reflex::Literal("getDetector"), method_10428, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_179), Reflex::Literal("setDetector"), method_10429, 0, "detector", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("getEnergy"), method_10430, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_97), Reflex::Literal("setEnergy"), method_10431, 0, "eventEnergy", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("getToT"), method_10432, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_97), Reflex::Literal("setTot"), method_10433, 0, "eventTot", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_220), Reflex::Literal("getTacIdleTime"), method_10434, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_220), Reflex::Literal("setTacIdleTime"), method_10435, 0, "tacIdleTime", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("getTqe"), method_10436, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_97), Reflex::Literal("setTqe"), method_10437, 0, "tqe", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("getTqt"), method_10438, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_97), Reflex::Literal("setTqt"), method_10439, 0, "tqt", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_179), Reflex::Literal("getXi"), method_10440, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_179), Reflex::Literal("setXi"), method_10441, 0, "xi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_179), Reflex::Literal("getYi"), method_10442, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_179), Reflex::Literal("setYi"), method_10443, 0, "yi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1809), Reflex::Literal("getTime"), method_10444, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_1809), Reflex::Literal("setTime"), method_10445, 0, "time", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_296), Reflex::Literal("setTac"), method_10446, 0, "tac", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296), Reflex::Literal("getTac"), method_10447, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_744), Reflex::Literal("Class"), method_10448, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3361), Reflex::Literal("Class_Name"), method_10449, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2386), Reflex::Literal("Class_Version"), method_10450, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("Dictionary"), method_10451, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_744), Reflex::Literal("IsA"), method_10452, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_15486), Reflex::Literal("ShowMembers"), method_10453, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_4973), Reflex::Literal("Streamer"), method_10454, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_4973), Reflex::Literal("StreamerNVirtual"), method_10455, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3361), Reflex::Literal("DeclFileName"), method_10456, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("ImplFileLine"), method_10457, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3361), Reflex::Literal("ImplFileName"), method_10458, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_135), Reflex::Literal("DeclFileLine"), method_10459, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class map<int,TH2D*,std::less<int>,std::allocator<std::pair<const int, TH2D*> > > -------------------------------
static void destructor_12172(void*, void * o, const std::vector<void*>&, void *) {
((::std::map<int,TH2D*>*)o)->::std::map<int,TH2D*>::~map();
}
static void constructor_12173( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,TH2D*>();
  else ::new(mem) ::std::map<int,TH2D*>();
}

static void constructor_12174( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,TH2D*>(*(const ::std::less<int>*)arg[0]);
  else ::new(mem) ::std::map<int,TH2D*>(*(const ::std::less<int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,TH2D*>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,TH2D*> >*)arg[1]);
  else ::new(mem) ::std::map<int,TH2D*>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,TH2D*> >*)arg[1]);
  }
}

static void constructor_12175( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,TH2D*>(*(const ::std::map<int,TH2D*>*)arg[0]);
  else ::new(mem) ::std::map<int,TH2D*>(*(const ::std::map<int,TH2D*>*)arg[0]);
}

static  void operator_12176( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,TH2D*>*)o)->operator=)(*(const ::std::map<int,TH2D*>*)arg[0]);
  else   (((::std::map<int,TH2D*>*)o)->operator=)(*(const ::std::map<int,TH2D*>*)arg[0]);
}

static  void method_12177( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,TH2D*> >)((((const ::std::map<int,TH2D*>*)o)->get_allocator)());
  else   (((const ::std::map<int,TH2D*>*)o)->get_allocator)();
}

static  void method_12178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,TH2D*> >)((((::std::map<int,TH2D*>*)o)->begin)());
  else   (((::std::map<int,TH2D*>*)o)->begin)();
}

static  void method_12179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,TH2D*> >)((((const ::std::map<int,TH2D*>*)o)->begin)());
  else   (((const ::std::map<int,TH2D*>*)o)->begin)();
}

static  void method_12180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,TH2D*> >)((((::std::map<int,TH2D*>*)o)->end)());
  else   (((::std::map<int,TH2D*>*)o)->end)();
}

static  void method_12181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,TH2D*> >)((((const ::std::map<int,TH2D*>*)o)->end)());
  else   (((const ::std::map<int,TH2D*>*)o)->end)();
}

static  void method_12186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<int,TH2D*>*)o)->empty)());
  else   (((const ::std::map<int,TH2D*>*)o)->empty)();
}

static  void method_12187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,TH2D*>*)o)->size)());
  else   (((const ::std::map<int,TH2D*>*)o)->size)();
}

static  void method_12188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,TH2D*>*)o)->max_size)());
  else   (((const ::std::map<int,TH2D*>*)o)->max_size)();
}

static  void operator_12189( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,TH2D*>*)o)->operator[])(*(const int*)arg[0]);
  else   (((::std::map<int,TH2D*>*)o)->operator[])(*(const int*)arg[0]);
}

static  void method_12190( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,TH2D*>*)o)->at)(*(const int*)arg[0]);
  else   (((::std::map<int,TH2D*>*)o)->at)(*(const int*)arg[0]);
}

static  void method_12191( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<int,TH2D*>*)o)->at)(*(const int*)arg[0]);
  else   (((const ::std::map<int,TH2D*>*)o)->at)(*(const int*)arg[0]);
}

static  void method_12192( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,TH2D*> >,bool>)((((::std::map<int,TH2D*>*)o)->insert)(*(const ::std::pair<const int,TH2D*>*)arg[0]));
  else   (((::std::map<int,TH2D*>*)o)->insert)(*(const ::std::pair<const int,TH2D*>*)arg[0]);
}

static  void method_12193( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,TH2D*> >)((((::std::map<int,TH2D*>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,TH2D*> >*)arg[0],
    *(const ::std::pair<const int,TH2D*>*)arg[1]));
  else   (((::std::map<int,TH2D*>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,TH2D*> >*)arg[0],
    *(const ::std::pair<const int,TH2D*>*)arg[1]);
}

static  void method_12194( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,TH2D*>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,TH2D*> >*)arg[0]);
}

static  void method_12195( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((::std::map<int,TH2D*>*)o)->erase)(*(const int*)arg[0]));
  else   (((::std::map<int,TH2D*>*)o)->erase)(*(const int*)arg[0]);
}

static  void method_12196( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,TH2D*>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,TH2D*> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const int,TH2D*> >*)arg[1]);
}

static  void method_12197( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,TH2D*>*)o)->swap)(*(::std::map<int,TH2D*>*)arg[0]);
}

static  void method_12198( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<int,TH2D*>*)o)->clear)();
}

static  void method_12199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<int>)((((const ::std::map<int,TH2D*>*)o)->key_comp)());
  else   (((const ::std::map<int,TH2D*>*)o)->key_comp)();
}

static  void method_12201( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,TH2D*> >)((((::std::map<int,TH2D*>*)o)->find)(*(const int*)arg[0]));
  else   (((::std::map<int,TH2D*>*)o)->find)(*(const int*)arg[0]);
}

static  void method_12202( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,TH2D*> >)((((const ::std::map<int,TH2D*>*)o)->find)(*(const int*)arg[0]));
  else   (((const ::std::map<int,TH2D*>*)o)->find)(*(const int*)arg[0]);
}

static  void method_12203( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,TH2D*>*)o)->count)(*(const int*)arg[0]));
  else   (((const ::std::map<int,TH2D*>*)o)->count)(*(const int*)arg[0]);
}

static  void method_12204( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,TH2D*> >)((((::std::map<int,TH2D*>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,TH2D*>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12205( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,TH2D*> >)((((const ::std::map<int,TH2D*>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,TH2D*>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12206( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,TH2D*> >)((((::std::map<int,TH2D*>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,TH2D*>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12207( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,TH2D*> >)((((const ::std::map<int,TH2D*>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,TH2D*>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12208( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,TH2D*> >,std::_Rb_tree_iterator<std::pair<const int,TH2D*> > >)((((::std::map<int,TH2D*>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::std::map<int,TH2D*>*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_12209( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const int,TH2D*> >,std::_Rb_tree_const_iterator<std::pair<const int,TH2D*> > >)((((const ::std::map<int,TH2D*>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::std::map<int,TH2D*>*)o)->equal_range)(*(const int*)arg[0]);
}

static void method_newdel_2923( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<int,TH2D*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<int,TH2D*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<int,TH2D*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<int,TH2D*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<int,TH2D*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x13( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<int,TH2D*> >::Generate();
  else ::Reflex::Proxy< ::std::map<int,TH2D*> >::Generate();
}

//------Dictionary for class map<int,TH2D*,std::less<int>,std::allocator<std::pair<const int, TH2D*> > > -------------------------------
void __std__map_int_TH2Dp__db_datamem(Reflex::Class*);
void __std__map_int_TH2Dp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_int_TH2Dp__datamem_bld(&__std__map_int_TH2Dp__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_int_TH2Dp__funcmem_bld(&__std__map_int_TH2Dp__db_funcmem);
void __std__map_int_TH2Dp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<int,TH2D*>"), typeid(::std::map<int,TH2D*>), sizeof(::std::map<int,TH2D*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_135, Reflex::Literal("std::map<int,TH2D*>::key_type"))
  .AddTypedef(type_12149, Reflex::Literal("std::map<int,TH2D*>::mapped_type"))
  .AddTypedef(type_3010, Reflex::Literal("std::map<int,TH2D*>::value_type"))
  .AddTypedef(type_2965, Reflex::Literal("std::map<int,TH2D*>::key_compare"))
  .AddTypedef(type_3105, Reflex::Literal("std::map<int,TH2D*>::allocator_type"))
  .AddTypedef(type_3010, Reflex::Literal("std::map<int,TH2D*>::_Alloc_value_type"))
  .AddTypedef(type_3105, Reflex::Literal("std::map<int,TH2D*>::_Pair_alloc_type"))
  .AddTypedef(type_3053, Reflex::Literal("std::map<int,TH2D*>::_Rep_type"))
  .AddTypedef(type_12158, Reflex::Literal("std::map<int,TH2D*>::pointer"))
  .AddTypedef(type_12160, Reflex::Literal("std::map<int,TH2D*>::const_pointer"))
  .AddTypedef(type_12162, Reflex::Literal("std::map<int,TH2D*>::reference"))
  .AddTypedef(type_12164, Reflex::Literal("std::map<int,TH2D*>::const_reference"))
  .AddTypedef(type_2794, Reflex::Literal("std::map<int,TH2D*>::iterator"))
  .AddTypedef(type_3258, Reflex::Literal("std::map<int,TH2D*>::const_iterator"))
  .AddTypedef(type_1821, Reflex::Literal("std::map<int,TH2D*>::size_type"))
  .AddTypedef(type_715, Reflex::Literal("std::map<int,TH2D*>::difference_type"))
  .AddTypedef(type_3193, Reflex::Literal("std::map<int,TH2D*>::reverse_iterator"))
  .AddTypedef(type_3192, Reflex::Literal("std::map<int,TH2D*>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_12172, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_12173, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17288, type_17289), Reflex::Literal("map"), constructor_12174, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16586), Reflex::Literal("map"), constructor_12175, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2923, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_int_TH2Dp__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_int_TH2Dp__funcmem_bld);
}

//------Delayed data member builder for class map<int,TH2D*,std::less<int>,std::allocator<std::pair<const int, TH2D*> > > -------------------
void __std__map_int_TH2Dp__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3053, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_int_TH2Dp_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<int,TH2D*,std::less<int>,std::allocator<std::pair<const int, TH2D*> > > -------------------
void __std__map_int_TH2Dp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16582, type_16586), Reflex::Literal("operator="), operator_12176, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3105), Reflex::Literal("get_allocator"), method_12177, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2794), Reflex::Literal("begin"), method_12178, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3258), Reflex::Literal("begin"), method_12179, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2794), Reflex::Literal("end"), method_12180, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3258), Reflex::Literal("end"), method_12181, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_617), Reflex::Literal("empty"), method_12186, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821), Reflex::Literal("size"), method_12187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821), Reflex::Literal("max_size"), method_12188, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17290, type_10740), Reflex::Literal("operator[]"), operator_12189, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17290, type_10740), Reflex::Literal("at"), method_12190, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17291, type_10740), Reflex::Literal("at"), method_12191, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3028, type_12164), Reflex::Literal("insert"), method_12192, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2794, type_2794, type_12164), Reflex::Literal("insert"), method_12193, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2794), Reflex::Literal("erase"), method_12194, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821, type_10740), Reflex::Literal("erase"), method_12195, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2794, type_2794), Reflex::Literal("erase"), method_12196, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_16582), Reflex::Literal("swap"), method_12197, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("clear"), method_12198, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2965), Reflex::Literal("key_comp"), method_12199, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2794, type_10740), Reflex::Literal("find"), method_12201, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3258, type_10740), Reflex::Literal("find"), method_12202, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821, type_10740), Reflex::Literal("count"), method_12203, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2794, type_10740), Reflex::Literal("lower_bound"), method_12204, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3258, type_10740), Reflex::Literal("lower_bound"), method_12205, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2794, type_10740), Reflex::Literal("upper_bound"), method_12206, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3258, type_10740), Reflex::Literal("upper_bound"), method_12207, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3027, type_10740), Reflex::Literal("equal_range"), method_12208, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3026, type_10740), Reflex::Literal("equal_range"), method_12209, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<int,TGraph*,std::less<int>,std::allocator<std::pair<const int, TGraph*> > > -------------------------------
static void destructor_12235(void*, void * o, const std::vector<void*>&, void *) {
((::std::map<int,TGraph*>*)o)->::std::map<int,TGraph*>::~map();
}
static void constructor_12236( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,TGraph*>();
  else ::new(mem) ::std::map<int,TGraph*>();
}

static void constructor_12237( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,TGraph*>(*(const ::std::less<int>*)arg[0]);
  else ::new(mem) ::std::map<int,TGraph*>(*(const ::std::less<int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,TGraph*>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,TGraph*> >*)arg[1]);
  else ::new(mem) ::std::map<int,TGraph*>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,TGraph*> >*)arg[1]);
  }
}

static void constructor_12238( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,TGraph*>(*(const ::std::map<int,TGraph*>*)arg[0]);
  else ::new(mem) ::std::map<int,TGraph*>(*(const ::std::map<int,TGraph*>*)arg[0]);
}

static  void operator_12239( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,TGraph*>*)o)->operator=)(*(const ::std::map<int,TGraph*>*)arg[0]);
  else   (((::std::map<int,TGraph*>*)o)->operator=)(*(const ::std::map<int,TGraph*>*)arg[0]);
}

static  void method_12240( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,TGraph*> >)((((const ::std::map<int,TGraph*>*)o)->get_allocator)());
  else   (((const ::std::map<int,TGraph*>*)o)->get_allocator)();
}

static  void method_12241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,TGraph*> >)((((::std::map<int,TGraph*>*)o)->begin)());
  else   (((::std::map<int,TGraph*>*)o)->begin)();
}

static  void method_12242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,TGraph*> >)((((const ::std::map<int,TGraph*>*)o)->begin)());
  else   (((const ::std::map<int,TGraph*>*)o)->begin)();
}

static  void method_12243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,TGraph*> >)((((::std::map<int,TGraph*>*)o)->end)());
  else   (((::std::map<int,TGraph*>*)o)->end)();
}

static  void method_12244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,TGraph*> >)((((const ::std::map<int,TGraph*>*)o)->end)());
  else   (((const ::std::map<int,TGraph*>*)o)->end)();
}

static  void method_12249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<int,TGraph*>*)o)->empty)());
  else   (((const ::std::map<int,TGraph*>*)o)->empty)();
}

static  void method_12250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,TGraph*>*)o)->size)());
  else   (((const ::std::map<int,TGraph*>*)o)->size)();
}

static  void method_12251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,TGraph*>*)o)->max_size)());
  else   (((const ::std::map<int,TGraph*>*)o)->max_size)();
}

static  void operator_12252( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,TGraph*>*)o)->operator[])(*(const int*)arg[0]);
  else   (((::std::map<int,TGraph*>*)o)->operator[])(*(const int*)arg[0]);
}

static  void method_12253( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,TGraph*>*)o)->at)(*(const int*)arg[0]);
  else   (((::std::map<int,TGraph*>*)o)->at)(*(const int*)arg[0]);
}

static  void method_12254( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<int,TGraph*>*)o)->at)(*(const int*)arg[0]);
  else   (((const ::std::map<int,TGraph*>*)o)->at)(*(const int*)arg[0]);
}

static  void method_12255( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,TGraph*> >,bool>)((((::std::map<int,TGraph*>*)o)->insert)(*(const ::std::pair<const int,TGraph*>*)arg[0]));
  else   (((::std::map<int,TGraph*>*)o)->insert)(*(const ::std::pair<const int,TGraph*>*)arg[0]);
}

static  void method_12256( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,TGraph*> >)((((::std::map<int,TGraph*>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,TGraph*> >*)arg[0],
    *(const ::std::pair<const int,TGraph*>*)arg[1]));
  else   (((::std::map<int,TGraph*>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,TGraph*> >*)arg[0],
    *(const ::std::pair<const int,TGraph*>*)arg[1]);
}

static  void method_12257( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,TGraph*>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,TGraph*> >*)arg[0]);
}

static  void method_12258( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((::std::map<int,TGraph*>*)o)->erase)(*(const int*)arg[0]));
  else   (((::std::map<int,TGraph*>*)o)->erase)(*(const int*)arg[0]);
}

static  void method_12259( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,TGraph*>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,TGraph*> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const int,TGraph*> >*)arg[1]);
}

static  void method_12260( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,TGraph*>*)o)->swap)(*(::std::map<int,TGraph*>*)arg[0]);
}

static  void method_12261( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<int,TGraph*>*)o)->clear)();
}

static  void method_12262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<int>)((((const ::std::map<int,TGraph*>*)o)->key_comp)());
  else   (((const ::std::map<int,TGraph*>*)o)->key_comp)();
}

static  void method_12264( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,TGraph*> >)((((::std::map<int,TGraph*>*)o)->find)(*(const int*)arg[0]));
  else   (((::std::map<int,TGraph*>*)o)->find)(*(const int*)arg[0]);
}

static  void method_12265( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,TGraph*> >)((((const ::std::map<int,TGraph*>*)o)->find)(*(const int*)arg[0]));
  else   (((const ::std::map<int,TGraph*>*)o)->find)(*(const int*)arg[0]);
}

static  void method_12266( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,TGraph*>*)o)->count)(*(const int*)arg[0]));
  else   (((const ::std::map<int,TGraph*>*)o)->count)(*(const int*)arg[0]);
}

static  void method_12267( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,TGraph*> >)((((::std::map<int,TGraph*>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,TGraph*>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12268( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,TGraph*> >)((((const ::std::map<int,TGraph*>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,TGraph*>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12269( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,TGraph*> >)((((::std::map<int,TGraph*>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,TGraph*>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12270( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,TGraph*> >)((((const ::std::map<int,TGraph*>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,TGraph*>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12271( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,TGraph*> >,std::_Rb_tree_iterator<std::pair<const int,TGraph*> > >)((((::std::map<int,TGraph*>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::std::map<int,TGraph*>*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_12272( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const int,TGraph*> >,std::_Rb_tree_const_iterator<std::pair<const int,TGraph*> > >)((((const ::std::map<int,TGraph*>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::std::map<int,TGraph*>*)o)->equal_range)(*(const int*)arg[0]);
}

static void method_newdel_2924( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<int,TGraph*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<int,TGraph*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<int,TGraph*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<int,TGraph*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<int,TGraph*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<int,TGraph*> >::Generate();
  else ::Reflex::Proxy< ::std::map<int,TGraph*> >::Generate();
}

//------Dictionary for class map<int,TGraph*,std::less<int>,std::allocator<std::pair<const int, TGraph*> > > -------------------------------
void __std__map_int_TGraphp__db_datamem(Reflex::Class*);
void __std__map_int_TGraphp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_int_TGraphp__datamem_bld(&__std__map_int_TGraphp__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_int_TGraphp__funcmem_bld(&__std__map_int_TGraphp__db_funcmem);
void __std__map_int_TGraphp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<int,TGraph*>"), typeid(::std::map<int,TGraph*>), sizeof(::std::map<int,TGraph*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_135, Reflex::Literal("std::map<int,TGraph*>::key_type"))
  .AddTypedef(type_12212, Reflex::Literal("std::map<int,TGraph*>::mapped_type"))
  .AddTypedef(type_3008, Reflex::Literal("std::map<int,TGraph*>::value_type"))
  .AddTypedef(type_2965, Reflex::Literal("std::map<int,TGraph*>::key_compare"))
  .AddTypedef(type_3103, Reflex::Literal("std::map<int,TGraph*>::allocator_type"))
  .AddTypedef(type_3008, Reflex::Literal("std::map<int,TGraph*>::_Alloc_value_type"))
  .AddTypedef(type_3103, Reflex::Literal("std::map<int,TGraph*>::_Pair_alloc_type"))
  .AddTypedef(type_3054, Reflex::Literal("std::map<int,TGraph*>::_Rep_type"))
  .AddTypedef(type_12221, Reflex::Literal("std::map<int,TGraph*>::pointer"))
  .AddTypedef(type_12223, Reflex::Literal("std::map<int,TGraph*>::const_pointer"))
  .AddTypedef(type_12225, Reflex::Literal("std::map<int,TGraph*>::reference"))
  .AddTypedef(type_12227, Reflex::Literal("std::map<int,TGraph*>::const_reference"))
  .AddTypedef(type_2795, Reflex::Literal("std::map<int,TGraph*>::iterator"))
  .AddTypedef(type_3259, Reflex::Literal("std::map<int,TGraph*>::const_iterator"))
  .AddTypedef(type_1821, Reflex::Literal("std::map<int,TGraph*>::size_type"))
  .AddTypedef(type_715, Reflex::Literal("std::map<int,TGraph*>::difference_type"))
  .AddTypedef(type_3195, Reflex::Literal("std::map<int,TGraph*>::reverse_iterator"))
  .AddTypedef(type_3194, Reflex::Literal("std::map<int,TGraph*>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_12235, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_12236, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17288, type_17293), Reflex::Literal("map"), constructor_12237, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16587), Reflex::Literal("map"), constructor_12238, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2924, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_int_TGraphp__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_int_TGraphp__funcmem_bld);
}

//------Delayed data member builder for class map<int,TGraph*,std::less<int>,std::allocator<std::pair<const int, TGraph*> > > -------------------
void __std__map_int_TGraphp__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3054, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_int_TGraphp_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<int,TGraph*,std::less<int>,std::allocator<std::pair<const int, TGraph*> > > -------------------
void __std__map_int_TGraphp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16584, type_16587), Reflex::Literal("operator="), operator_12239, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3103), Reflex::Literal("get_allocator"), method_12240, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2795), Reflex::Literal("begin"), method_12241, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3259), Reflex::Literal("begin"), method_12242, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2795), Reflex::Literal("end"), method_12243, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3259), Reflex::Literal("end"), method_12244, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_617), Reflex::Literal("empty"), method_12249, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821), Reflex::Literal("size"), method_12250, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821), Reflex::Literal("max_size"), method_12251, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17294, type_10740), Reflex::Literal("operator[]"), operator_12252, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17294, type_10740), Reflex::Literal("at"), method_12253, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17295, type_10740), Reflex::Literal("at"), method_12254, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3031, type_12227), Reflex::Literal("insert"), method_12255, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2795, type_2795, type_12227), Reflex::Literal("insert"), method_12256, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2795), Reflex::Literal("erase"), method_12257, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821, type_10740), Reflex::Literal("erase"), method_12258, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2795, type_2795), Reflex::Literal("erase"), method_12259, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_16584), Reflex::Literal("swap"), method_12260, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("clear"), method_12261, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2965), Reflex::Literal("key_comp"), method_12262, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2795, type_10740), Reflex::Literal("find"), method_12264, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3259, type_10740), Reflex::Literal("find"), method_12265, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821, type_10740), Reflex::Literal("count"), method_12266, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2795, type_10740), Reflex::Literal("lower_bound"), method_12267, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3259, type_10740), Reflex::Literal("lower_bound"), method_12268, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2795, type_10740), Reflex::Literal("upper_bound"), method_12269, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3259, type_10740), Reflex::Literal("upper_bound"), method_12270, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3030, type_10740), Reflex::Literal("equal_range"), method_12271, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3029, type_10740), Reflex::Literal("equal_range"), method_12272, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<int,TH1D*,std::less<int>,std::allocator<std::pair<const int, TH1D*> > > -------------------------------
static void destructor_12298(void*, void * o, const std::vector<void*>&, void *) {
((::std::map<int,TH1D*>*)o)->::std::map<int,TH1D*>::~map();
}
static void constructor_12299( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,TH1D*>();
  else ::new(mem) ::std::map<int,TH1D*>();
}

static void constructor_12300( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,TH1D*>(*(const ::std::less<int>*)arg[0]);
  else ::new(mem) ::std::map<int,TH1D*>(*(const ::std::less<int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,TH1D*>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,TH1D*> >*)arg[1]);
  else ::new(mem) ::std::map<int,TH1D*>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,TH1D*> >*)arg[1]);
  }
}

static void constructor_12301( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,TH1D*>(*(const ::std::map<int,TH1D*>*)arg[0]);
  else ::new(mem) ::std::map<int,TH1D*>(*(const ::std::map<int,TH1D*>*)arg[0]);
}

static  void operator_12302( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,TH1D*>*)o)->operator=)(*(const ::std::map<int,TH1D*>*)arg[0]);
  else   (((::std::map<int,TH1D*>*)o)->operator=)(*(const ::std::map<int,TH1D*>*)arg[0]);
}

static  void method_12303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,TH1D*> >)((((const ::std::map<int,TH1D*>*)o)->get_allocator)());
  else   (((const ::std::map<int,TH1D*>*)o)->get_allocator)();
}

static  void method_12304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,TH1D*> >)((((::std::map<int,TH1D*>*)o)->begin)());
  else   (((::std::map<int,TH1D*>*)o)->begin)();
}

static  void method_12305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,TH1D*> >)((((const ::std::map<int,TH1D*>*)o)->begin)());
  else   (((const ::std::map<int,TH1D*>*)o)->begin)();
}

static  void method_12306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,TH1D*> >)((((::std::map<int,TH1D*>*)o)->end)());
  else   (((::std::map<int,TH1D*>*)o)->end)();
}

static  void method_12307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,TH1D*> >)((((const ::std::map<int,TH1D*>*)o)->end)());
  else   (((const ::std::map<int,TH1D*>*)o)->end)();
}

static  void method_12312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<int,TH1D*>*)o)->empty)());
  else   (((const ::std::map<int,TH1D*>*)o)->empty)();
}

static  void method_12313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,TH1D*>*)o)->size)());
  else   (((const ::std::map<int,TH1D*>*)o)->size)();
}

static  void method_12314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,TH1D*>*)o)->max_size)());
  else   (((const ::std::map<int,TH1D*>*)o)->max_size)();
}

static  void operator_12315( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,TH1D*>*)o)->operator[])(*(const int*)arg[0]);
  else   (((::std::map<int,TH1D*>*)o)->operator[])(*(const int*)arg[0]);
}

static  void method_12316( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,TH1D*>*)o)->at)(*(const int*)arg[0]);
  else   (((::std::map<int,TH1D*>*)o)->at)(*(const int*)arg[0]);
}

static  void method_12317( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<int,TH1D*>*)o)->at)(*(const int*)arg[0]);
  else   (((const ::std::map<int,TH1D*>*)o)->at)(*(const int*)arg[0]);
}

static  void method_12318( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,TH1D*> >,bool>)((((::std::map<int,TH1D*>*)o)->insert)(*(const ::std::pair<const int,TH1D*>*)arg[0]));
  else   (((::std::map<int,TH1D*>*)o)->insert)(*(const ::std::pair<const int,TH1D*>*)arg[0]);
}

static  void method_12319( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,TH1D*> >)((((::std::map<int,TH1D*>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,TH1D*> >*)arg[0],
    *(const ::std::pair<const int,TH1D*>*)arg[1]));
  else   (((::std::map<int,TH1D*>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,TH1D*> >*)arg[0],
    *(const ::std::pair<const int,TH1D*>*)arg[1]);
}

static  void method_12320( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,TH1D*>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,TH1D*> >*)arg[0]);
}

static  void method_12321( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((::std::map<int,TH1D*>*)o)->erase)(*(const int*)arg[0]));
  else   (((::std::map<int,TH1D*>*)o)->erase)(*(const int*)arg[0]);
}

static  void method_12322( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,TH1D*>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,TH1D*> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const int,TH1D*> >*)arg[1]);
}

static  void method_12323( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,TH1D*>*)o)->swap)(*(::std::map<int,TH1D*>*)arg[0]);
}

static  void method_12324( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<int,TH1D*>*)o)->clear)();
}

static  void method_12325( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<int>)((((const ::std::map<int,TH1D*>*)o)->key_comp)());
  else   (((const ::std::map<int,TH1D*>*)o)->key_comp)();
}

static  void method_12327( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,TH1D*> >)((((::std::map<int,TH1D*>*)o)->find)(*(const int*)arg[0]));
  else   (((::std::map<int,TH1D*>*)o)->find)(*(const int*)arg[0]);
}

static  void method_12328( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,TH1D*> >)((((const ::std::map<int,TH1D*>*)o)->find)(*(const int*)arg[0]));
  else   (((const ::std::map<int,TH1D*>*)o)->find)(*(const int*)arg[0]);
}

static  void method_12329( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,TH1D*>*)o)->count)(*(const int*)arg[0]));
  else   (((const ::std::map<int,TH1D*>*)o)->count)(*(const int*)arg[0]);
}

static  void method_12330( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,TH1D*> >)((((::std::map<int,TH1D*>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,TH1D*>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12331( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,TH1D*> >)((((const ::std::map<int,TH1D*>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,TH1D*>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12332( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,TH1D*> >)((((::std::map<int,TH1D*>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,TH1D*>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12333( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,TH1D*> >)((((const ::std::map<int,TH1D*>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,TH1D*>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12334( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,TH1D*> >,std::_Rb_tree_iterator<std::pair<const int,TH1D*> > >)((((::std::map<int,TH1D*>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::std::map<int,TH1D*>*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_12335( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const int,TH1D*> >,std::_Rb_tree_const_iterator<std::pair<const int,TH1D*> > >)((((const ::std::map<int,TH1D*>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::std::map<int,TH1D*>*)o)->equal_range)(*(const int*)arg[0]);
}

static void method_newdel_2925( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<int,TH1D*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<int,TH1D*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<int,TH1D*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<int,TH1D*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<int,TH1D*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<int,TH1D*> >::Generate();
  else ::Reflex::Proxy< ::std::map<int,TH1D*> >::Generate();
}

//------Dictionary for class map<int,TH1D*,std::less<int>,std::allocator<std::pair<const int, TH1D*> > > -------------------------------
void __std__map_int_TH1Dp__db_datamem(Reflex::Class*);
void __std__map_int_TH1Dp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_int_TH1Dp__datamem_bld(&__std__map_int_TH1Dp__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_int_TH1Dp__funcmem_bld(&__std__map_int_TH1Dp__db_funcmem);
void __std__map_int_TH1Dp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<int,TH1D*>"), typeid(::std::map<int,TH1D*>), sizeof(::std::map<int,TH1D*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_135, Reflex::Literal("std::map<int,TH1D*>::key_type"))
  .AddTypedef(type_12275, Reflex::Literal("std::map<int,TH1D*>::mapped_type"))
  .AddTypedef(type_3009, Reflex::Literal("std::map<int,TH1D*>::value_type"))
  .AddTypedef(type_2965, Reflex::Literal("std::map<int,TH1D*>::key_compare"))
  .AddTypedef(type_3104, Reflex::Literal("std::map<int,TH1D*>::allocator_type"))
  .AddTypedef(type_3009, Reflex::Literal("std::map<int,TH1D*>::_Alloc_value_type"))
  .AddTypedef(type_3104, Reflex::Literal("std::map<int,TH1D*>::_Pair_alloc_type"))
  .AddTypedef(type_3055, Reflex::Literal("std::map<int,TH1D*>::_Rep_type"))
  .AddTypedef(type_12284, Reflex::Literal("std::map<int,TH1D*>::pointer"))
  .AddTypedef(type_12286, Reflex::Literal("std::map<int,TH1D*>::const_pointer"))
  .AddTypedef(type_12288, Reflex::Literal("std::map<int,TH1D*>::reference"))
  .AddTypedef(type_12290, Reflex::Literal("std::map<int,TH1D*>::const_reference"))
  .AddTypedef(type_2796, Reflex::Literal("std::map<int,TH1D*>::iterator"))
  .AddTypedef(type_3260, Reflex::Literal("std::map<int,TH1D*>::const_iterator"))
  .AddTypedef(type_1821, Reflex::Literal("std::map<int,TH1D*>::size_type"))
  .AddTypedef(type_715, Reflex::Literal("std::map<int,TH1D*>::difference_type"))
  .AddTypedef(type_3197, Reflex::Literal("std::map<int,TH1D*>::reverse_iterator"))
  .AddTypedef(type_3196, Reflex::Literal("std::map<int,TH1D*>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_12298, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_12299, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17288, type_17297), Reflex::Literal("map"), constructor_12300, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16585), Reflex::Literal("map"), constructor_12301, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2925, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_int_TH1Dp__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_int_TH1Dp__funcmem_bld);
}

//------Delayed data member builder for class map<int,TH1D*,std::less<int>,std::allocator<std::pair<const int, TH1D*> > > -------------------
void __std__map_int_TH1Dp__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3055, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_int_TH1Dp_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<int,TH1D*,std::less<int>,std::allocator<std::pair<const int, TH1D*> > > -------------------
void __std__map_int_TH1Dp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16583, type_16585), Reflex::Literal("operator="), operator_12302, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3104), Reflex::Literal("get_allocator"), method_12303, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2796), Reflex::Literal("begin"), method_12304, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3260), Reflex::Literal("begin"), method_12305, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2796), Reflex::Literal("end"), method_12306, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3260), Reflex::Literal("end"), method_12307, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_617), Reflex::Literal("empty"), method_12312, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821), Reflex::Literal("size"), method_12313, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821), Reflex::Literal("max_size"), method_12314, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17298, type_10740), Reflex::Literal("operator[]"), operator_12315, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17298, type_10740), Reflex::Literal("at"), method_12316, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17299, type_10740), Reflex::Literal("at"), method_12317, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3034, type_12290), Reflex::Literal("insert"), method_12318, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2796, type_2796, type_12290), Reflex::Literal("insert"), method_12319, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2796), Reflex::Literal("erase"), method_12320, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821, type_10740), Reflex::Literal("erase"), method_12321, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2796, type_2796), Reflex::Literal("erase"), method_12322, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_16583), Reflex::Literal("swap"), method_12323, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("clear"), method_12324, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2965), Reflex::Literal("key_comp"), method_12325, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2796, type_10740), Reflex::Literal("find"), method_12327, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3260, type_10740), Reflex::Literal("find"), method_12328, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821, type_10740), Reflex::Literal("count"), method_12329, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2796, type_10740), Reflex::Literal("lower_bound"), method_12330, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3260, type_10740), Reflex::Literal("lower_bound"), method_12331, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2796, type_10740), Reflex::Literal("upper_bound"), method_12332, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3260, type_10740), Reflex::Literal("upper_bound"), method_12333, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033, type_10740), Reflex::Literal("equal_range"), method_12334, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3032, type_10740), Reflex::Literal("equal_range"), method_12335, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<int>,std::allocator<std::pair<const int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
static void destructor_12360(void*, void * o, const std::vector<void*>&, void *) {
((::std::map<int,std::basic_string<char> >*)o)->::std::map<int,std::basic_string<char> >::~map();
}
static void constructor_12361( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::basic_string<char> >();
  else ::new(mem) ::std::map<int,std::basic_string<char> >();
}

static void constructor_12362( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::basic_string<char> >(*(const ::std::less<int>*)arg[0]);
  else ::new(mem) ::std::map<int,std::basic_string<char> >(*(const ::std::less<int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::basic_string<char> >(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,std::basic_string<char> > >*)arg[1]);
  else ::new(mem) ::std::map<int,std::basic_string<char> >(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,std::basic_string<char> > >*)arg[1]);
  }
}

static void constructor_12363( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::basic_string<char> >(*(const ::std::map<int,std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<int,std::basic_string<char> >(*(const ::std::map<int,std::basic_string<char> >*)arg[0]);
}

static  void operator_12364( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,std::basic_string<char> >*)o)->operator=)(*(const ::std::map<int,std::basic_string<char> >*)arg[0]);
  else   (((::std::map<int,std::basic_string<char> >*)o)->operator=)(*(const ::std::map<int,std::basic_string<char> >*)arg[0]);
}

static  void method_12365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,std::basic_string<char> > >)((((const ::std::map<int,std::basic_string<char> >*)o)->get_allocator)());
  else   (((const ::std::map<int,std::basic_string<char> >*)o)->get_allocator)();
}

static  void method_12366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > >)((((::std::map<int,std::basic_string<char> >*)o)->begin)());
  else   (((::std::map<int,std::basic_string<char> >*)o)->begin)();
}

static  void method_12367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::basic_string<char> > >)((((const ::std::map<int,std::basic_string<char> >*)o)->begin)());
  else   (((const ::std::map<int,std::basic_string<char> >*)o)->begin)();
}

static  void method_12368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > >)((((::std::map<int,std::basic_string<char> >*)o)->end)());
  else   (((::std::map<int,std::basic_string<char> >*)o)->end)();
}

static  void method_12369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::basic_string<char> > >)((((const ::std::map<int,std::basic_string<char> >*)o)->end)());
  else   (((const ::std::map<int,std::basic_string<char> >*)o)->end)();
}

static  void method_12374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<int,std::basic_string<char> >*)o)->empty)());
  else   (((const ::std::map<int,std::basic_string<char> >*)o)->empty)();
}

static  void method_12375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,std::basic_string<char> >*)o)->size)());
  else   (((const ::std::map<int,std::basic_string<char> >*)o)->size)();
}

static  void method_12376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,std::basic_string<char> >*)o)->max_size)());
  else   (((const ::std::map<int,std::basic_string<char> >*)o)->max_size)();
}

static  void operator_12377( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,std::basic_string<char> >*)o)->operator[])(*(const int*)arg[0]);
  else   (((::std::map<int,std::basic_string<char> >*)o)->operator[])(*(const int*)arg[0]);
}

static  void method_12378( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,std::basic_string<char> >*)o)->at)(*(const int*)arg[0]);
  else   (((::std::map<int,std::basic_string<char> >*)o)->at)(*(const int*)arg[0]);
}

static  void method_12379( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<int,std::basic_string<char> >*)o)->at)(*(const int*)arg[0]);
  else   (((const ::std::map<int,std::basic_string<char> >*)o)->at)(*(const int*)arg[0]);
}

static  void method_12380( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > >,bool>)((((::std::map<int,std::basic_string<char> >*)o)->insert)(*(const ::std::pair<const int,std::basic_string<char> >*)arg[0]));
  else   (((::std::map<int,std::basic_string<char> >*)o)->insert)(*(const ::std::pair<const int,std::basic_string<char> >*)arg[0]);
}

static  void method_12381( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > >)((((::std::map<int,std::basic_string<char> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > >*)arg[0],
    *(const ::std::pair<const int,std::basic_string<char> >*)arg[1]));
  else   (((::std::map<int,std::basic_string<char> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > >*)arg[0],
    *(const ::std::pair<const int,std::basic_string<char> >*)arg[1]);
}

static  void method_12382( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,std::basic_string<char> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > >*)arg[0]);
}

static  void method_12383( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((::std::map<int,std::basic_string<char> >*)o)->erase)(*(const int*)arg[0]));
  else   (((::std::map<int,std::basic_string<char> >*)o)->erase)(*(const int*)arg[0]);
}

static  void method_12384( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,std::basic_string<char> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > >*)arg[1]);
}

static  void method_12385( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,std::basic_string<char> >*)o)->swap)(*(::std::map<int,std::basic_string<char> >*)arg[0]);
}

static  void method_12386( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<int,std::basic_string<char> >*)o)->clear)();
}

static  void method_12387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<int>)((((const ::std::map<int,std::basic_string<char> >*)o)->key_comp)());
  else   (((const ::std::map<int,std::basic_string<char> >*)o)->key_comp)();
}

static  void method_12389( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > >)((((::std::map<int,std::basic_string<char> >*)o)->find)(*(const int*)arg[0]));
  else   (((::std::map<int,std::basic_string<char> >*)o)->find)(*(const int*)arg[0]);
}

static  void method_12390( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::basic_string<char> > >)((((const ::std::map<int,std::basic_string<char> >*)o)->find)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::basic_string<char> >*)o)->find)(*(const int*)arg[0]);
}

static  void method_12391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,std::basic_string<char> >*)o)->count)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::basic_string<char> >*)o)->count)(*(const int*)arg[0]);
}

static  void method_12392( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > >)((((::std::map<int,std::basic_string<char> >*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,std::basic_string<char> >*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12393( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::basic_string<char> > >)((((const ::std::map<int,std::basic_string<char> >*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::basic_string<char> >*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12394( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > >)((((::std::map<int,std::basic_string<char> >*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,std::basic_string<char> >*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12395( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::basic_string<char> > >)((((const ::std::map<int,std::basic_string<char> >*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::basic_string<char> >*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12396( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > >,std::_Rb_tree_iterator<std::pair<const int,std::basic_string<char> > > >)((((::std::map<int,std::basic_string<char> >*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::std::map<int,std::basic_string<char> >*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_12397( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const int,std::basic_string<char> > >,std::_Rb_tree_const_iterator<std::pair<const int,std::basic_string<char> > > >)((((const ::std::map<int,std::basic_string<char> >*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::basic_string<char> >*)o)->equal_range)(*(const int*)arg[0]);
}

static void method_newdel_2926( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<int,std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<int,std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<int,std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<int,std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<int,std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x19( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<int,std::basic_string<char> > >::Generate();
  else ::Reflex::Proxy< ::std::map<int,std::basic_string<char> > >::Generate();
}

//------Dictionary for class map<int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<int>,std::allocator<std::pair<const int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
void __std__map_int_std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__map_int_std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_int_std__basic_string_char_s__datamem_bld(&__std__map_int_std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_int_std__basic_string_char_s__funcmem_bld(&__std__map_int_std__basic_string_char_s__db_funcmem);
void __std__map_int_std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<int,std::basic_string<char> >"), typeid(::std::map<int,std::basic_string<char> >), sizeof(::std::map<int,std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_135, Reflex::Literal("std::map<int,std::basic_string<char> >::key_type"))
  .AddTypedef(type_2776, Reflex::Literal("std::map<int,std::basic_string<char> >::mapped_type"))
  .AddTypedef(type_3012, Reflex::Literal("std::map<int,std::basic_string<char> >::value_type"))
  .AddTypedef(type_2965, Reflex::Literal("std::map<int,std::basic_string<char> >::key_compare"))
  .AddTypedef(type_3107, Reflex::Literal("std::map<int,std::basic_string<char> >::allocator_type"))
  .AddTypedef(type_3012, Reflex::Literal("std::map<int,std::basic_string<char> >::_Alloc_value_type"))
  .AddTypedef(type_3107, Reflex::Literal("std::map<int,std::basic_string<char> >::_Pair_alloc_type"))
  .AddTypedef(type_3050, Reflex::Literal("std::map<int,std::basic_string<char> >::_Rep_type"))
  .AddTypedef(type_12346, Reflex::Literal("std::map<int,std::basic_string<char> >::pointer"))
  .AddTypedef(type_12348, Reflex::Literal("std::map<int,std::basic_string<char> >::const_pointer"))
  .AddTypedef(type_12350, Reflex::Literal("std::map<int,std::basic_string<char> >::reference"))
  .AddTypedef(type_12352, Reflex::Literal("std::map<int,std::basic_string<char> >::const_reference"))
  .AddTypedef(type_2791, Reflex::Literal("std::map<int,std::basic_string<char> >::iterator"))
  .AddTypedef(type_3255, Reflex::Literal("std::map<int,std::basic_string<char> >::const_iterator"))
  .AddTypedef(type_1821, Reflex::Literal("std::map<int,std::basic_string<char> >::size_type"))
  .AddTypedef(type_715, Reflex::Literal("std::map<int,std::basic_string<char> >::difference_type"))
  .AddTypedef(type_3187, Reflex::Literal("std::map<int,std::basic_string<char> >::reverse_iterator"))
  .AddTypedef(type_3186, Reflex::Literal("std::map<int,std::basic_string<char> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_12360, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_12361, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17288, type_17301), Reflex::Literal("map"), constructor_12362, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17302), Reflex::Literal("map"), constructor_12363, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2926, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x19, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_int_std__basic_string_char_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_int_std__basic_string_char_s__funcmem_bld);
}

//------Delayed data member builder for class map<int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<int>,std::allocator<std::pair<const int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__map_int_std__basic_string_char_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3050, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_int_std__basic_string_char_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<int>,std::allocator<std::pair<const int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__map_int_std__basic_string_char_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17303, type_17302), Reflex::Literal("operator="), operator_12364, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3107), Reflex::Literal("get_allocator"), method_12365, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791), Reflex::Literal("begin"), method_12366, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3255), Reflex::Literal("begin"), method_12367, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791), Reflex::Literal("end"), method_12368, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3255), Reflex::Literal("end"), method_12369, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_617), Reflex::Literal("empty"), method_12374, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821), Reflex::Literal("size"), method_12375, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821), Reflex::Literal("max_size"), method_12376, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11615, type_10740), Reflex::Literal("operator[]"), operator_12377, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11615, type_10740), Reflex::Literal("at"), method_12378, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14882, type_10740), Reflex::Literal("at"), method_12379, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3014, type_12352), Reflex::Literal("insert"), method_12380, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791, type_2791, type_12352), Reflex::Literal("insert"), method_12381, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2791), Reflex::Literal("erase"), method_12382, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821, type_10740), Reflex::Literal("erase"), method_12383, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2791, type_2791), Reflex::Literal("erase"), method_12384, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_17303), Reflex::Literal("swap"), method_12385, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("clear"), method_12386, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2965), Reflex::Literal("key_comp"), method_12387, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791, type_10740), Reflex::Literal("find"), method_12389, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3255, type_10740), Reflex::Literal("find"), method_12390, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821, type_10740), Reflex::Literal("count"), method_12391, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791, type_10740), Reflex::Literal("lower_bound"), method_12392, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3255, type_10740), Reflex::Literal("lower_bound"), method_12393, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791, type_10740), Reflex::Literal("upper_bound"), method_12394, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3255, type_10740), Reflex::Literal("upper_bound"), method_12395, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3013, type_10740), Reflex::Literal("equal_range"), method_12396, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3011, type_10740), Reflex::Literal("equal_range"), method_12397, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<int,std::pair<int, int>,std::less<int>,std::allocator<std::pair<const int, std::pair<int, int> > > > -------------------------------
static void destructor_12422(void*, void * o, const std::vector<void*>&, void *) {
((::std::map<int,std::pair<int,int> >*)o)->::std::map<int,std::pair<int,int> >::~map();
}
static void constructor_12423( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::pair<int,int> >();
  else ::new(mem) ::std::map<int,std::pair<int,int> >();
}

static void constructor_12424( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::pair<int,int> >(*(const ::std::less<int>*)arg[0]);
  else ::new(mem) ::std::map<int,std::pair<int,int> >(*(const ::std::less<int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::pair<int,int> >(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,std::pair<int,int> > >*)arg[1]);
  else ::new(mem) ::std::map<int,std::pair<int,int> >(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,std::pair<int,int> > >*)arg[1]);
  }
}

static void constructor_12425( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::pair<int,int> >(*(const ::std::map<int,std::pair<int,int> >*)arg[0]);
  else ::new(mem) ::std::map<int,std::pair<int,int> >(*(const ::std::map<int,std::pair<int,int> >*)arg[0]);
}

static  void operator_12426( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,std::pair<int,int> >*)o)->operator=)(*(const ::std::map<int,std::pair<int,int> >*)arg[0]);
  else   (((::std::map<int,std::pair<int,int> >*)o)->operator=)(*(const ::std::map<int,std::pair<int,int> >*)arg[0]);
}

static  void method_12427( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,std::pair<int,int> > >)((((const ::std::map<int,std::pair<int,int> >*)o)->get_allocator)());
  else   (((const ::std::map<int,std::pair<int,int> >*)o)->get_allocator)();
}

static  void method_12428( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > >)((((::std::map<int,std::pair<int,int> >*)o)->begin)());
  else   (((::std::map<int,std::pair<int,int> >*)o)->begin)();
}

static  void method_12429( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<int,int> > >)((((const ::std::map<int,std::pair<int,int> >*)o)->begin)());
  else   (((const ::std::map<int,std::pair<int,int> >*)o)->begin)();
}

static  void method_12430( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > >)((((::std::map<int,std::pair<int,int> >*)o)->end)());
  else   (((::std::map<int,std::pair<int,int> >*)o)->end)();
}

static  void method_12431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<int,int> > >)((((const ::std::map<int,std::pair<int,int> >*)o)->end)());
  else   (((const ::std::map<int,std::pair<int,int> >*)o)->end)();
}

static  void method_12436( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<int,std::pair<int,int> >*)o)->empty)());
  else   (((const ::std::map<int,std::pair<int,int> >*)o)->empty)();
}

static  void method_12437( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,std::pair<int,int> >*)o)->size)());
  else   (((const ::std::map<int,std::pair<int,int> >*)o)->size)();
}

static  void method_12438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,std::pair<int,int> >*)o)->max_size)());
  else   (((const ::std::map<int,std::pair<int,int> >*)o)->max_size)();
}

static  void operator_12439( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,std::pair<int,int> >*)o)->operator[])(*(const int*)arg[0]);
  else   (((::std::map<int,std::pair<int,int> >*)o)->operator[])(*(const int*)arg[0]);
}

static  void method_12440( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,std::pair<int,int> >*)o)->at)(*(const int*)arg[0]);
  else   (((::std::map<int,std::pair<int,int> >*)o)->at)(*(const int*)arg[0]);
}

static  void method_12441( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<int,std::pair<int,int> >*)o)->at)(*(const int*)arg[0]);
  else   (((const ::std::map<int,std::pair<int,int> >*)o)->at)(*(const int*)arg[0]);
}

static  void method_12442( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > >,bool>)((((::std::map<int,std::pair<int,int> >*)o)->insert)(*(const ::std::pair<const int,std::pair<int,int> >*)arg[0]));
  else   (((::std::map<int,std::pair<int,int> >*)o)->insert)(*(const ::std::pair<const int,std::pair<int,int> >*)arg[0]);
}

static  void method_12443( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > >)((((::std::map<int,std::pair<int,int> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > >*)arg[0],
    *(const ::std::pair<const int,std::pair<int,int> >*)arg[1]));
  else   (((::std::map<int,std::pair<int,int> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > >*)arg[0],
    *(const ::std::pair<const int,std::pair<int,int> >*)arg[1]);
}

static  void method_12444( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,std::pair<int,int> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > >*)arg[0]);
}

static  void method_12445( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((::std::map<int,std::pair<int,int> >*)o)->erase)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<int,int> >*)o)->erase)(*(const int*)arg[0]);
}

static  void method_12446( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,std::pair<int,int> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > >*)arg[1]);
}

static  void method_12447( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,std::pair<int,int> >*)o)->swap)(*(::std::map<int,std::pair<int,int> >*)arg[0]);
}

static  void method_12448( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<int,std::pair<int,int> >*)o)->clear)();
}

static  void method_12449( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<int>)((((const ::std::map<int,std::pair<int,int> >*)o)->key_comp)());
  else   (((const ::std::map<int,std::pair<int,int> >*)o)->key_comp)();
}

static  void method_12451( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > >)((((::std::map<int,std::pair<int,int> >*)o)->find)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<int,int> >*)o)->find)(*(const int*)arg[0]);
}

static  void method_12452( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<int,int> > >)((((const ::std::map<int,std::pair<int,int> >*)o)->find)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<int,int> >*)o)->find)(*(const int*)arg[0]);
}

static  void method_12453( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,std::pair<int,int> >*)o)->count)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<int,int> >*)o)->count)(*(const int*)arg[0]);
}

static  void method_12454( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > >)((((::std::map<int,std::pair<int,int> >*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<int,int> >*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12455( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<int,int> > >)((((const ::std::map<int,std::pair<int,int> >*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<int,int> >*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12456( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > >)((((::std::map<int,std::pair<int,int> >*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<int,int> >*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12457( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<int,int> > >)((((const ::std::map<int,std::pair<int,int> >*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<int,int> >*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12458( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > >,std::_Rb_tree_iterator<std::pair<const int,std::pair<int,int> > > >)((((::std::map<int,std::pair<int,int> >*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<int,int> >*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_12459( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const int,std::pair<int,int> > >,std::_Rb_tree_const_iterator<std::pair<const int,std::pair<int,int> > > >)((((const ::std::map<int,std::pair<int,int> >*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<int,int> >*)o)->equal_range)(*(const int*)arg[0]);
}

static void method_newdel_2927( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<int,int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<int,int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<int,int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<int,int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<int,int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x21( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<int,std::pair<int,int> > >::Generate();
  else ::Reflex::Proxy< ::std::map<int,std::pair<int,int> > >::Generate();
}

//------Dictionary for class map<int,std::pair<int, int>,std::less<int>,std::allocator<std::pair<const int, std::pair<int, int> > > > -------------------------------
void __std__map_int_std__pair_int_int_s__db_datamem(Reflex::Class*);
void __std__map_int_std__pair_int_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_int_std__pair_int_int_s__datamem_bld(&__std__map_int_std__pair_int_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_int_std__pair_int_int_s__funcmem_bld(&__std__map_int_std__pair_int_int_s__db_funcmem);
void __std__map_int_std__pair_int_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<int,std::pair<int,int> >"), typeid(::std::map<int,std::pair<int,int> >), sizeof(::std::map<int,std::pair<int,int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_135, Reflex::Literal("std::map<int,std::pair<int,int> >::key_type"))
  .AddTypedef(type_3019, Reflex::Literal("std::map<int,std::pair<int,int> >::mapped_type"))
  .AddTypedef(type_3016, Reflex::Literal("std::map<int,std::pair<int,int> >::value_type"))
  .AddTypedef(type_2965, Reflex::Literal("std::map<int,std::pair<int,int> >::key_compare"))
  .AddTypedef(type_3109, Reflex::Literal("std::map<int,std::pair<int,int> >::allocator_type"))
  .AddTypedef(type_3016, Reflex::Literal("std::map<int,std::pair<int,int> >::_Alloc_value_type"))
  .AddTypedef(type_3109, Reflex::Literal("std::map<int,std::pair<int,int> >::_Pair_alloc_type"))
  .AddTypedef(type_3051, Reflex::Literal("std::map<int,std::pair<int,int> >::_Rep_type"))
  .AddTypedef(type_12408, Reflex::Literal("std::map<int,std::pair<int,int> >::pointer"))
  .AddTypedef(type_12410, Reflex::Literal("std::map<int,std::pair<int,int> >::const_pointer"))
  .AddTypedef(type_12412, Reflex::Literal("std::map<int,std::pair<int,int> >::reference"))
  .AddTypedef(type_12414, Reflex::Literal("std::map<int,std::pair<int,int> >::const_reference"))
  .AddTypedef(type_2792, Reflex::Literal("std::map<int,std::pair<int,int> >::iterator"))
  .AddTypedef(type_3256, Reflex::Literal("std::map<int,std::pair<int,int> >::const_iterator"))
  .AddTypedef(type_1821, Reflex::Literal("std::map<int,std::pair<int,int> >::size_type"))
  .AddTypedef(type_715, Reflex::Literal("std::map<int,std::pair<int,int> >::difference_type"))
  .AddTypedef(type_3189, Reflex::Literal("std::map<int,std::pair<int,int> >::reverse_iterator"))
  .AddTypedef(type_3188, Reflex::Literal("std::map<int,std::pair<int,int> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_12422, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_12423, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17288, type_17305), Reflex::Literal("map"), constructor_12424, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17306), Reflex::Literal("map"), constructor_12425, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2927, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x21, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_int_std__pair_int_int_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_int_std__pair_int_int_s__funcmem_bld);
}

//------Delayed data member builder for class map<int,std::pair<int, int>,std::less<int>,std::allocator<std::pair<const int, std::pair<int, int> > > > -------------------
void __std__map_int_std__pair_int_int_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3051, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_int_std__pair_int_int_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<int,std::pair<int, int>,std::less<int>,std::allocator<std::pair<const int, std::pair<int, int> > > > -------------------
void __std__map_int_std__pair_int_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17307, type_17306), Reflex::Literal("operator="), operator_12426, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3109), Reflex::Literal("get_allocator"), method_12427, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2792), Reflex::Literal("begin"), method_12428, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3256), Reflex::Literal("begin"), method_12429, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2792), Reflex::Literal("end"), method_12430, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3256), Reflex::Literal("end"), method_12431, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_617), Reflex::Literal("empty"), method_12436, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821), Reflex::Literal("size"), method_12437, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821), Reflex::Literal("max_size"), method_12438, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10867, type_10740), Reflex::Literal("operator[]"), operator_12439, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10867, type_10740), Reflex::Literal("at"), method_12440, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10869, type_10740), Reflex::Literal("at"), method_12441, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3018, type_12414), Reflex::Literal("insert"), method_12442, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2792, type_2792, type_12414), Reflex::Literal("insert"), method_12443, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2792), Reflex::Literal("erase"), method_12444, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821, type_10740), Reflex::Literal("erase"), method_12445, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2792, type_2792), Reflex::Literal("erase"), method_12446, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_17307), Reflex::Literal("swap"), method_12447, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("clear"), method_12448, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2965), Reflex::Literal("key_comp"), method_12449, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2792, type_10740), Reflex::Literal("find"), method_12451, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3256, type_10740), Reflex::Literal("find"), method_12452, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821, type_10740), Reflex::Literal("count"), method_12453, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2792, type_10740), Reflex::Literal("lower_bound"), method_12454, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3256, type_10740), Reflex::Literal("lower_bound"), method_12455, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2792, type_10740), Reflex::Literal("upper_bound"), method_12456, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3256, type_10740), Reflex::Literal("upper_bound"), method_12457, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3017, type_10740), Reflex::Literal("equal_range"), method_12458, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3015, type_10740), Reflex::Literal("equal_range"), method_12459, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<int,int,std::less<int>,std::allocator<std::pair<const int, int> > > -------------------------------
static void destructor_12484(void*, void * o, const std::vector<void*>&, void *) {
((::std::map<int,int>*)o)->::std::map<int,int>::~map();
}
static void constructor_12485( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,int>();
  else ::new(mem) ::std::map<int,int>();
}

static void constructor_12486( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,int>(*(const ::std::less<int>*)arg[0]);
  else ::new(mem) ::std::map<int,int>(*(const ::std::less<int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,int>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,int> >*)arg[1]);
  else ::new(mem) ::std::map<int,int>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,int> >*)arg[1]);
  }
}

static void constructor_12487( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,int>(*(const ::std::map<int,int>*)arg[0]);
  else ::new(mem) ::std::map<int,int>(*(const ::std::map<int,int>*)arg[0]);
}

static  void operator_12488( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,int>*)o)->operator=)(*(const ::std::map<int,int>*)arg[0]);
  else   (((::std::map<int,int>*)o)->operator=)(*(const ::std::map<int,int>*)arg[0]);
}

static  void method_12489( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,int> >)((((const ::std::map<int,int>*)o)->get_allocator)());
  else   (((const ::std::map<int,int>*)o)->get_allocator)();
}

static  void method_12490( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,int> >)((((::std::map<int,int>*)o)->begin)());
  else   (((::std::map<int,int>*)o)->begin)();
}

static  void method_12491( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,int> >)((((const ::std::map<int,int>*)o)->begin)());
  else   (((const ::std::map<int,int>*)o)->begin)();
}

static  void method_12492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,int> >)((((::std::map<int,int>*)o)->end)());
  else   (((::std::map<int,int>*)o)->end)();
}

static  void method_12493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,int> >)((((const ::std::map<int,int>*)o)->end)());
  else   (((const ::std::map<int,int>*)o)->end)();
}

static  void method_12498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<int,int>*)o)->empty)());
  else   (((const ::std::map<int,int>*)o)->empty)();
}

static  void method_12499( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,int>*)o)->size)());
  else   (((const ::std::map<int,int>*)o)->size)();
}

static  void method_12500( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,int>*)o)->max_size)());
  else   (((const ::std::map<int,int>*)o)->max_size)();
}

static  void operator_12501( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,int>*)o)->operator[])(*(const int*)arg[0]);
  else   (((::std::map<int,int>*)o)->operator[])(*(const int*)arg[0]);
}

static  void method_12502( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,int>*)o)->at)(*(const int*)arg[0]);
  else   (((::std::map<int,int>*)o)->at)(*(const int*)arg[0]);
}

static  void method_12503( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<int,int>*)o)->at)(*(const int*)arg[0]);
  else   (((const ::std::map<int,int>*)o)->at)(*(const int*)arg[0]);
}

static  void method_12504( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,int> >,bool>)((((::std::map<int,int>*)o)->insert)(*(const ::std::pair<const int,int>*)arg[0]));
  else   (((::std::map<int,int>*)o)->insert)(*(const ::std::pair<const int,int>*)arg[0]);
}

static  void method_12505( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,int> >)((((::std::map<int,int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,int> >*)arg[0],
    *(const ::std::pair<const int,int>*)arg[1]));
  else   (((::std::map<int,int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,int> >*)arg[0],
    *(const ::std::pair<const int,int>*)arg[1]);
}

static  void method_12506( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,int> >*)arg[0]);
}

static  void method_12507( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((::std::map<int,int>*)o)->erase)(*(const int*)arg[0]));
  else   (((::std::map<int,int>*)o)->erase)(*(const int*)arg[0]);
}

static  void method_12508( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,int> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const int,int> >*)arg[1]);
}

static  void method_12509( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,int>*)o)->swap)(*(::std::map<int,int>*)arg[0]);
}

static  void method_12510( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<int,int>*)o)->clear)();
}

static  void method_12511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<int>)((((const ::std::map<int,int>*)o)->key_comp)());
  else   (((const ::std::map<int,int>*)o)->key_comp)();
}

static  void method_12513( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,int> >)((((::std::map<int,int>*)o)->find)(*(const int*)arg[0]));
  else   (((::std::map<int,int>*)o)->find)(*(const int*)arg[0]);
}

static  void method_12514( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,int> >)((((const ::std::map<int,int>*)o)->find)(*(const int*)arg[0]));
  else   (((const ::std::map<int,int>*)o)->find)(*(const int*)arg[0]);
}

static  void method_12515( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,int>*)o)->count)(*(const int*)arg[0]));
  else   (((const ::std::map<int,int>*)o)->count)(*(const int*)arg[0]);
}

static  void method_12516( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,int> >)((((::std::map<int,int>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,int>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12517( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,int> >)((((const ::std::map<int,int>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,int>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12518( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,int> >)((((::std::map<int,int>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,int>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12519( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,int> >)((((const ::std::map<int,int>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,int>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12520( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,int> >,std::_Rb_tree_iterator<std::pair<const int,int> > >)((((::std::map<int,int>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::std::map<int,int>*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_12521( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const int,int> >,std::_Rb_tree_const_iterator<std::pair<const int,int> > >)((((const ::std::map<int,int>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::std::map<int,int>*)o)->equal_range)(*(const int*)arg[0]);
}

static void method_newdel_2928( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<int,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<int,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<int,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<int,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<int,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x23( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<int,int> >::Generate();
  else ::Reflex::Proxy< ::std::map<int,int> >::Generate();
}

//------Dictionary for class map<int,int,std::less<int>,std::allocator<std::pair<const int, int> > > -------------------------------
void __std__map_int_int__db_datamem(Reflex::Class*);
void __std__map_int_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_int_int__datamem_bld(&__std__map_int_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_int_int__funcmem_bld(&__std__map_int_int__db_funcmem);
void __std__map_int_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<int,int>"), typeid(::std::map<int,int>), sizeof(::std::map<int,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_135, Reflex::Literal("std::map<int,int>::key_type"))
  .AddTypedef(type_135, Reflex::Literal("std::map<int,int>::mapped_type"))
  .AddTypedef(type_3020, Reflex::Literal("std::map<int,int>::value_type"))
  .AddTypedef(type_2965, Reflex::Literal("std::map<int,int>::key_compare"))
  .AddTypedef(type_3110, Reflex::Literal("std::map<int,int>::allocator_type"))
  .AddTypedef(type_3020, Reflex::Literal("std::map<int,int>::_Alloc_value_type"))
  .AddTypedef(type_3110, Reflex::Literal("std::map<int,int>::_Pair_alloc_type"))
  .AddTypedef(type_3057, Reflex::Literal("std::map<int,int>::_Rep_type"))
  .AddTypedef(type_12470, Reflex::Literal("std::map<int,int>::pointer"))
  .AddTypedef(type_12472, Reflex::Literal("std::map<int,int>::const_pointer"))
  .AddTypedef(type_12474, Reflex::Literal("std::map<int,int>::reference"))
  .AddTypedef(type_12476, Reflex::Literal("std::map<int,int>::const_reference"))
  .AddTypedef(type_2798, Reflex::Literal("std::map<int,int>::iterator"))
  .AddTypedef(type_3262, Reflex::Literal("std::map<int,int>::const_iterator"))
  .AddTypedef(type_1821, Reflex::Literal("std::map<int,int>::size_type"))
  .AddTypedef(type_715, Reflex::Literal("std::map<int,int>::difference_type"))
  .AddTypedef(type_3201, Reflex::Literal("std::map<int,int>::reverse_iterator"))
  .AddTypedef(type_3200, Reflex::Literal("std::map<int,int>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_12484, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_12485, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17288, type_17309), Reflex::Literal("map"), constructor_12486, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17310), Reflex::Literal("map"), constructor_12487, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2928, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x23, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_int_int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_int_int__funcmem_bld);
}

//------Delayed data member builder for class map<int,int,std::less<int>,std::allocator<std::pair<const int, int> > > -------------------
void __std__map_int_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3057, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_int_int_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<int,int,std::less<int>,std::allocator<std::pair<const int, int> > > -------------------
void __std__map_int_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17311, type_17310), Reflex::Literal("operator="), operator_12488, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3110), Reflex::Literal("get_allocator"), method_12489, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2798), Reflex::Literal("begin"), method_12490, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3262), Reflex::Literal("begin"), method_12491, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2798), Reflex::Literal("end"), method_12492, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3262), Reflex::Literal("end"), method_12493, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_617), Reflex::Literal("empty"), method_12498, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821), Reflex::Literal("size"), method_12499, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821), Reflex::Literal("max_size"), method_12500, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10738, type_10740), Reflex::Literal("operator[]"), operator_12501, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10738, type_10740), Reflex::Literal("at"), method_12502, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10740, type_10740), Reflex::Literal("at"), method_12503, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3042, type_12476), Reflex::Literal("insert"), method_12504, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2798, type_2798, type_12476), Reflex::Literal("insert"), method_12505, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2798), Reflex::Literal("erase"), method_12506, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821, type_10740), Reflex::Literal("erase"), method_12507, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2798, type_2798), Reflex::Literal("erase"), method_12508, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_17311), Reflex::Literal("swap"), method_12509, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("clear"), method_12510, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2965), Reflex::Literal("key_comp"), method_12511, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2798, type_10740), Reflex::Literal("find"), method_12513, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3262, type_10740), Reflex::Literal("find"), method_12514, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821, type_10740), Reflex::Literal("count"), method_12515, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2798, type_10740), Reflex::Literal("lower_bound"), method_12516, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3262, type_10740), Reflex::Literal("lower_bound"), method_12517, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2798, type_10740), Reflex::Literal("upper_bound"), method_12518, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3262, type_10740), Reflex::Literal("upper_bound"), method_12519, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3041, type_10740), Reflex::Literal("equal_range"), method_12520, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3040, type_10740), Reflex::Literal("equal_range"), method_12521, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<int,double,std::less<int>,std::allocator<std::pair<const int, double> > > -------------------------------
static void destructor_12546(void*, void * o, const std::vector<void*>&, void *) {
((::std::map<int,double>*)o)->::std::map<int,double>::~map();
}
static void constructor_12547( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,double>();
  else ::new(mem) ::std::map<int,double>();
}

static void constructor_12548( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,double>(*(const ::std::less<int>*)arg[0]);
  else ::new(mem) ::std::map<int,double>(*(const ::std::less<int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,double>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,double> >*)arg[1]);
  else ::new(mem) ::std::map<int,double>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,double> >*)arg[1]);
  }
}

static void constructor_12549( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,double>(*(const ::std::map<int,double>*)arg[0]);
  else ::new(mem) ::std::map<int,double>(*(const ::std::map<int,double>*)arg[0]);
}

static  void operator_12550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,double>*)o)->operator=)(*(const ::std::map<int,double>*)arg[0]);
  else   (((::std::map<int,double>*)o)->operator=)(*(const ::std::map<int,double>*)arg[0]);
}

static  void method_12551( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,double> >)((((const ::std::map<int,double>*)o)->get_allocator)());
  else   (((const ::std::map<int,double>*)o)->get_allocator)();
}

static  void method_12552( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,double> >)((((::std::map<int,double>*)o)->begin)());
  else   (((::std::map<int,double>*)o)->begin)();
}

static  void method_12553( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,double> >)((((const ::std::map<int,double>*)o)->begin)());
  else   (((const ::std::map<int,double>*)o)->begin)();
}

static  void method_12554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,double> >)((((::std::map<int,double>*)o)->end)());
  else   (((::std::map<int,double>*)o)->end)();
}

static  void method_12555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,double> >)((((const ::std::map<int,double>*)o)->end)());
  else   (((const ::std::map<int,double>*)o)->end)();
}

static  void method_12560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<int,double>*)o)->empty)());
  else   (((const ::std::map<int,double>*)o)->empty)();
}

static  void method_12561( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,double>*)o)->size)());
  else   (((const ::std::map<int,double>*)o)->size)();
}

static  void method_12562( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,double>*)o)->max_size)());
  else   (((const ::std::map<int,double>*)o)->max_size)();
}

static  void operator_12563( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,double>*)o)->operator[])(*(const int*)arg[0]);
  else   (((::std::map<int,double>*)o)->operator[])(*(const int*)arg[0]);
}

static  void method_12564( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,double>*)o)->at)(*(const int*)arg[0]);
  else   (((::std::map<int,double>*)o)->at)(*(const int*)arg[0]);
}

static  void method_12565( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<int,double>*)o)->at)(*(const int*)arg[0]);
  else   (((const ::std::map<int,double>*)o)->at)(*(const int*)arg[0]);
}

static  void method_12566( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,double> >,bool>)((((::std::map<int,double>*)o)->insert)(*(const ::std::pair<const int,double>*)arg[0]));
  else   (((::std::map<int,double>*)o)->insert)(*(const ::std::pair<const int,double>*)arg[0]);
}

static  void method_12567( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,double> >)((((::std::map<int,double>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,double> >*)arg[0],
    *(const ::std::pair<const int,double>*)arg[1]));
  else   (((::std::map<int,double>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,double> >*)arg[0],
    *(const ::std::pair<const int,double>*)arg[1]);
}

static  void method_12568( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,double>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,double> >*)arg[0]);
}

static  void method_12569( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((::std::map<int,double>*)o)->erase)(*(const int*)arg[0]));
  else   (((::std::map<int,double>*)o)->erase)(*(const int*)arg[0]);
}

static  void method_12570( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,double>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,double> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const int,double> >*)arg[1]);
}

static  void method_12571( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,double>*)o)->swap)(*(::std::map<int,double>*)arg[0]);
}

static  void method_12572( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<int,double>*)o)->clear)();
}

static  void method_12573( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<int>)((((const ::std::map<int,double>*)o)->key_comp)());
  else   (((const ::std::map<int,double>*)o)->key_comp)();
}

static  void method_12575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,double> >)((((::std::map<int,double>*)o)->find)(*(const int*)arg[0]));
  else   (((::std::map<int,double>*)o)->find)(*(const int*)arg[0]);
}

static  void method_12576( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,double> >)((((const ::std::map<int,double>*)o)->find)(*(const int*)arg[0]));
  else   (((const ::std::map<int,double>*)o)->find)(*(const int*)arg[0]);
}

static  void method_12577( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,double>*)o)->count)(*(const int*)arg[0]));
  else   (((const ::std::map<int,double>*)o)->count)(*(const int*)arg[0]);
}

static  void method_12578( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,double> >)((((::std::map<int,double>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,double>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12579( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,double> >)((((const ::std::map<int,double>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,double>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12580( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,double> >)((((::std::map<int,double>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,double>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12581( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,double> >)((((const ::std::map<int,double>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,double>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12582( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,double> >,std::_Rb_tree_iterator<std::pair<const int,double> > >)((((::std::map<int,double>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::std::map<int,double>*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_12583( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const int,double> >,std::_Rb_tree_const_iterator<std::pair<const int,double> > >)((((const ::std::map<int,double>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::std::map<int,double>*)o)->equal_range)(*(const int*)arg[0]);
}

static void method_newdel_2929( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<int,double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<int,double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<int,double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<int,double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<int,double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x25( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<int,double> >::Generate();
  else ::Reflex::Proxy< ::std::map<int,double> >::Generate();
}

//------Dictionary for class map<int,double,std::less<int>,std::allocator<std::pair<const int, double> > > -------------------------------
void __std__map_int_double__db_datamem(Reflex::Class*);
void __std__map_int_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_int_double__datamem_bld(&__std__map_int_double__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_int_double__funcmem_bld(&__std__map_int_double__db_funcmem);
void __std__map_int_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<int,double>"), typeid(::std::map<int,double>), sizeof(::std::map<int,double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_135, Reflex::Literal("std::map<int,double>::key_type"))
  .AddTypedef(type_220, Reflex::Literal("std::map<int,double>::mapped_type"))
  .AddTypedef(type_3021, Reflex::Literal("std::map<int,double>::value_type"))
  .AddTypedef(type_2965, Reflex::Literal("std::map<int,double>::key_compare"))
  .AddTypedef(type_3111, Reflex::Literal("std::map<int,double>::allocator_type"))
  .AddTypedef(type_3021, Reflex::Literal("std::map<int,double>::_Alloc_value_type"))
  .AddTypedef(type_3111, Reflex::Literal("std::map<int,double>::_Pair_alloc_type"))
  .AddTypedef(type_3056, Reflex::Literal("std::map<int,double>::_Rep_type"))
  .AddTypedef(type_12532, Reflex::Literal("std::map<int,double>::pointer"))
  .AddTypedef(type_12534, Reflex::Literal("std::map<int,double>::const_pointer"))
  .AddTypedef(type_12536, Reflex::Literal("std::map<int,double>::reference"))
  .AddTypedef(type_12538, Reflex::Literal("std::map<int,double>::const_reference"))
  .AddTypedef(type_2797, Reflex::Literal("std::map<int,double>::iterator"))
  .AddTypedef(type_3261, Reflex::Literal("std::map<int,double>::const_iterator"))
  .AddTypedef(type_1821, Reflex::Literal("std::map<int,double>::size_type"))
  .AddTypedef(type_715, Reflex::Literal("std::map<int,double>::difference_type"))
  .AddTypedef(type_3199, Reflex::Literal("std::map<int,double>::reverse_iterator"))
  .AddTypedef(type_3198, Reflex::Literal("std::map<int,double>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_12546, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_12547, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17288, type_17313), Reflex::Literal("map"), constructor_12548, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17314), Reflex::Literal("map"), constructor_12549, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2929, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x25, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_int_double__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_int_double__funcmem_bld);
}

//------Delayed data member builder for class map<int,double,std::less<int>,std::allocator<std::pair<const int, double> > > -------------------
void __std__map_int_double__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3056, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_int_double_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<int,double,std::less<int>,std::allocator<std::pair<const int, double> > > -------------------
void __std__map_int_double__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17315, type_17314), Reflex::Literal("operator="), operator_12550, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3111), Reflex::Literal("get_allocator"), method_12551, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2797), Reflex::Literal("begin"), method_12552, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3261), Reflex::Literal("begin"), method_12553, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2797), Reflex::Literal("end"), method_12554, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3261), Reflex::Literal("end"), method_12555, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_617), Reflex::Literal("empty"), method_12560, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821), Reflex::Literal("size"), method_12561, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821), Reflex::Literal("max_size"), method_12562, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10802, type_10740), Reflex::Literal("operator[]"), operator_12563, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10802, type_10740), Reflex::Literal("at"), method_12564, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10804, type_10740), Reflex::Literal("at"), method_12565, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3038, type_12538), Reflex::Literal("insert"), method_12566, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2797, type_2797, type_12538), Reflex::Literal("insert"), method_12567, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2797), Reflex::Literal("erase"), method_12568, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821, type_10740), Reflex::Literal("erase"), method_12569, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2797, type_2797), Reflex::Literal("erase"), method_12570, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_17315), Reflex::Literal("swap"), method_12571, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("clear"), method_12572, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2965), Reflex::Literal("key_comp"), method_12573, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2797, type_10740), Reflex::Literal("find"), method_12575, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3261, type_10740), Reflex::Literal("find"), method_12576, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821, type_10740), Reflex::Literal("count"), method_12577, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2797, type_10740), Reflex::Literal("lower_bound"), method_12578, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3261, type_10740), Reflex::Literal("lower_bound"), method_12579, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2797, type_10740), Reflex::Literal("upper_bound"), method_12580, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3261, type_10740), Reflex::Literal("upper_bound"), method_12581, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_10740), Reflex::Literal("equal_range"), method_12582, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3036, type_10740), Reflex::Literal("equal_range"), method_12583, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<int,std::vector<int, std::allocator<int> >,std::less<int>,std::allocator<std::pair<const int, std::vector<int, std::allocator<int> > > > > -------------------------------
static void destructor_12608(void*, void * o, const std::vector<void*>&, void *) {
((::std::map<int,std::vector<int> >*)o)->::std::map<int,std::vector<int> >::~map();
}
static void constructor_12609( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::vector<int> >();
  else ::new(mem) ::std::map<int,std::vector<int> >();
}

static void constructor_12610( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::vector<int> >(*(const ::std::less<int>*)arg[0]);
  else ::new(mem) ::std::map<int,std::vector<int> >(*(const ::std::less<int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::vector<int> >(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,std::vector<int> > >*)arg[1]);
  else ::new(mem) ::std::map<int,std::vector<int> >(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,std::vector<int> > >*)arg[1]);
  }
}

static void constructor_12611( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::vector<int> >(*(const ::std::map<int,std::vector<int> >*)arg[0]);
  else ::new(mem) ::std::map<int,std::vector<int> >(*(const ::std::map<int,std::vector<int> >*)arg[0]);
}

static  void operator_12612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,std::vector<int> >*)o)->operator=)(*(const ::std::map<int,std::vector<int> >*)arg[0]);
  else   (((::std::map<int,std::vector<int> >*)o)->operator=)(*(const ::std::map<int,std::vector<int> >*)arg[0]);
}

static  void method_12613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,std::vector<int> > >)((((const ::std::map<int,std::vector<int> >*)o)->get_allocator)());
  else   (((const ::std::map<int,std::vector<int> >*)o)->get_allocator)();
}

static  void method_12614( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > >)((((::std::map<int,std::vector<int> >*)o)->begin)());
  else   (((::std::map<int,std::vector<int> >*)o)->begin)();
}

static  void method_12615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::vector<int> > >)((((const ::std::map<int,std::vector<int> >*)o)->begin)());
  else   (((const ::std::map<int,std::vector<int> >*)o)->begin)();
}

static  void method_12616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > >)((((::std::map<int,std::vector<int> >*)o)->end)());
  else   (((::std::map<int,std::vector<int> >*)o)->end)();
}

static  void method_12617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::vector<int> > >)((((const ::std::map<int,std::vector<int> >*)o)->end)());
  else   (((const ::std::map<int,std::vector<int> >*)o)->end)();
}

static  void method_12622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<int,std::vector<int> >*)o)->empty)());
  else   (((const ::std::map<int,std::vector<int> >*)o)->empty)();
}

static  void method_12623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,std::vector<int> >*)o)->size)());
  else   (((const ::std::map<int,std::vector<int> >*)o)->size)();
}

static  void method_12624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,std::vector<int> >*)o)->max_size)());
  else   (((const ::std::map<int,std::vector<int> >*)o)->max_size)();
}

static  void operator_12625( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,std::vector<int> >*)o)->operator[])(*(const int*)arg[0]);
  else   (((::std::map<int,std::vector<int> >*)o)->operator[])(*(const int*)arg[0]);
}

static  void method_12626( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,std::vector<int> >*)o)->at)(*(const int*)arg[0]);
  else   (((::std::map<int,std::vector<int> >*)o)->at)(*(const int*)arg[0]);
}

static  void method_12627( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<int,std::vector<int> >*)o)->at)(*(const int*)arg[0]);
  else   (((const ::std::map<int,std::vector<int> >*)o)->at)(*(const int*)arg[0]);
}

static  void method_12628( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > >,bool>)((((::std::map<int,std::vector<int> >*)o)->insert)(*(const ::std::pair<const int,std::vector<int> >*)arg[0]));
  else   (((::std::map<int,std::vector<int> >*)o)->insert)(*(const ::std::pair<const int,std::vector<int> >*)arg[0]);
}

static  void method_12629( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > >)((((::std::map<int,std::vector<int> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > >*)arg[0],
    *(const ::std::pair<const int,std::vector<int> >*)arg[1]));
  else   (((::std::map<int,std::vector<int> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > >*)arg[0],
    *(const ::std::pair<const int,std::vector<int> >*)arg[1]);
}

static  void method_12630( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,std::vector<int> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > >*)arg[0]);
}

static  void method_12631( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((::std::map<int,std::vector<int> >*)o)->erase)(*(const int*)arg[0]));
  else   (((::std::map<int,std::vector<int> >*)o)->erase)(*(const int*)arg[0]);
}

static  void method_12632( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,std::vector<int> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > >*)arg[1]);
}

static  void method_12633( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,std::vector<int> >*)o)->swap)(*(::std::map<int,std::vector<int> >*)arg[0]);
}

static  void method_12634( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<int,std::vector<int> >*)o)->clear)();
}

static  void method_12635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<int>)((((const ::std::map<int,std::vector<int> >*)o)->key_comp)());
  else   (((const ::std::map<int,std::vector<int> >*)o)->key_comp)();
}

static  void method_12637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > >)((((::std::map<int,std::vector<int> >*)o)->find)(*(const int*)arg[0]));
  else   (((::std::map<int,std::vector<int> >*)o)->find)(*(const int*)arg[0]);
}

static  void method_12638( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::vector<int> > >)((((const ::std::map<int,std::vector<int> >*)o)->find)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::vector<int> >*)o)->find)(*(const int*)arg[0]);
}

static  void method_12639( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,std::vector<int> >*)o)->count)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::vector<int> >*)o)->count)(*(const int*)arg[0]);
}

static  void method_12640( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > >)((((::std::map<int,std::vector<int> >*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,std::vector<int> >*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12641( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::vector<int> > >)((((const ::std::map<int,std::vector<int> >*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::vector<int> >*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12642( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > >)((((::std::map<int,std::vector<int> >*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,std::vector<int> >*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12643( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::vector<int> > >)((((const ::std::map<int,std::vector<int> >*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::vector<int> >*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12644( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > >,std::_Rb_tree_iterator<std::pair<const int,std::vector<int> > > >)((((::std::map<int,std::vector<int> >*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::std::map<int,std::vector<int> >*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_12645( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const int,std::vector<int> > >,std::_Rb_tree_const_iterator<std::pair<const int,std::vector<int> > > >)((((const ::std::map<int,std::vector<int> >*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::vector<int> >*)o)->equal_range)(*(const int*)arg[0]);
}

static void method_newdel_2930( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<int,std::vector<int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<int,std::vector<int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<int,std::vector<int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<int,std::vector<int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<int,std::vector<int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<int,std::vector<int> > >::Generate();
  else ::Reflex::Proxy< ::std::map<int,std::vector<int> > >::Generate();
}

//------Dictionary for class map<int,std::vector<int, std::allocator<int> >,std::less<int>,std::allocator<std::pair<const int, std::vector<int, std::allocator<int> > > > > -------------------------------
void __std__map_int_std__vector_int_s__db_datamem(Reflex::Class*);
void __std__map_int_std__vector_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_int_std__vector_int_s__datamem_bld(&__std__map_int_std__vector_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_int_std__vector_int_s__funcmem_bld(&__std__map_int_std__vector_int_s__db_funcmem);
void __std__map_int_std__vector_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<int,std::vector<int> >"), typeid(::std::map<int,std::vector<int> >), sizeof(::std::map<int,std::vector<int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_135, Reflex::Literal("std::map<int,std::vector<int> >::key_type"))
  .AddTypedef(type_2749, Reflex::Literal("std::map<int,std::vector<int> >::mapped_type"))
  .AddTypedef(type_3023, Reflex::Literal("std::map<int,std::vector<int> >::value_type"))
  .AddTypedef(type_2965, Reflex::Literal("std::map<int,std::vector<int> >::key_compare"))
  .AddTypedef(type_3113, Reflex::Literal("std::map<int,std::vector<int> >::allocator_type"))
  .AddTypedef(type_3023, Reflex::Literal("std::map<int,std::vector<int> >::_Alloc_value_type"))
  .AddTypedef(type_3113, Reflex::Literal("std::map<int,std::vector<int> >::_Pair_alloc_type"))
  .AddTypedef(type_3052, Reflex::Literal("std::map<int,std::vector<int> >::_Rep_type"))
  .AddTypedef(type_12594, Reflex::Literal("std::map<int,std::vector<int> >::pointer"))
  .AddTypedef(type_12596, Reflex::Literal("std::map<int,std::vector<int> >::const_pointer"))
  .AddTypedef(type_12598, Reflex::Literal("std::map<int,std::vector<int> >::reference"))
  .AddTypedef(type_12600, Reflex::Literal("std::map<int,std::vector<int> >::const_reference"))
  .AddTypedef(type_2793, Reflex::Literal("std::map<int,std::vector<int> >::iterator"))
  .AddTypedef(type_3257, Reflex::Literal("std::map<int,std::vector<int> >::const_iterator"))
  .AddTypedef(type_1821, Reflex::Literal("std::map<int,std::vector<int> >::size_type"))
  .AddTypedef(type_715, Reflex::Literal("std::map<int,std::vector<int> >::difference_type"))
  .AddTypedef(type_3191, Reflex::Literal("std::map<int,std::vector<int> >::reverse_iterator"))
  .AddTypedef(type_3190, Reflex::Literal("std::map<int,std::vector<int> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_12608, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_12609, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17288, type_17317), Reflex::Literal("map"), constructor_12610, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17318), Reflex::Literal("map"), constructor_12611, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2930, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_int_std__vector_int_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_int_std__vector_int_s__funcmem_bld);
}

//------Delayed data member builder for class map<int,std::vector<int, std::allocator<int> >,std::less<int>,std::allocator<std::pair<const int, std::vector<int, std::allocator<int> > > > > -------------------
void __std__map_int_std__vector_int_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3052, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_int_std__vector_int_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<int,std::vector<int, std::allocator<int> >,std::less<int>,std::allocator<std::pair<const int, std::vector<int, std::allocator<int> > > > > -------------------
void __std__map_int_std__vector_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17319, type_17318), Reflex::Literal("operator="), operator_12612, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3113), Reflex::Literal("get_allocator"), method_12613, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2793), Reflex::Literal("begin"), method_12614, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3257), Reflex::Literal("begin"), method_12615, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2793), Reflex::Literal("end"), method_12616, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3257), Reflex::Literal("end"), method_12617, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_617), Reflex::Literal("empty"), method_12622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821), Reflex::Literal("size"), method_12623, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821), Reflex::Literal("max_size"), method_12624, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17041, type_10740), Reflex::Literal("operator[]"), operator_12625, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17041, type_10740), Reflex::Literal("at"), method_12626, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17040, type_10740), Reflex::Literal("at"), method_12627, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3025, type_12600), Reflex::Literal("insert"), method_12628, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2793, type_2793, type_12600), Reflex::Literal("insert"), method_12629, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2793), Reflex::Literal("erase"), method_12630, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821, type_10740), Reflex::Literal("erase"), method_12631, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2793, type_2793), Reflex::Literal("erase"), method_12632, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_17319), Reflex::Literal("swap"), method_12633, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("clear"), method_12634, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2965), Reflex::Literal("key_comp"), method_12635, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2793, type_10740), Reflex::Literal("find"), method_12637, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3257, type_10740), Reflex::Literal("find"), method_12638, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821, type_10740), Reflex::Literal("count"), method_12639, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2793, type_10740), Reflex::Literal("lower_bound"), method_12640, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3257, type_10740), Reflex::Literal("lower_bound"), method_12641, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2793, type_10740), Reflex::Literal("upper_bound"), method_12642, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3257, type_10740), Reflex::Literal("upper_bound"), method_12643, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3024, type_10740), Reflex::Literal("equal_range"), method_12644, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3022, type_10740), Reflex::Literal("equal_range"), method_12645, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<std::pair<int, int>,int,std::less<std::pair<int, int> >,std::allocator<std::pair<const std::pair<int, int>, int> > > -------------------------------
static void destructor_12670(void*, void * o, const std::vector<void*>&, void *) {
((::std::map<std::pair<int,int>,int>*)o)->::std::map<std::pair<int,int>,int>::~map();
}
static void constructor_12671( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<int,int>,int>();
  else ::new(mem) ::std::map<std::pair<int,int>,int>();
}

static void constructor_12672( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<int,int>,int>(*(const ::std::less<std::pair<int,int> >*)arg[0]);
  else ::new(mem) ::std::map<std::pair<int,int>,int>(*(const ::std::less<std::pair<int,int> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<int,int>,int>(*(const ::std::less<std::pair<int,int> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::pair<int,int>,int> >*)arg[1]);
  else ::new(mem) ::std::map<std::pair<int,int>,int>(*(const ::std::less<std::pair<int,int> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::pair<int,int>,int> >*)arg[1]);
  }
}

static void constructor_12673( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<int,int>,int>(*(const ::std::map<std::pair<int,int>,int>*)arg[0]);
  else ::new(mem) ::std::map<std::pair<int,int>,int>(*(const ::std::map<std::pair<int,int>,int>*)arg[0]);
}

static  void operator_12674( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::pair<int,int>,int>*)o)->operator=)(*(const ::std::map<std::pair<int,int>,int>*)arg[0]);
  else   (((::std::map<std::pair<int,int>,int>*)o)->operator=)(*(const ::std::map<std::pair<int,int>,int>*)arg[0]);
}

static  void method_12675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::pair<int,int>,int> >)((((const ::std::map<std::pair<int,int>,int>*)o)->get_allocator)());
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->get_allocator)();
}

static  void method_12676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >)((((::std::map<std::pair<int,int>,int>*)o)->begin)());
  else   (((::std::map<std::pair<int,int>,int>*)o)->begin)();
}

static  void method_12677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> >)((((const ::std::map<std::pair<int,int>,int>*)o)->begin)());
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->begin)();
}

static  void method_12678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >)((((::std::map<std::pair<int,int>,int>*)o)->end)());
  else   (((::std::map<std::pair<int,int>,int>*)o)->end)();
}

static  void method_12679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> >)((((const ::std::map<std::pair<int,int>,int>*)o)->end)());
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->end)();
}

static  void method_12684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::pair<int,int>,int>*)o)->empty)());
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->empty)();
}

static  void method_12685( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<std::pair<int,int>,int>*)o)->size)());
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->size)();
}

static  void method_12686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<std::pair<int,int>,int>*)o)->max_size)());
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->max_size)();
}

static  void operator_12687( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::pair<int,int>,int>*)o)->operator[])(*(const ::std::pair<int,int>*)arg[0]);
  else   (((::std::map<std::pair<int,int>,int>*)o)->operator[])(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_12688( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::pair<int,int>,int>*)o)->at)(*(const ::std::pair<int,int>*)arg[0]);
  else   (((::std::map<std::pair<int,int>,int>*)o)->at)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_12689( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::pair<int,int>,int>*)o)->at)(*(const ::std::pair<int,int>*)arg[0]);
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->at)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_12690( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >,bool>)((((::std::map<std::pair<int,int>,int>*)o)->insert)(*(const ::std::pair<const std::pair<int,int>,int>*)arg[0]));
  else   (((::std::map<std::pair<int,int>,int>*)o)->insert)(*(const ::std::pair<const std::pair<int,int>,int>*)arg[0]);
}

static  void method_12691( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >)((((::std::map<std::pair<int,int>,int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >*)arg[0],
    *(const ::std::pair<const std::pair<int,int>,int>*)arg[1]));
  else   (((::std::map<std::pair<int,int>,int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >*)arg[0],
    *(const ::std::pair<const std::pair<int,int>,int>*)arg[1]);
}

static  void method_12692( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::pair<int,int>,int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >*)arg[0]);
}

static  void method_12693( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((::std::map<std::pair<int,int>,int>*)o)->erase)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((::std::map<std::pair<int,int>,int>*)o)->erase)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_12694( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::pair<int,int>,int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >*)arg[1]);
}

static  void method_12695( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::pair<int,int>,int>*)o)->swap)(*(::std::map<std::pair<int,int>,int>*)arg[0]);
}

static  void method_12696( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::pair<int,int>,int>*)o)->clear)();
}

static  void method_12697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::pair<int,int> >)((((const ::std::map<std::pair<int,int>,int>*)o)->key_comp)());
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->key_comp)();
}

static  void method_12699( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >)((((::std::map<std::pair<int,int>,int>*)o)->find)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((::std::map<std::pair<int,int>,int>*)o)->find)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_12700( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> >)((((const ::std::map<std::pair<int,int>,int>*)o)->find)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->find)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_12701( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<std::pair<int,int>,int>*)o)->count)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->count)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_12702( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >)((((::std::map<std::pair<int,int>,int>*)o)->lower_bound)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((::std::map<std::pair<int,int>,int>*)o)->lower_bound)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_12703( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> >)((((const ::std::map<std::pair<int,int>,int>*)o)->lower_bound)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->lower_bound)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_12704( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >)((((::std::map<std::pair<int,int>,int>*)o)->upper_bound)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((::std::map<std::pair<int,int>,int>*)o)->upper_bound)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_12705( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> >)((((const ::std::map<std::pair<int,int>,int>*)o)->upper_bound)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->upper_bound)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_12706( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >,std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> > >)((((::std::map<std::pair<int,int>,int>*)o)->equal_range)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((::std::map<std::pair<int,int>,int>*)o)->equal_range)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_12707( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> >,std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> > >)((((const ::std::map<std::pair<int,int>,int>*)o)->equal_range)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->equal_range)(*(const ::std::pair<int,int>*)arg[0]);
}

static void method_newdel_2931( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<int,int>,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<int,int>,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<int,int>,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<int,int>,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<int,int>,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x29( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::pair<int,int>,int> >::Generate();
  else ::Reflex::Proxy< ::std::map<std::pair<int,int>,int> >::Generate();
}

//------Dictionary for class map<std::pair<int, int>,int,std::less<std::pair<int, int> >,std::allocator<std::pair<const std::pair<int, int>, int> > > -------------------------------
void __std__map_std__pair_int_int__int__db_datamem(Reflex::Class*);
void __std__map_std__pair_int_int__int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__pair_int_int__int__datamem_bld(&__std__map_std__pair_int_int__int__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__pair_int_int__int__funcmem_bld(&__std__map_std__pair_int_int__int__db_funcmem);
void __std__map_std__pair_int_int__int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::pair<int,int>,int>"), typeid(::std::map<std::pair<int,int>,int>), sizeof(::std::map<std::pair<int,int>,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3019, Reflex::Literal("std::map<std::pair<int,int>,int>::key_type"))
  .AddTypedef(type_135, Reflex::Literal("std::map<std::pair<int,int>,int>::mapped_type"))
  .AddTypedef(type_3039, Reflex::Literal("std::map<std::pair<int,int>,int>::value_type"))
  .AddTypedef(type_2966, Reflex::Literal("std::map<std::pair<int,int>,int>::key_compare"))
  .AddTypedef(type_3120, Reflex::Literal("std::map<std::pair<int,int>,int>::allocator_type"))
  .AddTypedef(type_3039, Reflex::Literal("std::map<std::pair<int,int>,int>::_Alloc_value_type"))
  .AddTypedef(type_3120, Reflex::Literal("std::map<std::pair<int,int>,int>::_Pair_alloc_type"))
  .AddTypedef(type_3058, Reflex::Literal("std::map<std::pair<int,int>,int>::_Rep_type"))
  .AddTypedef(type_12656, Reflex::Literal("std::map<std::pair<int,int>,int>::pointer"))
  .AddTypedef(type_12658, Reflex::Literal("std::map<std::pair<int,int>,int>::const_pointer"))
  .AddTypedef(type_12660, Reflex::Literal("std::map<std::pair<int,int>,int>::reference"))
  .AddTypedef(type_12662, Reflex::Literal("std::map<std::pair<int,int>,int>::const_reference"))
  .AddTypedef(type_2799, Reflex::Literal("std::map<std::pair<int,int>,int>::iterator"))
  .AddTypedef(type_3263, Reflex::Literal("std::map<std::pair<int,int>,int>::const_iterator"))
  .AddTypedef(type_1821, Reflex::Literal("std::map<std::pair<int,int>,int>::size_type"))
  .AddTypedef(type_715, Reflex::Literal("std::map<std::pair<int,int>,int>::difference_type"))
  .AddTypedef(type_3207, Reflex::Literal("std::map<std::pair<int,int>,int>::reverse_iterator"))
  .AddTypedef(type_3206, Reflex::Literal("std::map<std::pair<int,int>,int>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_12670, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_12671, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17321, type_17322), Reflex::Literal("map"), constructor_12672, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17323), Reflex::Literal("map"), constructor_12673, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2931, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x29, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__pair_int_int__int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__pair_int_int__int__funcmem_bld);
}

//------Delayed data member builder for class map<std::pair<int, int>,int,std::less<std::pair<int, int> >,std::allocator<std::pair<const std::pair<int, int>, int> > > -------------------
void __std__map_std__pair_int_int__int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3058, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__pair_int_int__int_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::pair<int, int>,int,std::less<std::pair<int, int> >,std::allocator<std::pair<const std::pair<int, int>, int> > > -------------------
void __std__map_std__pair_int_int__int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17324, type_17323), Reflex::Literal("operator="), operator_12674, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3120), Reflex::Literal("get_allocator"), method_12675, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2799), Reflex::Literal("begin"), method_12676, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3263), Reflex::Literal("begin"), method_12677, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2799), Reflex::Literal("end"), method_12678, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3263), Reflex::Literal("end"), method_12679, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_617), Reflex::Literal("empty"), method_12684, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821), Reflex::Literal("size"), method_12685, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821), Reflex::Literal("max_size"), method_12686, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10738, type_10869), Reflex::Literal("operator[]"), operator_12687, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10738, type_10869), Reflex::Literal("at"), method_12688, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10740, type_10869), Reflex::Literal("at"), method_12689, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3045, type_12662), Reflex::Literal("insert"), method_12690, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2799, type_2799, type_12662), Reflex::Literal("insert"), method_12691, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2799), Reflex::Literal("erase"), method_12692, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821, type_10869), Reflex::Literal("erase"), method_12693, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_2799, type_2799), Reflex::Literal("erase"), method_12694, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752, type_17324), Reflex::Literal("swap"), method_12695, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1752), Reflex::Literal("clear"), method_12696, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2966), Reflex::Literal("key_comp"), method_12697, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2799, type_10869), Reflex::Literal("find"), method_12699, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3263, type_10869), Reflex::Literal("find"), method_12700, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1821, type_10869), Reflex::Literal("count"), method_12701, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2799, type_10869), Reflex::Literal("lower_bound"), method_12702, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3263, type_10869), Reflex::Literal("lower_bound"), method_12703, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2799, type_10869), Reflex::Literal("upper_bound"), method_12704, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3263, type_10869), Reflex::Literal("upper_bound"), method_12705, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3044, type_10869), Reflex::Literal("equal_range"), method_12706, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3043, type_10869), Reflex::Literal("equal_range"), method_12707, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __TTofpetRun_dict(); 
      __TTofpetEventHeader_dict(); 
      __TTofpetThresholdCalibration_dict(); 
      __TTofpetSetupHandler_dict(); 
      __TTofpetThresholdCalibrationGui_dict(); 
      __TTofpetHit_dict(); 
      __std__map_int_TH2Dp__dict(); 
      __std__map_int_TGraphp__dict(); 
      __std__map_int_TH1Dp__dict(); 
      __std__map_int_std__basic_string_char_s__dict(); 
      __std__map_int_std__pair_int_int_s__dict(); 
      __std__map_int_int__dict(); 
      __std__map_int_double__dict(); 
      __std__map_int_std__vector_int_s__dict(); 
      __std__map_std__pair_int_int__int__dict(); 
    }
    ~Dictionaries() {
      type_300.Unload(); // class TTofpetRun 
      type_1096.Unload(); // class TTofpetEventHeader 
      type_1637.Unload(); // class TTofpetThresholdCalibration 
      type_2344.Unload(); // class TTofpetSetupHandler 
      type_2516.Unload(); // class TTofpetThresholdCalibrationGui 
      type_2704.Unload(); // class TTofpetHit 
      type_2923.Unload(); // class std::map<int,TH2D*> 
      type_2924.Unload(); // class std::map<int,TGraph*> 
      type_2925.Unload(); // class std::map<int,TH1D*> 
      type_2926.Unload(); // class std::map<int,std::basic_string<char> > 
      type_2927.Unload(); // class std::map<int,std::pair<int,int> > 
      type_2928.Unload(); // class std::map<int,int> 
      type_2929.Unload(); // class std::map<int,double> 
      type_2930.Unload(); // class std::map<int,std::vector<int> > 
      type_2931.Unload(); // class std::map<std::pair<int,int>,int> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
