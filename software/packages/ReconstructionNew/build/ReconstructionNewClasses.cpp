// Generated at Thu Nov 17 12:42:17 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/usr/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/usr/bin/c++"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic "
  GCCXML_EXECUTABLE="/usr/bin/gccxml_cc1plus"
  GCCXML_CPP="/usr/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__FLT_MIN__='1.17549435e-38F' -D__CHAR_BIT__='8' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='4.9406564584124654e-324' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__LP64__='1' -D__GNUC_PATCHLEVEL__='7' -D__DEC64_MAX_EXP__='385' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__unix='1' -D__LDBL_MAX_EXP__='16384' -D__linux__='1' -D__SCHAR_MAX__='127' -D__DBL_DIG__='15' -D_FORTIFY_SOURCE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209290e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__SIZEOF_LONG__='8' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='1.7976931348623157e+308' -D__DBL_HAS_INFINITY__='1' -D__DEC32_MIN_EXP__='(-94)' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__DBL_MIN__='2.2250738585072014e-308' -D__FLT_MIN_10_EXP__='(-37)' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__DBL_HAS_DENORM__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.4.7 20120313 (Red Hat 4.4.7-16)"' -D__DEC64_EPSILON__='1E-15DD' -D__DEC128_MIN_EXP__='(-6142)' -Dunix='1' -D__SIZE_TYPE__='long unsigned int' -D__ELF__='1' -D__FLT_RADIX__='2' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__GNUC_RH_RELEASE__='16' -D__k8='1' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__DEC64_MANT_DIG__='16' -D__DEC32_MAX_EXP__='97' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__k8__='1' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__DEC64_MIN_EXP__='(-382)' -D__FLT_DIG__='6' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__FLT_MAX_EXP__='128' -D__DBL_MANT_DIG__='53' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__SSP__='1' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='2.2204460492503131e-16' -D_LP64='1' -D__SIZEOF_WCHAR_T__='4' -D__DEC_EVAL_METHOD__='2' -D__INTMAX_MAX__='9223372036854775807L' -D__FLT_DENORM_MIN__='1.40129846e-45F' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282347e+38F' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='4' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__GNUC_GNU_INLINE__='1' -D_GNU_SOURCE='1' -iwrapper"/usr/share/gccxml-0.9/GCC/4.4" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/backward" -isystem"/usr/local/include" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/usr/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.4.7 20120313 (Red Hat 4.4.7-16)
Copyright (C) 2010 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/project/Gruppo3/fiber5/celentano/OptoTracker/software/packages/ReconstructionNew/include/ReconstructionNewClasses.hh"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::Type type_150 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_263 = ::Reflex::TypeBuilder(Reflex::Literal("TH2D"));
  ::Reflex::Type type_254 = ::Reflex::TypeBuilder(Reflex::Literal("TH1D"));
  ::Reflex::Type type_661 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_278 = ::Reflex::TypeBuilder(Reflex::Literal("TH3D"));
  ::Reflex::Type type_203 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1210 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1005 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_205 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_828 = ::Reflex::TypeBuilder(Reflex::Literal("TFile"));
  ::Reflex::Type type_247 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_2837 = ::Reflex::TypeBuilder(Reflex::Literal("TTree"));
  ::Reflex::Type type_1050 = ::Reflex::TypeBuilder(Reflex::Literal("TList"));
  ::Reflex::Type type_627 = ::Reflex::TypeBuilder(Reflex::Literal("TProof"));
  ::Reflex::Type type_2703 = ::Reflex::TypeBuilder(Reflex::Literal("TEvent"));
  ::Reflex::Type type_1980 = ::Reflex::TypeBuilder(Reflex::Literal("TClass"));
  ::Reflex::Type type_857 = ::Reflex::TypeBuilder(Reflex::Literal("TBuffer"));
  ::Reflex::Type type_2698 = ::Reflex::TypeBuilder(Reflex::Literal("TNamed"));
  ::Reflex::Type type_850 = ::Reflex::TypeBuilder(Reflex::Literal("TBranch"));
  ::Reflex::Type type_2748 = ::Reflex::TypeBuilder(Reflex::Literal("TChain"));
  ::Reflex::Type type_2618 = ::Reflex::TypeBuilder(Reflex::Literal("TDriver"));
  ::Reflex::Type type_2261 = ::Reflex::TypeBuilder(Reflex::Literal("TObject"));
  ::Reflex::Type type_852 = ::Reflex::TypeBuilder(Reflex::Literal("TRandom3"));
  ::Reflex::Type type_1165 = ::Reflex::TypeBuilder(Reflex::Literal("TMCTruth"));
  ::Reflex::Type type_413 = ::Reflex::TypeBuilder(Reflex::Literal("TSelector"));
  ::Reflex::Type type_1950 = ::Reflex::TypeBuilder(Reflex::Literal("long long"));
  ::Reflex::Type type_66 = ::Reflex::TypeBuilder(Reflex::Literal("TXMLHandler"));
  ::Reflex::Type type_2256 = ::Reflex::TypeBuilder(Reflex::Literal("TDetector"));
  ::Reflex::Type type_2738 = ::Reflex::TypeBuilder(Reflex::Literal("TAnalysis"));
  ::Reflex::Type type_2794 = ::Reflex::TypeBuilder(Reflex::Literal("TReconHit"));
  ::Reflex::Type type_523 = ::Reflex::TypeBuilder(Reflex::Literal("TReconInput"));
  ::Reflex::Type type_1149 = ::Reflex::TypeBuilder(Reflex::Literal("TTofpetRun"));
  ::Reflex::Type type_218 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_1365 = ::Reflex::TypeBuilder(Reflex::Literal("TJobManager"));
  ::Reflex::Type type_2223 = ::Reflex::TypeBuilder(Reflex::Literal("TClonesArray"));
  ::Reflex::Type type_180 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_402 = ::Reflex::EnumTypeBuilder(Reflex::Literal("fitObject_t"));
  ::Reflex::Type type_1443 = ::Reflex::TypeBuilder(Reflex::Literal("TDetectorUtils"));
  ::Reflex::Type type_438 = ::Reflex::TypeBuilder(Reflex::Literal("TMemberInspector"));
  ::Reflex::Type type_1138 = ::Reflex::TypeBuilder(Reflex::Literal("TRootSaveDriver"));
  ::Reflex::Type type_155 = ::Reflex::TypeBuilder(Reflex::Literal("TMatrixT<double>"));
  ::Reflex::Type type_1785 = ::Reflex::TypeBuilder(Reflex::Literal("TRealSetupHandler"));
  ::Reflex::Type type_587 = ::Reflex::TypeBuilder(Reflex::Literal("TEventMarkerDriver"));
  ::Reflex::Type type_1150 = ::Reflex::TypeBuilder(Reflex::Literal("TMarocEventHeader"));
  ::Reflex::Type type_2840 = ::Reflex::TypeBuilder(Reflex::Literal("TMarocBasicDriver"));
  ::Reflex::Type type_2214 = ::Reflex::TypeBuilder(Reflex::Literal("TMarocSetupHandler"));
  ::Reflex::Type type_2124 = ::Reflex::TypeBuilder(Reflex::Literal("TMatrixReconDriver"));
  ::Reflex::Type type_2918 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_2500 = ::Reflex::TypeBuilder(Reflex::Literal("TTofpetSetupHandler"));
  ::Reflex::Type type_1226 = ::Reflex::TypeBuilder(Reflex::Literal("TMatrixWriterDriver"));
  ::Reflex::Type type_1849 = ::Reflex::TypeBuilder(Reflex::Literal("TMCDataReaderDriver"));
  ::Reflex::Type type_106 = ::Reflex::TypeBuilder(Reflex::Literal("TChargeAnalysisDriver"));
  ::Reflex::Type type_8183 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::Minimizer"));
  ::Reflex::Type type_2679 = ::Reflex::TypeBuilder(Reflex::Literal("TLikelihoodCalculator"));
  ::Reflex::Type type_228 = ::Reflex::TypeBuilder(Reflex::Literal("TLikelihoodReconDriver"));
  ::Reflex::Type type_2913 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<TDriver*>"));
  ::Reflex::Type type_2025 = ::Reflex::TypeBuilder(Reflex::Literal("TMarocDataReaderDriver"));
  ::Reflex::Type type_2943 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_1016 = ::Reflex::EnumTypeBuilder(Reflex::Literal("fitLikelihoodMode_t"));
  ::Reflex::Type type_140 = ::Reflex::TypeBuilder(Reflex::Literal("TTofpetSetupHandlerDriver"));
  ::Reflex::Type type_1435 = ::Reflex::TypeBuilder(Reflex::Literal("TMatrixInterpreterDriver"));
  ::Reflex::Type type_1529 = ::Reflex::TypeBuilder(Reflex::Literal("TMarocSetupHandlerDriver"));
  ::Reflex::Type type_3221 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<TDriver*>"));
  ::Reflex::Type type_742 = ::Reflex::TypeBuilder(Reflex::Literal("TTofpetDummyAnalysisDriver"));
  ::Reflex::Type type_1233 = ::Reflex::TypeBuilder(Reflex::Literal("TTofpetTimeAnalysisDriver"));
  ::Reflex::Type type_1170 = ::Reflex::TypeBuilder(Reflex::Literal("TLikelihoodCalculatorIdeal"));
  ::Reflex::Type type_1760 = ::Reflex::TypeBuilder(Reflex::Literal("TTofpetThresholdCalibration"));
  ::Reflex::Type type_2628 = ::Reflex::TypeBuilder(Reflex::Literal("TLikelihoodCalculatorMaroc1"));
  ::Reflex::Type type_835 = ::Reflex::TypeBuilder(Reflex::Literal("TChargeAnalysisPoissonDriver"));
  ::Reflex::Type type_1518 = ::Reflex::TypeBuilder(Reflex::Literal("TLikelihoodComputationDriver"));
  ::Reflex::Type type_4247 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::IBaseFunctionMultiDim"));
  ::Reflex::Type type_2533 = ::Reflex::TypeBuilder(Reflex::Literal("TTofpetThresholdCalibrationDriver"));
  ::Reflex::Type type_2921 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_1375 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_ofstream<char,std::char_traits<char> >"));
  ::Reflex::Type type_2873 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TDriver*,std::allocator<TDriver*> >"));
  ::Reflex::Type type_3080 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >"));
  ::Reflex::Type type_8389 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >"));
  ::Reflex::Type type_8390 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TDriver* const*,std::vector<TDriver*> >"));
  ::Reflex::Type type_3290 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> > >"));
  ::Reflex::Type type_3289 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TDriver* const*,std::vector<TDriver*> > >"));
  ::Reflex::Type type_2955 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2943);
  ::Reflex::Type type_1376 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ofstream"), type_1375);
  ::Reflex::Type type_15769 = ::Reflex::PointerBuilder(type_263);
  ::Reflex::Type type_18831 = ::Reflex::ArrayBuilder(type_15769, 256);
  ::Reflex::Type type_15660 = ::Reflex::ArrayBuilder(type_18831, 6);
  ::Reflex::Type type_15661 = ::Reflex::PointerBuilder(type_254);
  ::Reflex::Type type_15662 = ::Reflex::PointerBuilder(type_1165);
  ::Reflex::Type type_15663 = ::Reflex::PointerBuilder(type_2703);
  ::Reflex::Type type_1005c = ::Reflex::ConstBuilder(type_1005);
  ::Reflex::Type type_3438 = ::Reflex::PointerBuilder(type_1005c);
  ::Reflex::Type type_789 = ::Reflex::PointerBuilder(type_1980);
  ::Reflex::Type type_2548 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Version_t"), type_205);
  ::Reflex::Type type_15639 = ::Reflex::ReferenceBuilder(type_438);
  ::Reflex::Type type_4877 = ::Reflex::ReferenceBuilder(type_857);
  ::Reflex::Type type_15682 = ::Reflex::PointerBuilder(type_2500);
  ::Reflex::Type type_15683 = ::Reflex::ReferenceBuilder(type_140);
  ::Reflex::Type type_140c = ::Reflex::ConstBuilder(type_140);
  ::Reflex::Type type_15684 = ::Reflex::ReferenceBuilder(type_140c);
  ::Reflex::Type type_15763 = ::Reflex::PointerBuilder(type_8183);
  ::Reflex::Type type_15764 = ::Reflex::PointerBuilder(type_523);
  ::Reflex::Type type_15765 = ::Reflex::PointerBuilder(type_1785);
  ::Reflex::Type type_3439 = ::Reflex::PointerBuilder(type_150);
  ::Reflex::Type type_18854 = ::Reflex::PointerBuilder(type_3439);
  ::Reflex::Type type_15766 = ::Reflex::ArrayBuilder(type_18854, 6);
  ::Reflex::Type type_8490 = ::Reflex::PointerBuilder(type_247);
  ::Reflex::Type type_18855 = ::Reflex::PointerBuilder(type_8490);
  ::Reflex::Type type_15767 = ::Reflex::ArrayBuilder(type_18855, 6);
  ::Reflex::Type type_15768 = ::Reflex::PointerBuilder(type_2679);
  ::Reflex::Type type_5840 = ::Reflex::PointerBuilder(type_2837);
  ::Reflex::Type type_15770 = ::Reflex::ReferenceBuilder(type_228);
  ::Reflex::Type type_228c = ::Reflex::ConstBuilder(type_228);
  ::Reflex::Type type_15771 = ::Reflex::ReferenceBuilder(type_228c);
  ::Reflex::Type type_247c = ::Reflex::ConstBuilder(type_247);
  ::Reflex::Type type_12392 = ::Reflex::PointerBuilder(type_247c);
  ::Reflex::Type type_15775 = ::Reflex::PointerBuilder(type_4247);
  ::Reflex::Type type_15882 = ::Reflex::ArrayBuilder(type_150, 30);
  ::Reflex::Type type_15883 = ::Reflex::ArrayBuilder(type_247, 30);
  ::Reflex::Type type_15884 = ::Reflex::ReferenceBuilder(type_523);
  ::Reflex::Type type_523c = ::Reflex::ConstBuilder(type_523);
  ::Reflex::Type type_15885 = ::Reflex::ReferenceBuilder(type_523c);
  ::Reflex::Type type_15896 = ::Reflex::ReferenceBuilder(type_587);
  ::Reflex::Type type_587c = ::Reflex::ConstBuilder(type_587);
  ::Reflex::Type type_15897 = ::Reflex::ReferenceBuilder(type_587c);
  ::Reflex::Type type_15929 = ::Reflex::PointerBuilder(type_15661);
  ::Reflex::Type type_15930 = ::Reflex::PointerBuilder(type_15769);
  ::Reflex::Type type_15931 = ::Reflex::PointerBuilder(type_1149);
  ::Reflex::Type type_15932 = ::Reflex::ReferenceBuilder(type_742);
  ::Reflex::Type type_742c = ::Reflex::ConstBuilder(type_742);
  ::Reflex::Type type_15933 = ::Reflex::ReferenceBuilder(type_742c);
  ::Reflex::Type type_15958 = ::Reflex::PointerBuilder(type_828);
  ::Reflex::Type type_16609 = ::Reflex::ReferenceBuilder(type_1138);
  ::Reflex::Type type_1138c = ::Reflex::ConstBuilder(type_1138);
  ::Reflex::Type type_16610 = ::Reflex::ReferenceBuilder(type_1138c);
  ::Reflex::Type type_16615 = ::Reflex::ReferenceBuilder(type_1170);
  ::Reflex::Type type_1170c = ::Reflex::ConstBuilder(type_1170);
  ::Reflex::Type type_16616 = ::Reflex::ReferenceBuilder(type_1170c);
  ::Reflex::Type type_16659 = ::Reflex::ReferenceBuilder(type_1226);
  ::Reflex::Type type_1226c = ::Reflex::ConstBuilder(type_1226);
  ::Reflex::Type type_16660 = ::Reflex::ReferenceBuilder(type_1226c);
  ::Reflex::Type type_16661 = ::Reflex::ReferenceBuilder(type_1233);
  ::Reflex::Type type_1233c = ::Reflex::ConstBuilder(type_1233);
  ::Reflex::Type type_16662 = ::Reflex::ReferenceBuilder(type_1233c);
  ::Reflex::Type type_5839 = ::Reflex::PointerBuilder(type_850);
  ::Reflex::Type type_16739 = ::Reflex::PointerBuilder(type_66);
  ::Reflex::Type type_16740 = ::Reflex::PointerBuilder(type_2913);
  ::Reflex::Type type_16741 = ::Reflex::PointerBuilder(type_2256);
  ::Reflex::Type type_16742 = ::Reflex::PointerBuilder(type_1443);
  ::Reflex::Type type_16743 = ::Reflex::PointerBuilder(type_3080);
  ::Reflex::Type type_883 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Int_t"), type_150);
  ::Reflex::Type type_1951 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Long64_t"), type_1950);
  ::Reflex::Type type_13947 = ::Reflex::PointerBuilder(type_2261);
  ::Reflex::Type type_15838 = ::Reflex::PointerBuilder(type_1050);
  ::Reflex::Type type_662 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Bool_t"), type_661);
  ::Reflex::Type type_9059 = ::Reflex::PointerBuilder(type_2618);
  ::Reflex::Type type_16746 = ::Reflex::PointerBuilder(type_852);
  ::Reflex::Type type_16757 = ::Reflex::PointerBuilder(type_278);
  ::Reflex::Type type_16758 = ::Reflex::ReferenceBuilder(type_1435);
  ::Reflex::Type type_1435c = ::Reflex::ConstBuilder(type_1435);
  ::Reflex::Type type_16759 = ::Reflex::ReferenceBuilder(type_1435c);
  ::Reflex::Type type_16775 = ::Reflex::ReferenceBuilder(type_1518);
  ::Reflex::Type type_1518c = ::Reflex::ConstBuilder(type_1518);
  ::Reflex::Type type_16776 = ::Reflex::ReferenceBuilder(type_1518c);
  ::Reflex::Type type_16777 = ::Reflex::PointerBuilder(type_2214);
  ::Reflex::Type type_16778 = ::Reflex::ReferenceBuilder(type_1529);
  ::Reflex::Type type_1529c = ::Reflex::ConstBuilder(type_1529);
  ::Reflex::Type type_16779 = ::Reflex::ReferenceBuilder(type_1529c);
  ::Reflex::Type type_12451 = ::Reflex::PointerBuilder(type_2223);
  ::Reflex::Type type_17573 = ::Reflex::ReferenceBuilder(type_1849);
  ::Reflex::Type type_1849c = ::Reflex::ConstBuilder(type_1849);
  ::Reflex::Type type_17574 = ::Reflex::ReferenceBuilder(type_1849c);
  ::Reflex::Type type_17624 = ::Reflex::PointerBuilder(type_1150);
  ::Reflex::Type type_17625 = ::Reflex::ReferenceBuilder(type_2025);
  ::Reflex::Type type_2025c = ::Reflex::ConstBuilder(type_2025);
  ::Reflex::Type type_17626 = ::Reflex::ReferenceBuilder(type_2025c);
  ::Reflex::Type type_156 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("TMatrixD"), type_155);
  ::Reflex::Type type_17765 = ::Reflex::PointerBuilder(type_156);
  ::Reflex::Type type_17766 = ::Reflex::ReferenceBuilder(type_2124);
  ::Reflex::Type type_2124c = ::Reflex::ConstBuilder(type_2124);
  ::Reflex::Type type_17767 = ::Reflex::ReferenceBuilder(type_2124c);
  ::Reflex::Type type_18058 = ::Reflex::PointerBuilder(type_1760);
  ::Reflex::Type type_18059 = ::Reflex::ReferenceBuilder(type_2533);
  ::Reflex::Type type_2533c = ::Reflex::ConstBuilder(type_2533);
  ::Reflex::Type type_18060 = ::Reflex::ReferenceBuilder(type_2533c);
  ::Reflex::Type type_18063 = ::Reflex::PointerBuilder(type_1365);
  ::Reflex::Type type_18064 = ::Reflex::ReferenceBuilder(type_2618);
  ::Reflex::Type type_2618c = ::Reflex::ConstBuilder(type_2618);
  ::Reflex::Type type_18065 = ::Reflex::ReferenceBuilder(type_2618c);
  ::Reflex::Type type_2955c = ::Reflex::ConstBuilder(type_2955);
  ::Reflex::Type type_14900 = ::Reflex::ReferenceBuilder(type_2955c);
  ::Reflex::Type type_18066 = ::Reflex::ReferenceBuilder(type_2628);
  ::Reflex::Type type_2628c = ::Reflex::ConstBuilder(type_2628);
  ::Reflex::Type type_18067 = ::Reflex::ReferenceBuilder(type_2628c);
  ::Reflex::Type type_18085 = ::Reflex::ReferenceBuilder(type_2679);
  ::Reflex::Type type_2679c = ::Reflex::ConstBuilder(type_2679);
  ::Reflex::Type type_18086 = ::Reflex::ReferenceBuilder(type_2679c);
  ::Reflex::Type type_18087 = ::Reflex::PointerBuilder(type_18854);
  ::Reflex::Type type_18088 = ::Reflex::PointerBuilder(type_18855);
  ::Reflex::Type type_18113 = ::Reflex::PointerBuilder(type_2748);
  ::Reflex::Type type_18114 = ::Reflex::PointerBuilder(type_627);
  ::Reflex::Type type_18115 = ::Reflex::PointerBuilder(type_2921);
  ::Reflex::Type type_18116 = ::Reflex::ReferenceBuilder(type_2738);
  ::Reflex::Type type_2738c = ::Reflex::ConstBuilder(type_2738);
  ::Reflex::Type type_18117 = ::Reflex::ReferenceBuilder(type_2738c);
  ::Reflex::Type type_2647 = ::Reflex::PointerBuilder(type_1005);
  ::Reflex::Type type_4598 = ::Reflex::PointerBuilder(type_2647);
  ::Reflex::Type type_18125 = ::Reflex::ReferenceBuilder(type_2794);
  ::Reflex::Type type_2794c = ::Reflex::ConstBuilder(type_2794);
  ::Reflex::Type type_18126 = ::Reflex::ReferenceBuilder(type_2794c);
  ::Reflex::Type type_18161 = ::Reflex::ReferenceBuilder(type_2840);
  ::Reflex::Type type_2840c = ::Reflex::ConstBuilder(type_2840);
  ::Reflex::Type type_18162 = ::Reflex::ReferenceBuilder(type_2840c);
  ::Reflex::Type type_12141 = ::Reflex::PointerBuilder(type_9059);
  ::Reflex::Type type_9059c = ::Reflex::ConstBuilder(type_9059);
  ::Reflex::Type type_12143 = ::Reflex::PointerBuilder(type_9059c);
  ::Reflex::Type type_12145 = ::Reflex::ReferenceBuilder(type_9059);
  ::Reflex::Type type_12147 = ::Reflex::ReferenceBuilder(type_9059c);
  ::Reflex::Type type_1961 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_180);
  ::Reflex::Type type_759 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("ptrdiff_t"), type_203);
  ::Reflex::Type type_3221c = ::Reflex::ConstBuilder(type_3221);
  ::Reflex::Type type_18196 = ::Reflex::ReferenceBuilder(type_3221c);
  ::Reflex::Type type_2913c = ::Reflex::ConstBuilder(type_2913);
  ::Reflex::Type type_18323 = ::Reflex::ReferenceBuilder(type_2913c);
  ::Reflex::Type type_18324 = ::Reflex::ReferenceBuilder(type_2913);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __TChargeAnalysisDriver
#undef __TChargeAnalysisDriver
#endif
class __TChargeAnalysisDriver : public ::TDriver {
  public:
  __TChargeAnalysisDriver();
  virtual ~__TChargeAnalysisDriver() throw();
  virtual int startOfData() throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual int start() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int end() throw();
  virtual int process(TEvent*) throw();
  int m_nPixels;
  int m_nDetectors;
  int m_writeOut;
  ::std::string m_writeOutFileName;
  ::std::ofstream m_writeOutFile;
  ::std::vector<double> m_Q;
  void* hPixels2D[6][256];
  void* hPixelsMC;
  void* hPixelsModel;
  void* hEdep;
  void* hLength;
  void* m_MCTruth;
};
#ifdef __TTofpetSetupHandlerDriver
#undef __TTofpetSetupHandlerDriver
#endif
class __TTofpetSetupHandlerDriver : public ::TDriver {
  public:
  __TTofpetSetupHandlerDriver();
  virtual ~__TTofpetSetupHandlerDriver() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int start() throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  int m_source;
  ::std::string m_fname;
  void* m_setupHandler;
};
#ifdef __TLikelihoodReconDriver
#undef __TLikelihoodReconDriver
#endif
class __TLikelihoodReconDriver : public ::TDriver, public ::ROOT::Math::IBaseFunctionMultiDim {
  public:
  __TLikelihoodReconDriver();
  virtual ~__TLikelihoodReconDriver() throw();
  virtual ::ROOT::Math::IBaseFunctionMultiDim* Clone() const throw();
  virtual unsigned int NDim() const throw();
  virtual int process(TEvent*) throw();
  virtual void Streamer(TBuffer&) throw();
  virtual int start() throw();
  virtual double DoEval(double const*) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int endOfData() throw();
  virtual int startOfData() throw();
  virtual ::TClass* IsA() const throw();
  void* m_minimizer;
  void* m_reconInput;
  void* m_realSetupHandler;
  ::fitObject_t m_fitObject;
  ::fitLikelihoodMode_t m_fitLikelihoodMode;
  void* m_ON[6];
  void* m_disc[6];
  void* m_Q[6];
  void* m_T[6];
  int m_reconInputMode;
  ::std::string m_reconInputFileName;
  void* m_likelihoodCalculator;
  void* hX;
  void* hY;
  void* hZ;
  void* hX_1;
  void* hY_1;
  void* hZ_1;
  void* hX_2;
  void* hY_2;
  void* hZ_2;
  void* hXY;
  void* hXZ;
  void* hYZ;
  void* hXY_1;
  void* hXZ_1;
  void* hYZ_1;
  void* hXY_2;
  void* hXZ_2;
  void* hYZ_2;
  void* hTheta;
  void* hPhi;
  void* hNPhotons;
  void* hT0;
  void* hTau;
  void* tout;
  double m_x0;
  double m_y0;
  double m_z0;
  double m_x1;
  double m_y1;
  double m_z1;
  double m_N;
  double m_tau;
  double m_beta;
  double m_T0;
  double m_L;
  int m_nON;
  double m_QTOT;
  int m_eventN;
};
#ifdef __TReconInput
#undef __TReconInput
#endif
class __TReconInput : public ::TNamed {
  public:
  __TReconInput();
  virtual ~__TReconInput() throw();
  virtual void Print() const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  int m_isParConfigured[30];
  double m_parVal[30];
  int m_isParFixed[30];
  int m_isParLowLimited[30];
  int m_isParHighLimited[30];
  double m_parLowLimit[30];
  double m_parHighLimit[30];
  ::fitObject_t m_fitObject;
  ::fitLikelihoodMode_t m_fitLikelihoodMode;
};
#ifdef __TEventMarkerDriver
#undef __TEventMarkerDriver
#endif
class __TEventMarkerDriver : public ::TDriver {
  public:
  __TEventMarkerDriver();
  virtual ~__TEventMarkerDriver() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int process(TEvent*) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  int m_interval;
};
#ifdef __TTofpetDummyAnalysisDriver
#undef __TTofpetDummyAnalysisDriver
#endif
class __TTofpetDummyAnalysisDriver : public ::TDriver {
  public:
  __TTofpetDummyAnalysisDriver();
  virtual ~__TTofpetDummyAnalysisDriver() throw();
  virtual int startOfData() throw();
  virtual int process(TEvent*) throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int end() throw();
  virtual ::TClass* IsA() const throw();
  void* hMultiplicity0;
  void* hMultiplicity1;
  void* hMultiplicity2;
  void* hMultiplicityAverage;
  void* hToT0;
  void* hToT1;
  void* hToTCh;
  void* m_TofpetRun;
  int m_Nsteps;
};
#ifdef __TChargeAnalysisPoissonDriver
#undef __TChargeAnalysisPoissonDriver
#endif
class __TChargeAnalysisPoissonDriver : public ::TDriver {
  public:
  __TChargeAnalysisPoissonDriver();
  virtual ~__TChargeAnalysisPoissonDriver() throw();
  virtual int startOfData() throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual int start() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int end() throw();
  virtual int process(TEvent*) throw();
  int m_nPixels;
  int m_nDetectors;
  int m_eventsProduced;
  ::std::string m_writeOutFileName;
  ::std::ofstream m_writeOutFile;
  ::std::vector<double> m_Q;
  void* hPixels2D[6][256];
  void* hPixelsMC;
};
#ifdef __TRootSaveDriver
#undef __TRootSaveDriver
#endif
class __TRootSaveDriver : public ::TDriver {
  public:
  __TRootSaveDriver();
  virtual ~__TRootSaveDriver() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual int end() throw();
  virtual void Streamer(TBuffer&) throw();
  ::std::string m_fname;
  void* m_fout;
};
#ifdef __TLikelihoodCalculatorIdeal
#undef __TLikelihoodCalculatorIdeal
#endif
class __TLikelihoodCalculatorIdeal : public ::TLikelihoodCalculator {
  public:
  __TLikelihoodCalculatorIdeal();
  virtual ~__TLikelihoodCalculatorIdeal() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual double CalculateLikelihood(double const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
};
#ifdef __TMatrixWriterDriver
#undef __TMatrixWriterDriver
#endif
class __TMatrixWriterDriver : public ::TDriver {
  public:
  __TMatrixWriterDriver();
  virtual ~__TMatrixWriterDriver() throw();
  virtual int startOfData() throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual int start() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int end() throw();
  virtual int process(TEvent*) throw();
  void* hPixels;
  int m_nPixels;
  int m_nDetectors;
  int m_voxelID;
};
#ifdef __TTofpetTimeAnalysisDriver
#undef __TTofpetTimeAnalysisDriver
#endif
class __TTofpetTimeAnalysisDriver : public ::TDriver {
  public:
  __TTofpetTimeAnalysisDriver();
  virtual ~__TTofpetTimeAnalysisDriver() throw();
  virtual int startOfData() throw();
  virtual int process(TEvent*) throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int end() throw();
  virtual ::TClass* IsA() const throw();
  void* hMultiplicity0;
  void* hMultiplicity1;
  void* hMultiplicity2;
  void* hEntries0;
  void* hEntries1;
  void* hToT0;
  void* hToT1;
  void* hToTch1VSch2;
  void* hDeltaT;
  void* m_TofpetRun;
  void* tout;
  double m_Q1;
  double m_Q2;
  long long m_T1;
  long long m_T2;
  int m_Nsteps;
  int m_ch1;
  int m_ch2;
};
#ifdef __TJobManager
#undef __TJobManager
#endif
class __TJobManager : public ::TSelector {
  public:
  __TJobManager();
  virtual ~__TJobManager() throw();
  virtual ::Int_t GetEntry(long long, int) throw();
  virtual void SetInputList(TList*) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void Init(TTree*) throw();
  virtual ::Bool_t Process(long long) throw();
  virtual const char* ClassName() const throw();
  virtual void SetOption(char const*) throw();
  virtual ::Bool_t Notify() throw();
  virtual void SlaveTerminate() throw();
  virtual void SetObject(TObject*) throw();
  virtual void Begin(TTree*) throw();
  virtual void Terminate() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TList* GetOutputList() const throw();
  virtual ::Int_t Version() const throw();
  virtual void SlaveBegin(TTree*) throw();
  void* fTree;
  void* b_event;
  void* m_event;
  void* m_xmlHandler;
  void* m_drivers;
  void* m_detector;
  void* m_detectorUtils;
  void* m_variables;
  int m_eventN;
  int m_doProof;
  int m_doProofDiag;
  int m_skipEvents;
  int m_numberOfEvents;
  int m_verboseLevel;
  int m_dryRun;
  int m_numberOfWorkers;
  int m_numberOfIterations;
  int m_iterationN;
  int m_isProofCompatible;
};
#ifdef __TMatrixInterpreterDriver
#undef __TMatrixInterpreterDriver
#endif
class __TMatrixInterpreterDriver : public ::TDriver {
  public:
  __TMatrixInterpreterDriver();
  virtual ~__TMatrixInterpreterDriver() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int process(TEvent*) throw();
  virtual int startOfData() throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  void* hVoxelRecon;
};
#ifdef __TLikelihoodComputationDriver
#undef __TLikelihoodComputationDriver
#endif
class __TLikelihoodComputationDriver : public ::TDriver {
  public:
  __TLikelihoodComputationDriver();
  virtual ~__TLikelihoodComputationDriver() throw();
  virtual int startOfData() throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual int start() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int end() throw();
  virtual int process(TEvent*) throw();
  void* m_reconInput;
  void* m_realSetupHandler;
  ::fitObject_t m_fitObject;
  ::fitLikelihoodMode_t m_fitLikelihoodMode;
  void* m_ON[6];
  void* m_disc[6];
  void* m_Q[6];
  void* m_T[6];
  int m_reconInputMode;
  ::std::string m_reconInputFileName;
  void* m_likelihoodCalculator;
  void* hX;
  void* hY;
  void* hZ;
  void* hXY;
  void* hXZ;
  void* hYZ;
};
#ifdef __TMarocSetupHandlerDriver
#undef __TMarocSetupHandlerDriver
#endif
class __TMarocSetupHandlerDriver : public ::TDriver {
  public:
  __TMarocSetupHandlerDriver();
  virtual ~__TMarocSetupHandlerDriver() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int start() throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  int m_source;
  ::std::string m_fname;
  void* m_setupHandler;
};
#ifdef __TMCDataReaderDriver
#undef __TMCDataReaderDriver
#endif
class __TMCDataReaderDriver : public ::TDriver {
  public:
  __TMCDataReaderDriver();
  virtual ~__TMCDataReaderDriver() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int process(TEvent*) throw();
  virtual int startOfData() throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  void* m_reconHitCollection;
};
#ifdef __TMarocDataReaderDriver
#undef __TMarocDataReaderDriver
#endif
class __TMarocDataReaderDriver : public ::TDriver {
  public:
  __TMarocDataReaderDriver();
  virtual ~__TMarocDataReaderDriver() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int process(TEvent*) throw();
  virtual int startOfData() throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  void* m_reconHitCollection;
  void* m_marocSetupHandler;
  void* m_marocEventHeader;
  double m_ChargeCutMin;
  double m_ChargeCutMax;
  double m_MultCutMin;
  double m_MultCutMax;
};
#ifdef __TMatrixReconDriver
#undef __TMatrixReconDriver
#endif
class __TMatrixReconDriver : public ::TDriver {
  public:
  __TMatrixReconDriver();
  virtual ~__TMatrixReconDriver() throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual int start() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int endOfData() throw();
  virtual int startOfData() throw();
  virtual int process(TEvent*) throw();
  void* m_matrix;
  ::TMatrixD m_matrixInverse;
  int m_matrixSource;
  void* m_matrixFile;
  ::std::string m_matrixFileName;
  void* hVoxelsInput;
  void* hVoxelsReconAll;
  ::TMatrixD m_pixelDataAll;
  ::TMatrixD m_voxelDataAll;
};
#ifdef __TTofpetThresholdCalibrationDriver
#undef __TTofpetThresholdCalibrationDriver
#endif
class __TTofpetThresholdCalibrationDriver : public ::TDriver {
  public:
  __TTofpetThresholdCalibrationDriver();
  virtual ~__TTofpetThresholdCalibrationDriver() throw();
  virtual int startOfData() throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual int start() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int end() throw();
  virtual int process(TEvent*) throw();
  void* hToT0;
  void* hToTvsThr;
  void* m_TTofpetRun;
  void* m_TTofpetSetupHandler;
  void* m_TTofpetThresholdCalibration;
  void* m_detector;
  int m_Nsteps;
  int m_Nchannels;
  int m_NhToT0;
  int m_NhToTCalib;
  int m_hToT0_nbins;
  double m_hToT0_min;
  double m_hToT0_max;
  int m_isInteractive;
  ::std::string m_Thrfname;
};
#ifdef __TDriver
#undef __TDriver
#endif
class __TDriver : public ::TObject {
  public:
  __TDriver();
  virtual ~__TDriver() throw();
  void* m_manager;
  ::std::string m_name;
  int m_verboseLevel;
  int m_iterationN;
  int m_isProofCompatible;
  ::std::string m_collectionName;
  ::std::string m_collectionRawName;
  ::std::string m_collectionOutName;
};
#ifdef __TLikelihoodCalculatorMaroc1
#undef __TLikelihoodCalculatorMaroc1
#endif
class __TLikelihoodCalculatorMaroc1 : public ::TLikelihoodCalculator {
  public:
  __TLikelihoodCalculatorMaroc1();
  virtual ~__TLikelihoodCalculatorMaroc1() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual double CalculateLikelihood(double const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
};
#ifdef __TLikelihoodCalculator
#undef __TLikelihoodCalculator
#endif
class __TLikelihoodCalculator : public ::TObject {
  public:
  __TLikelihoodCalculator();
  virtual ~__TLikelihoodCalculator() throw();
  void* m_driver;
  void* m_detector;
  void* m_detectorUtils;
  void* m_realSetupHandler;
  void* m_ON[6];
  void* m_disc[6];
  void* m_Q[6];
  void* m_T[6];
  ::fitObject_t m_fitObject;
  ::fitLikelihoodMode_t m_fitLikelihoodMode;
};
#ifdef __TAnalysis
#undef __TAnalysis
#endif
class __TAnalysis : public ::TObject {
  public:
  __TAnalysis();
  virtual ~__TAnalysis() throw();
  void* m_manager;
  void* m_chain;
  void* m_proof;
  ::std::string m_steeringName;
  ::std::string m_detName;
  void* m_fileName;
  int isConfigured;
};
#ifdef __TReconHit
#undef __TReconHit
#endif
class __TReconHit : public ::TObject {
  public:
  __TReconHit();
  virtual ~__TReconHit() throw();
  int face;
  int detector;
  int pixel;
  int nPhe;
  double Q;
  double T;
  bool hit;
};
#ifdef __TMarocBasicDriver
#undef __TMarocBasicDriver
#endif
class __TMarocBasicDriver : public ::TDriver {
  public:
  __TMarocBasicDriver();
  virtual ~__TMarocBasicDriver() throw();
  virtual int startOfData() throw();
  virtual int process(TEvent*) throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual int end() throw();
  virtual ::TClass* IsA() const throw();
  void* hMultiplicity0;
  void* hQTot0;
  void* hQTotvsMultiplicity0;
};
#ifdef __std__vector_TDriverp_
#undef __std__vector_TDriverp_
#endif
class __std__vector_TDriverp_ : protected ::std::_Vector_base<TDriver*,std::allocator<TDriver*> > {
  public:
  __std__vector_TDriverp_();
};
}


#endif // __CINT__
namespace {
} // unnamed namespace

#ifndef G__DICTIONARY
# define G__DICTIONARY
#endif
#include "TClass.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "RtypesImp.h"
#include "TIsAProxy.h"
atomic_TClass_ptr TChargeAnalysisDriver::fgIsA(0);
TClass* ::TChargeAnalysisDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TChargeAnalysisDriver");
   }
   return fgIsA;
}
const char * ::TChargeAnalysisDriver::Class_Name() {return "TChargeAnalysisDriver";}
void ::TChargeAnalysisDriver::Dictionary() {}
const char *::TChargeAnalysisDriver::ImplFileName() {return "";}
int ::TChargeAnalysisDriver::ImplFileLine() {return 1;}
void ::TChargeAnalysisDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TChargeAnalysisDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nPixels", &m_nPixels);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nDetectors", &m_nDetectors);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_writeOut", &m_writeOut);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_writeOutFileName", &m_writeOutFileName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_writeOutFile", &m_writeOutFile);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Q", &m_Q);
   R__insp.InspectMember("std::vector<double>", (void*)&m_Q, "m_Q.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "hPixels2D[6][256]", &hPixels2D);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hPixelsMC", &hPixelsMC);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hPixelsModel", &hPixelsModel);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hEdep", &hEdep);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hLength", &hLength);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_MCTruth", &m_MCTruth);
   TDriver::ShowMembers(R__insp);
}
void ::TChargeAnalysisDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TChargeAnalysisDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TChargeAnalysisDriver::Class(),this);
   }
}

atomic_TClass_ptr TTofpetSetupHandlerDriver::fgIsA(0);
TClass* ::TTofpetSetupHandlerDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TTofpetSetupHandlerDriver");
   }
   return fgIsA;
}
const char * ::TTofpetSetupHandlerDriver::Class_Name() {return "TTofpetSetupHandlerDriver";}
void ::TTofpetSetupHandlerDriver::Dictionary() {}
const char *::TTofpetSetupHandlerDriver::ImplFileName() {return "";}
int ::TTofpetSetupHandlerDriver::ImplFileLine() {return 1;}
void ::TTofpetSetupHandlerDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TTofpetSetupHandlerDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_source", &m_source);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_fname", &m_fname);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_setupHandler", &m_setupHandler);
   TDriver::ShowMembers(R__insp);
}
void ::TTofpetSetupHandlerDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TTofpetSetupHandlerDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TTofpetSetupHandlerDriver::Class(),this);
   }
}

atomic_TClass_ptr TLikelihoodReconDriver::fgIsA(0);
TClass* ::TLikelihoodReconDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TLikelihoodReconDriver");
   }
   return fgIsA;
}
const char * ::TLikelihoodReconDriver::Class_Name() {return "TLikelihoodReconDriver";}
void ::TLikelihoodReconDriver::Dictionary() {}
const char *::TLikelihoodReconDriver::ImplFileName() {return "";}
int ::TLikelihoodReconDriver::ImplFileLine() {return 1;}
void ::TLikelihoodReconDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TLikelihoodReconDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_minimizer", &m_minimizer);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_reconInput", &m_reconInput);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_realSetupHandler", &m_realSetupHandler);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_fitObject", &m_fitObject);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_fitLikelihoodMode", &m_fitLikelihoodMode);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_ON[6]", &m_ON);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_disc[6]", &m_disc);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Q[6]", &m_Q);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_T[6]", &m_T);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_reconInputMode", &m_reconInputMode);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_reconInputFileName", &m_reconInputFileName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_likelihoodCalculator", &m_likelihoodCalculator);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hX", &hX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hY", &hY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hZ", &hZ);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hX_1", &hX_1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hY_1", &hY_1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hZ_1", &hZ_1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hX_2", &hX_2);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hY_2", &hY_2);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hZ_2", &hZ_2);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hXY", &hXY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hXZ", &hXZ);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hYZ", &hYZ);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hXY_1", &hXY_1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hXZ_1", &hXZ_1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hYZ_1", &hYZ_1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hXY_2", &hXY_2);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hXZ_2", &hXZ_2);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hYZ_2", &hYZ_2);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hTheta", &hTheta);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hPhi", &hPhi);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hNPhotons", &hNPhotons);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hT0", &hT0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hTau", &hTau);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*tout", &tout);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_x0", &m_x0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_y0", &m_y0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_z0", &m_z0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_x1", &m_x1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_y1", &m_y1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_z1", &m_z1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_N", &m_N);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_tau", &m_tau);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_beta", &m_beta);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_T0", &m_T0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_L", &m_L);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nON", &m_nON);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_QTOT", &m_QTOT);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_eventN", &m_eventN);
   TDriver::ShowMembers(R__insp);
   R__insp.GenericShowMembers("ROOT::Math::IBaseFunctionMultiDim", ( ::ROOT::Math::IBaseFunctionMultiDim *)(this), false);
}
void ::TLikelihoodReconDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TLikelihoodReconDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TLikelihoodReconDriver::Class(),this);
   }
}

atomic_TClass_ptr TReconInput::fgIsA(0);
TClass* ::TReconInput::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TReconInput");
   }
   return fgIsA;
}
const char * ::TReconInput::Class_Name() {return "TReconInput";}
void ::TReconInput::Dictionary() {}
const char *::TReconInput::ImplFileName() {return "";}
int ::TReconInput::ImplFileLine() {return 1;}
void ::TReconInput::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TReconInput::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_isParConfigured[30]", &m_isParConfigured);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_parVal[30]", &m_parVal);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_isParFixed[30]", &m_isParFixed);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_isParLowLimited[30]", &m_isParLowLimited);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_isParHighLimited[30]", &m_isParHighLimited);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_parLowLimit[30]", &m_parLowLimit);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_parHighLimit[30]", &m_parHighLimit);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_fitObject", &m_fitObject);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_fitLikelihoodMode", &m_fitLikelihoodMode);
   TNamed::ShowMembers(R__insp);
}
void ::TReconInput::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TReconInput::Class(),this);
   } else {
      b.WriteClassBuffer(::TReconInput::Class(),this);
   }
}

atomic_TClass_ptr TEventMarkerDriver::fgIsA(0);
TClass* ::TEventMarkerDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TEventMarkerDriver");
   }
   return fgIsA;
}
const char * ::TEventMarkerDriver::Class_Name() {return "TEventMarkerDriver";}
void ::TEventMarkerDriver::Dictionary() {}
const char *::TEventMarkerDriver::ImplFileName() {return "";}
int ::TEventMarkerDriver::ImplFileLine() {return 1;}
void ::TEventMarkerDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TEventMarkerDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_interval", &m_interval);
   TDriver::ShowMembers(R__insp);
}
void ::TEventMarkerDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TEventMarkerDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TEventMarkerDriver::Class(),this);
   }
}

atomic_TClass_ptr TTofpetDummyAnalysisDriver::fgIsA(0);
TClass* ::TTofpetDummyAnalysisDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TTofpetDummyAnalysisDriver");
   }
   return fgIsA;
}
const char * ::TTofpetDummyAnalysisDriver::Class_Name() {return "TTofpetDummyAnalysisDriver";}
void ::TTofpetDummyAnalysisDriver::Dictionary() {}
const char *::TTofpetDummyAnalysisDriver::ImplFileName() {return "";}
int ::TTofpetDummyAnalysisDriver::ImplFileLine() {return 1;}
void ::TTofpetDummyAnalysisDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TTofpetDummyAnalysisDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hMultiplicity0", &hMultiplicity0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hMultiplicity1", &hMultiplicity1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hMultiplicity2", &hMultiplicity2);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hMultiplicityAverage", &hMultiplicityAverage);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hToT0", &hToT0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hToT1", &hToT1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hToTCh", &hToTCh);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_TofpetRun", &m_TofpetRun);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Nsteps", &m_Nsteps);
   TDriver::ShowMembers(R__insp);
}
void ::TTofpetDummyAnalysisDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TTofpetDummyAnalysisDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TTofpetDummyAnalysisDriver::Class(),this);
   }
}

atomic_TClass_ptr TChargeAnalysisPoissonDriver::fgIsA(0);
TClass* ::TChargeAnalysisPoissonDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TChargeAnalysisPoissonDriver");
   }
   return fgIsA;
}
const char * ::TChargeAnalysisPoissonDriver::Class_Name() {return "TChargeAnalysisPoissonDriver";}
void ::TChargeAnalysisPoissonDriver::Dictionary() {}
const char *::TChargeAnalysisPoissonDriver::ImplFileName() {return "";}
int ::TChargeAnalysisPoissonDriver::ImplFileLine() {return 1;}
void ::TChargeAnalysisPoissonDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TChargeAnalysisPoissonDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nPixels", &m_nPixels);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nDetectors", &m_nDetectors);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_eventsProduced", &m_eventsProduced);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_writeOutFileName", &m_writeOutFileName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_writeOutFile", &m_writeOutFile);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Q", &m_Q);
   R__insp.InspectMember("std::vector<double>", (void*)&m_Q, "m_Q.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "hPixels2D[6][256]", &hPixels2D);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hPixelsMC", &hPixelsMC);
   TDriver::ShowMembers(R__insp);
}
void ::TChargeAnalysisPoissonDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TChargeAnalysisPoissonDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TChargeAnalysisPoissonDriver::Class(),this);
   }
}

atomic_TClass_ptr TRootSaveDriver::fgIsA(0);
TClass* ::TRootSaveDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TRootSaveDriver");
   }
   return fgIsA;
}
const char * ::TRootSaveDriver::Class_Name() {return "TRootSaveDriver";}
void ::TRootSaveDriver::Dictionary() {}
const char *::TRootSaveDriver::ImplFileName() {return "";}
int ::TRootSaveDriver::ImplFileLine() {return 1;}
void ::TRootSaveDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TRootSaveDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_fname", &m_fname);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_fout", &m_fout);
   TDriver::ShowMembers(R__insp);
}
void ::TRootSaveDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TRootSaveDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TRootSaveDriver::Class(),this);
   }
}

atomic_TClass_ptr TLikelihoodCalculatorIdeal::fgIsA(0);
TClass* ::TLikelihoodCalculatorIdeal::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TLikelihoodCalculatorIdeal");
   }
   return fgIsA;
}
const char * ::TLikelihoodCalculatorIdeal::Class_Name() {return "TLikelihoodCalculatorIdeal";}
void ::TLikelihoodCalculatorIdeal::Dictionary() {}
const char *::TLikelihoodCalculatorIdeal::ImplFileName() {return "";}
int ::TLikelihoodCalculatorIdeal::ImplFileLine() {return 1;}
void ::TLikelihoodCalculatorIdeal::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TLikelihoodCalculatorIdeal::IsA();
   if (R__cl || R__insp.IsA()) { }
   TLikelihoodCalculator::ShowMembers(R__insp);
}
void ::TLikelihoodCalculatorIdeal::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TLikelihoodCalculatorIdeal::Class(),this);
   } else {
      b.WriteClassBuffer(::TLikelihoodCalculatorIdeal::Class(),this);
   }
}

atomic_TClass_ptr TMatrixWriterDriver::fgIsA(0);
TClass* ::TMatrixWriterDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TMatrixWriterDriver");
   }
   return fgIsA;
}
const char * ::TMatrixWriterDriver::Class_Name() {return "TMatrixWriterDriver";}
void ::TMatrixWriterDriver::Dictionary() {}
const char *::TMatrixWriterDriver::ImplFileName() {return "";}
int ::TMatrixWriterDriver::ImplFileLine() {return 1;}
void ::TMatrixWriterDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TMatrixWriterDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hPixels", &hPixels);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nPixels", &m_nPixels);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nDetectors", &m_nDetectors);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_voxelID", &m_voxelID);
   TDriver::ShowMembers(R__insp);
}
void ::TMatrixWriterDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TMatrixWriterDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TMatrixWriterDriver::Class(),this);
   }
}

atomic_TClass_ptr TTofpetTimeAnalysisDriver::fgIsA(0);
TClass* ::TTofpetTimeAnalysisDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TTofpetTimeAnalysisDriver");
   }
   return fgIsA;
}
const char * ::TTofpetTimeAnalysisDriver::Class_Name() {return "TTofpetTimeAnalysisDriver";}
void ::TTofpetTimeAnalysisDriver::Dictionary() {}
const char *::TTofpetTimeAnalysisDriver::ImplFileName() {return "";}
int ::TTofpetTimeAnalysisDriver::ImplFileLine() {return 1;}
void ::TTofpetTimeAnalysisDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TTofpetTimeAnalysisDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hMultiplicity0", &hMultiplicity0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hMultiplicity1", &hMultiplicity1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hMultiplicity2", &hMultiplicity2);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hEntries0", &hEntries0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hEntries1", &hEntries1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hToT0", &hToT0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hToT1", &hToT1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hToTch1VSch2", &hToTch1VSch2);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hDeltaT", &hDeltaT);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_TofpetRun", &m_TofpetRun);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*tout", &tout);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Q1", &m_Q1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Q2", &m_Q2);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_T1", &m_T1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_T2", &m_T2);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Nsteps", &m_Nsteps);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_ch1", &m_ch1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_ch2", &m_ch2);
   TDriver::ShowMembers(R__insp);
}
void ::TTofpetTimeAnalysisDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TTofpetTimeAnalysisDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TTofpetTimeAnalysisDriver::Class(),this);
   }
}

atomic_TClass_ptr TJobManager::fgIsA(0);
TClass* ::TJobManager::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TJobManager");
   }
   return fgIsA;
}
const char * ::TJobManager::Class_Name() {return "TJobManager";}
void ::TJobManager::Dictionary() {}
const char *::TJobManager::ImplFileName() {return "";}
int ::TJobManager::ImplFileLine() {return 1;}
void ::TJobManager::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TJobManager::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*fTree", &fTree);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*b_event", &b_event);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_event", &m_event);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_xmlHandler", &m_xmlHandler);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_drivers", &m_drivers);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_detector", &m_detector);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_detectorUtils", &m_detectorUtils);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_variables", &m_variables);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_eventN", &m_eventN);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_doProof", &m_doProof);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_doProofDiag", &m_doProofDiag);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_skipEvents", &m_skipEvents);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_numberOfEvents", &m_numberOfEvents);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_verboseLevel", &m_verboseLevel);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_dryRun", &m_dryRun);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_numberOfWorkers", &m_numberOfWorkers);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_numberOfIterations", &m_numberOfIterations);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_iterationN", &m_iterationN);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_isProofCompatible", &m_isProofCompatible);
   TSelector::ShowMembers(R__insp);
}
void ::TJobManager::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TJobManager::Class(),this);
   } else {
      b.WriteClassBuffer(::TJobManager::Class(),this);
   }
}

atomic_TClass_ptr TMatrixInterpreterDriver::fgIsA(0);
TClass* ::TMatrixInterpreterDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TMatrixInterpreterDriver");
   }
   return fgIsA;
}
const char * ::TMatrixInterpreterDriver::Class_Name() {return "TMatrixInterpreterDriver";}
void ::TMatrixInterpreterDriver::Dictionary() {}
const char *::TMatrixInterpreterDriver::ImplFileName() {return "";}
int ::TMatrixInterpreterDriver::ImplFileLine() {return 1;}
void ::TMatrixInterpreterDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TMatrixInterpreterDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hVoxelRecon", &hVoxelRecon);
   TDriver::ShowMembers(R__insp);
}
void ::TMatrixInterpreterDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TMatrixInterpreterDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TMatrixInterpreterDriver::Class(),this);
   }
}

atomic_TClass_ptr TLikelihoodComputationDriver::fgIsA(0);
TClass* ::TLikelihoodComputationDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TLikelihoodComputationDriver");
   }
   return fgIsA;
}
const char * ::TLikelihoodComputationDriver::Class_Name() {return "TLikelihoodComputationDriver";}
void ::TLikelihoodComputationDriver::Dictionary() {}
const char *::TLikelihoodComputationDriver::ImplFileName() {return "";}
int ::TLikelihoodComputationDriver::ImplFileLine() {return 1;}
void ::TLikelihoodComputationDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TLikelihoodComputationDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_reconInput", &m_reconInput);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_realSetupHandler", &m_realSetupHandler);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_fitObject", &m_fitObject);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_fitLikelihoodMode", &m_fitLikelihoodMode);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_ON[6]", &m_ON);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_disc[6]", &m_disc);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Q[6]", &m_Q);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_T[6]", &m_T);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_reconInputMode", &m_reconInputMode);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_reconInputFileName", &m_reconInputFileName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_likelihoodCalculator", &m_likelihoodCalculator);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hX", &hX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hY", &hY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hZ", &hZ);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hXY", &hXY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hXZ", &hXZ);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hYZ", &hYZ);
   TDriver::ShowMembers(R__insp);
}
void ::TLikelihoodComputationDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TLikelihoodComputationDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TLikelihoodComputationDriver::Class(),this);
   }
}

atomic_TClass_ptr TMarocSetupHandlerDriver::fgIsA(0);
TClass* ::TMarocSetupHandlerDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TMarocSetupHandlerDriver");
   }
   return fgIsA;
}
const char * ::TMarocSetupHandlerDriver::Class_Name() {return "TMarocSetupHandlerDriver";}
void ::TMarocSetupHandlerDriver::Dictionary() {}
const char *::TMarocSetupHandlerDriver::ImplFileName() {return "";}
int ::TMarocSetupHandlerDriver::ImplFileLine() {return 1;}
void ::TMarocSetupHandlerDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TMarocSetupHandlerDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_source", &m_source);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_fname", &m_fname);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_setupHandler", &m_setupHandler);
   TDriver::ShowMembers(R__insp);
}
void ::TMarocSetupHandlerDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TMarocSetupHandlerDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TMarocSetupHandlerDriver::Class(),this);
   }
}

atomic_TClass_ptr TMCDataReaderDriver::fgIsA(0);
TClass* ::TMCDataReaderDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TMCDataReaderDriver");
   }
   return fgIsA;
}
const char * ::TMCDataReaderDriver::Class_Name() {return "TMCDataReaderDriver";}
void ::TMCDataReaderDriver::Dictionary() {}
const char *::TMCDataReaderDriver::ImplFileName() {return "";}
int ::TMCDataReaderDriver::ImplFileLine() {return 1;}
void ::TMCDataReaderDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TMCDataReaderDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_reconHitCollection", &m_reconHitCollection);
   TDriver::ShowMembers(R__insp);
}
void ::TMCDataReaderDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TMCDataReaderDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TMCDataReaderDriver::Class(),this);
   }
}

atomic_TClass_ptr TMarocDataReaderDriver::fgIsA(0);
TClass* ::TMarocDataReaderDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TMarocDataReaderDriver");
   }
   return fgIsA;
}
const char * ::TMarocDataReaderDriver::Class_Name() {return "TMarocDataReaderDriver";}
void ::TMarocDataReaderDriver::Dictionary() {}
const char *::TMarocDataReaderDriver::ImplFileName() {return "";}
int ::TMarocDataReaderDriver::ImplFileLine() {return 1;}
void ::TMarocDataReaderDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TMarocDataReaderDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_reconHitCollection", &m_reconHitCollection);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_marocSetupHandler", &m_marocSetupHandler);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_marocEventHeader", &m_marocEventHeader);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_ChargeCutMin", &m_ChargeCutMin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_ChargeCutMax", &m_ChargeCutMax);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_MultCutMin", &m_MultCutMin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_MultCutMax", &m_MultCutMax);
   TDriver::ShowMembers(R__insp);
}
void ::TMarocDataReaderDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TMarocDataReaderDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TMarocDataReaderDriver::Class(),this);
   }
}

atomic_TClass_ptr TMatrixReconDriver::fgIsA(0);
TClass* ::TMatrixReconDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TMatrixReconDriver");
   }
   return fgIsA;
}
const char * ::TMatrixReconDriver::Class_Name() {return "TMatrixReconDriver";}
void ::TMatrixReconDriver::Dictionary() {}
const char *::TMatrixReconDriver::ImplFileName() {return "";}
int ::TMatrixReconDriver::ImplFileLine() {return 1;}
void ::TMatrixReconDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TMatrixReconDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_matrix", &m_matrix);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_matrixInverse", &m_matrixInverse);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_matrixSource", &m_matrixSource);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_matrixFile", &m_matrixFile);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_matrixFileName", &m_matrixFileName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hVoxelsInput", &hVoxelsInput);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hVoxelsReconAll", &hVoxelsReconAll);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_pixelDataAll", &m_pixelDataAll);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_voxelDataAll", &m_voxelDataAll);
   TDriver::ShowMembers(R__insp);
}
void ::TMatrixReconDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TMatrixReconDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TMatrixReconDriver::Class(),this);
   }
}

atomic_TClass_ptr TTofpetThresholdCalibrationDriver::fgIsA(0);
TClass* ::TTofpetThresholdCalibrationDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TTofpetThresholdCalibrationDriver");
   }
   return fgIsA;
}
const char * ::TTofpetThresholdCalibrationDriver::Class_Name() {return "TTofpetThresholdCalibrationDriver";}
void ::TTofpetThresholdCalibrationDriver::Dictionary() {}
const char *::TTofpetThresholdCalibrationDriver::ImplFileName() {return "";}
int ::TTofpetThresholdCalibrationDriver::ImplFileLine() {return 1;}
void ::TTofpetThresholdCalibrationDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TTofpetThresholdCalibrationDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hToT0", &hToT0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hToTvsThr", &hToTvsThr);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_TTofpetRun", &m_TTofpetRun);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_TTofpetSetupHandler", &m_TTofpetSetupHandler);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_TTofpetThresholdCalibration", &m_TTofpetThresholdCalibration);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_detector", &m_detector);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Nsteps", &m_Nsteps);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Nchannels", &m_Nchannels);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_NhToT0", &m_NhToT0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_NhToTCalib", &m_NhToTCalib);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_hToT0_nbins", &m_hToT0_nbins);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_hToT0_min", &m_hToT0_min);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_hToT0_max", &m_hToT0_max);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_isInteractive", &m_isInteractive);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Thrfname", &m_Thrfname);
   TDriver::ShowMembers(R__insp);
}
void ::TTofpetThresholdCalibrationDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TTofpetThresholdCalibrationDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TTofpetThresholdCalibrationDriver::Class(),this);
   }
}

atomic_TClass_ptr TDriver::fgIsA(0);
TClass* ::TDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TDriver");
   }
   return fgIsA;
}
const char * ::TDriver::Class_Name() {return "TDriver";}
void ::TDriver::Dictionary() {}
const char *::TDriver::ImplFileName() {return "";}
int ::TDriver::ImplFileLine() {return 1;}
void ::TDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_manager", &m_manager);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_name", &m_name);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_verboseLevel", &m_verboseLevel);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_iterationN", &m_iterationN);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_isProofCompatible", &m_isProofCompatible);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_collectionName", &m_collectionName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_collectionRawName", &m_collectionRawName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_collectionOutName", &m_collectionOutName);
   TObject::ShowMembers(R__insp);
}
void ::TDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TDriver::Class(),this);
   }
}

atomic_TClass_ptr TLikelihoodCalculatorMaroc1::fgIsA(0);
TClass* ::TLikelihoodCalculatorMaroc1::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TLikelihoodCalculatorMaroc1");
   }
   return fgIsA;
}
const char * ::TLikelihoodCalculatorMaroc1::Class_Name() {return "TLikelihoodCalculatorMaroc1";}
void ::TLikelihoodCalculatorMaroc1::Dictionary() {}
const char *::TLikelihoodCalculatorMaroc1::ImplFileName() {return "";}
int ::TLikelihoodCalculatorMaroc1::ImplFileLine() {return 1;}
void ::TLikelihoodCalculatorMaroc1::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TLikelihoodCalculatorMaroc1::IsA();
   if (R__cl || R__insp.IsA()) { }
   TLikelihoodCalculator::ShowMembers(R__insp);
}
void ::TLikelihoodCalculatorMaroc1::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TLikelihoodCalculatorMaroc1::Class(),this);
   } else {
      b.WriteClassBuffer(::TLikelihoodCalculatorMaroc1::Class(),this);
   }
}

atomic_TClass_ptr TLikelihoodCalculator::fgIsA(0);
TClass* ::TLikelihoodCalculator::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TLikelihoodCalculator");
   }
   return fgIsA;
}
const char * ::TLikelihoodCalculator::Class_Name() {return "TLikelihoodCalculator";}
void ::TLikelihoodCalculator::Dictionary() {}
const char *::TLikelihoodCalculator::ImplFileName() {return "";}
int ::TLikelihoodCalculator::ImplFileLine() {return 1;}
void ::TLikelihoodCalculator::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TLikelihoodCalculator::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_driver", &m_driver);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_detector", &m_detector);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_detectorUtils", &m_detectorUtils);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_realSetupHandler", &m_realSetupHandler);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_ON[6]", &m_ON);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_disc[6]", &m_disc);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Q[6]", &m_Q);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_T[6]", &m_T);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_fitObject", &m_fitObject);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_fitLikelihoodMode", &m_fitLikelihoodMode);
   TObject::ShowMembers(R__insp);
}
void ::TLikelihoodCalculator::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TLikelihoodCalculator::Class(),this);
   } else {
      b.WriteClassBuffer(::TLikelihoodCalculator::Class(),this);
   }
}

atomic_TClass_ptr TAnalysis::fgIsA(0);
TClass* ::TAnalysis::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TAnalysis");
   }
   return fgIsA;
}
const char * ::TAnalysis::Class_Name() {return "TAnalysis";}
void ::TAnalysis::Dictionary() {}
const char *::TAnalysis::ImplFileName() {return "";}
int ::TAnalysis::ImplFileLine() {return 1;}
void ::TAnalysis::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TAnalysis::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_manager", &m_manager);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_chain", &m_chain);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_proof", &m_proof);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_steeringName", &m_steeringName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_detName", &m_detName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_fileName", &m_fileName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "isConfigured", &isConfigured);
   TObject::ShowMembers(R__insp);
}
void ::TAnalysis::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TAnalysis::Class(),this);
   } else {
      b.WriteClassBuffer(::TAnalysis::Class(),this);
   }
}

atomic_TClass_ptr TReconHit::fgIsA(0);
TClass* ::TReconHit::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TReconHit");
   }
   return fgIsA;
}
const char * ::TReconHit::Class_Name() {return "TReconHit";}
void ::TReconHit::Dictionary() {}
const char *::TReconHit::ImplFileName() {return "";}
int ::TReconHit::ImplFileLine() {return 1;}
void ::TReconHit::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TReconHit::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "face", &face);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detector", &detector);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "pixel", &pixel);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "nPhe", &nPhe);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "Q", &Q);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "T", &T);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "hit", &hit);
   TObject::ShowMembers(R__insp);
}
void ::TReconHit::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TReconHit::Class(),this);
   } else {
      b.WriteClassBuffer(::TReconHit::Class(),this);
   }
}

atomic_TClass_ptr TMarocBasicDriver::fgIsA(0);
TClass* ::TMarocBasicDriver::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TMarocBasicDriver");
   }
   return fgIsA;
}
const char * ::TMarocBasicDriver::Class_Name() {return "TMarocBasicDriver";}
void ::TMarocBasicDriver::Dictionary() {}
const char *::TMarocBasicDriver::ImplFileName() {return "";}
int ::TMarocBasicDriver::ImplFileLine() {return 1;}
void ::TMarocBasicDriver::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TMarocBasicDriver::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hMultiplicity0", &hMultiplicity0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hQTot0", &hQTot0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*hQTotvsMultiplicity0", &hQTotvsMultiplicity0);
   TDriver::ShowMembers(R__insp);
}
void ::TMarocBasicDriver::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TMarocBasicDriver::Class(),this);
   } else {
      b.WriteClassBuffer(::TMarocBasicDriver::Class(),this);
   }
}


namespace {
//------Stub functions for class TChargeAnalysisDriver -------------------------------
static void constructor_3621( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TChargeAnalysisDriver();
  else ::new(mem) ::TChargeAnalysisDriver();
}

static void destructor_3622(void*, void * o, const std::vector<void*>&, void *) {
((::TChargeAnalysisDriver*)o)->::TChargeAnalysisDriver::~TChargeAnalysisDriver();
}
static  void method_3623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TChargeAnalysisDriver*)o)->start)());
  else   (((::TChargeAnalysisDriver*)o)->start)();
}

static  void method_3624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TChargeAnalysisDriver*)o)->startOfData)());
  else   (((::TChargeAnalysisDriver*)o)->startOfData)();
}

static  void method_3625( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TChargeAnalysisDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TChargeAnalysisDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_3626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TChargeAnalysisDriver*)o)->end)());
  else   (((::TChargeAnalysisDriver*)o)->end)();
}

static  void method_3627( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TChargeAnalysisDriver*)o)->setWriteOutFileName)((const char*)arg[0]);
}

static  void method_3628( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TChargeAnalysisDriver*)o)->Class)());
  else   (((::TChargeAnalysisDriver*)o)->Class)();
}

static  void method_3629( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TChargeAnalysisDriver*)o)->Class_Name)());
  else   (((::TChargeAnalysisDriver*)o)->Class_Name)();
}

static  void method_3630( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TChargeAnalysisDriver*)o)->Class_Version)());
  else   (((::TChargeAnalysisDriver*)o)->Class_Version)();
}

static  void method_3631( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TChargeAnalysisDriver*)o)->Dictionary)();
}

static  void method_3632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TChargeAnalysisDriver*)o)->IsA)());
  else   (((const ::TChargeAnalysisDriver*)o)->IsA)();
}

static  void method_3633( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TChargeAnalysisDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_3634( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TChargeAnalysisDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_3635( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TChargeAnalysisDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_3636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TChargeAnalysisDriver*)o)->DeclFileName)());
  else   (((::TChargeAnalysisDriver*)o)->DeclFileName)();
}

static  void method_3637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TChargeAnalysisDriver*)o)->ImplFileLine)());
  else   (((::TChargeAnalysisDriver*)o)->ImplFileLine)();
}

static  void method_3638( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TChargeAnalysisDriver*)o)->ImplFileName)());
  else   (((::TChargeAnalysisDriver*)o)->ImplFileName)();
}

static  void method_3639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TChargeAnalysisDriver*)o)->DeclFileLine)());
  else   (((::TChargeAnalysisDriver*)o)->DeclFileLine)();
}

static void method_newdel_106( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TChargeAnalysisDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TChargeAnalysisDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TChargeAnalysisDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TChargeAnalysisDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TChargeAnalysisDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TChargeAnalysisDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TChargeAnalysisDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TChargeAnalysisDriver -------------------------------
void __TChargeAnalysisDriver_db_datamem(Reflex::Class*);
void __TChargeAnalysisDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TChargeAnalysisDriver_datamem_bld(&__TChargeAnalysisDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TChargeAnalysisDriver_funcmem_bld(&__TChargeAnalysisDriver_db_funcmem);
void __TChargeAnalysisDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TChargeAnalysisDriver"), typeid(::TChargeAnalysisDriver), sizeof(::TChargeAnalysisDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TChargeAnalysisDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2618, ::Reflex::BaseOffset< ::TChargeAnalysisDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TChargeAnalysisDriver"), constructor_3621, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TChargeAnalysisDriver"), destructor_3622, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_106, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TChargeAnalysisDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TChargeAnalysisDriver_funcmem_bld);
}

//------Delayed data member builder for class TChargeAnalysisDriver -------------------
void __TChargeAnalysisDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_150, Reflex::Literal("m_nPixels"), OffsetOf(__shadow__::__TChargeAnalysisDriver, m_nPixels), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_nDetectors"), OffsetOf(__shadow__::__TChargeAnalysisDriver, m_nDetectors), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_writeOut"), OffsetOf(__shadow__::__TChargeAnalysisDriver, m_writeOut), ::Reflex::PRIVATE)
  .AddDataMember(type_2955, Reflex::Literal("m_writeOutFileName"), OffsetOf(__shadow__::__TChargeAnalysisDriver, m_writeOutFileName), ::Reflex::PRIVATE)
  .AddDataMember(type_1376, Reflex::Literal("m_writeOutFile"), OffsetOf(__shadow__::__TChargeAnalysisDriver, m_writeOutFile), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_2918, Reflex::Literal("m_Q"), OffsetOf(__shadow__::__TChargeAnalysisDriver, m_Q), ::Reflex::PRIVATE)
  .AddDataMember(type_15660, Reflex::Literal("hPixels2D"), OffsetOf(__shadow__::__TChargeAnalysisDriver, hPixels2D), ::Reflex::PRIVATE)
  .AddDataMember(type_15661, Reflex::Literal("hPixelsMC"), OffsetOf(__shadow__::__TChargeAnalysisDriver, hPixelsMC), ::Reflex::PRIVATE)
  .AddDataMember(type_15661, Reflex::Literal("hPixelsModel"), OffsetOf(__shadow__::__TChargeAnalysisDriver, hPixelsModel), ::Reflex::PRIVATE)
  .AddDataMember(type_15661, Reflex::Literal("hEdep"), OffsetOf(__shadow__::__TChargeAnalysisDriver, hEdep), ::Reflex::PRIVATE)
  .AddDataMember(type_15661, Reflex::Literal("hLength"), OffsetOf(__shadow__::__TChargeAnalysisDriver, hLength), ::Reflex::PRIVATE)
  .AddDataMember(type_15662, Reflex::Literal("m_MCTruth"), OffsetOf(__shadow__::__TChargeAnalysisDriver, m_MCTruth), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TChargeAnalysisDriver -------------------
void __TChargeAnalysisDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("start"), method_3623, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("startOfData"), method_3624, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_15663), Reflex::Literal("process"), method_3625, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("end"), method_3626, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_3438), Reflex::Literal("setWriteOutFileName"), method_3627, 0, "fname", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_3628, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_3629, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_3630, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_3631, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_3632, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_3633, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_3634, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_3635, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_3636, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_3637, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_3638, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_3639, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TTofpetSetupHandlerDriver -------------------------------
static  void operator_3825( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TTofpetSetupHandlerDriver*)o)->operator=)(*(const ::TTofpetSetupHandlerDriver*)arg[0]);
  else   (((::TTofpetSetupHandlerDriver*)o)->operator=)(*(const ::TTofpetSetupHandlerDriver*)arg[0]);
}

static void constructor_3826( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetSetupHandlerDriver(*(const ::TTofpetSetupHandlerDriver*)arg[0]);
  else ::new(mem) ::TTofpetSetupHandlerDriver(*(const ::TTofpetSetupHandlerDriver*)arg[0]);
}

static void constructor_3827( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetSetupHandlerDriver();
  else ::new(mem) ::TTofpetSetupHandlerDriver();
}

static void destructor_3828(void*, void * o, const std::vector<void*>&, void *) {
((::TTofpetSetupHandlerDriver*)o)->::TTofpetSetupHandlerDriver::~TTofpetSetupHandlerDriver();
}
static  void method_3829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetSetupHandlerDriver*)o)->start)());
  else   (((::TTofpetSetupHandlerDriver*)o)->start)();
}

static  void method_3830( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetSetupHandlerDriver*)o)->setSource)(*(int*)arg[0]);
}

static  void method_3831( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetSetupHandlerDriver*)o)->setFileName)((const char*)arg[0]);
}

static  void method_3832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetSetupHandlerDriver*)o)->Class)());
  else   (((::TTofpetSetupHandlerDriver*)o)->Class)();
}

static  void method_3833( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetSetupHandlerDriver*)o)->Class_Name)());
  else   (((::TTofpetSetupHandlerDriver*)o)->Class_Name)();
}

static  void method_3834( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TTofpetSetupHandlerDriver*)o)->Class_Version)());
  else   (((::TTofpetSetupHandlerDriver*)o)->Class_Version)();
}

static  void method_3835( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetSetupHandlerDriver*)o)->Dictionary)();
}

static  void method_3836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetSetupHandlerDriver*)o)->IsA)());
  else   (((const ::TTofpetSetupHandlerDriver*)o)->IsA)();
}

static  void method_3837( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetSetupHandlerDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_3838( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetSetupHandlerDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_3839( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetSetupHandlerDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_3840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetSetupHandlerDriver*)o)->DeclFileName)());
  else   (((::TTofpetSetupHandlerDriver*)o)->DeclFileName)();
}

static  void method_3841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetSetupHandlerDriver*)o)->ImplFileLine)());
  else   (((::TTofpetSetupHandlerDriver*)o)->ImplFileLine)();
}

static  void method_3842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetSetupHandlerDriver*)o)->ImplFileName)());
  else   (((::TTofpetSetupHandlerDriver*)o)->ImplFileName)();
}

static  void method_3843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetSetupHandlerDriver*)o)->DeclFileLine)());
  else   (((::TTofpetSetupHandlerDriver*)o)->DeclFileLine)();
}

static void method_newdel_140( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TTofpetSetupHandlerDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TTofpetSetupHandlerDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TTofpetSetupHandlerDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TTofpetSetupHandlerDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TTofpetSetupHandlerDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TTofpetSetupHandlerDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TTofpetSetupHandlerDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TTofpetSetupHandlerDriver -------------------------------
void __TTofpetSetupHandlerDriver_db_datamem(Reflex::Class*);
void __TTofpetSetupHandlerDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TTofpetSetupHandlerDriver_datamem_bld(&__TTofpetSetupHandlerDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TTofpetSetupHandlerDriver_funcmem_bld(&__TTofpetSetupHandlerDriver_db_funcmem);
void __TTofpetSetupHandlerDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TTofpetSetupHandlerDriver"), typeid(::TTofpetSetupHandlerDriver), sizeof(::TTofpetSetupHandlerDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TTofpetSetupHandlerDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2618, ::Reflex::BaseOffset< ::TTofpetSetupHandlerDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15683, type_15684), Reflex::Literal("operator="), operator_3825, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15684), Reflex::Literal("TTofpetSetupHandlerDriver"), constructor_3826, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TTofpetSetupHandlerDriver"), constructor_3827, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TTofpetSetupHandlerDriver"), destructor_3828, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_140, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TTofpetSetupHandlerDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TTofpetSetupHandlerDriver_funcmem_bld);
}

//------Delayed data member builder for class TTofpetSetupHandlerDriver -------------------
void __TTofpetSetupHandlerDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_150, Reflex::Literal("m_source"), OffsetOf(__shadow__::__TTofpetSetupHandlerDriver, m_source), ::Reflex::PRIVATE)
  .AddDataMember(type_2955, Reflex::Literal("m_fname"), OffsetOf(__shadow__::__TTofpetSetupHandlerDriver, m_fname), ::Reflex::PRIVATE)
  .AddDataMember(type_15682, Reflex::Literal("m_setupHandler"), OffsetOf(__shadow__::__TTofpetSetupHandlerDriver, m_setupHandler), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TTofpetSetupHandlerDriver -------------------
void __TTofpetSetupHandlerDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("start"), method_3829, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setSource"), method_3830, 0, "source", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_3438), Reflex::Literal("setFileName"), method_3831, 0, "fname", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_3832, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_3833, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_3834, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_3835, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_3836, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_3837, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_3838, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_3839, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_3840, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_3841, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_3842, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_3843, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TLikelihoodReconDriver -------------------------------
static  void operator_4209( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TLikelihoodReconDriver*)o)->operator=)(*(const ::TLikelihoodReconDriver*)arg[0]);
  else   (((::TLikelihoodReconDriver*)o)->operator=)(*(const ::TLikelihoodReconDriver*)arg[0]);
}

static void constructor_4210( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TLikelihoodReconDriver(*(const ::TLikelihoodReconDriver*)arg[0]);
  else ::new(mem) ::TLikelihoodReconDriver(*(const ::TLikelihoodReconDriver*)arg[0]);
}

static void constructor_4211( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TLikelihoodReconDriver();
  else ::new(mem) ::TLikelihoodReconDriver();
}

static void destructor_4212(void*, void * o, const std::vector<void*>&, void *) {
((::TLikelihoodReconDriver*)o)->::TLikelihoodReconDriver::~TLikelihoodReconDriver();
}
static  void method_4213( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TLikelihoodReconDriver*)o)->initFit)();
}

static  void method_4214( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TLikelihoodReconDriver*)o)->doFit)();
}

static  void method_4215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodReconDriver*)o)->getMinimizer)());
  else   (((::TLikelihoodReconDriver*)o)->getMinimizer)();
}

static  void method_4216( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TLikelihoodReconDriver*)o)->initParameters)();
}

static  void method_4217( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodReconDriver*)o)->setFitObject)(*(::fitObject_t*)arg[0]);
}

static  void method_4218( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodReconDriver*)o)->setFitLikelihoodMode)(*(::fitLikelihoodMode_t*)arg[0]);
}

static  void method_4219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodReconDriver*)o)->getFitObject)());
  else   (((::TLikelihoodReconDriver*)o)->getFitObject)();
}

static  void method_4220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodReconDriver*)o)->getFitLikelihoodMode)());
  else   (((::TLikelihoodReconDriver*)o)->getFitLikelihoodMode)();
}

static  void method_4221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodReconDriver*)o)->start)());
  else   (((::TLikelihoodReconDriver*)o)->start)();
}

static  void method_4222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodReconDriver*)o)->startOfData)());
  else   (((::TLikelihoodReconDriver*)o)->startOfData)();
}

static  void method_4223( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodReconDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TLikelihoodReconDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_4224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodReconDriver*)o)->endOfData)());
  else   (((::TLikelihoodReconDriver*)o)->endOfData)();
}

static  void method_4225( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodReconDriver*)o)->DoEval)((const double*)arg[0]));
  else   (((const ::TLikelihoodReconDriver*)o)->DoEval)((const double*)arg[0]);
}

static  void method_4226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::TLikelihoodReconDriver*)o)->NDim)());
  else   (((const ::TLikelihoodReconDriver*)o)->NDim)();
}

static  void method_4227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TLikelihoodReconDriver*)o)->Clone)());
  else   (((const ::TLikelihoodReconDriver*)o)->Clone)();
}

static  void method_4228( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodReconDriver*)o)->configLikelihoodCalculator)((const char*)arg[0]);
}

static  void method_4229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TLikelihoodReconDriver*)o)->getLikelihoodCalculator)());
  else   (((const ::TLikelihoodReconDriver*)o)->getLikelihoodCalculator)();
}

static  void method_4230( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodReconDriver*)o)->setLikelihoodCalculator)((::TLikelihoodCalculator*)arg[0]);
}

static  void method_4231( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodReconDriver*)o)->setReconInputMode)((const char*)arg[0]);
}

static  void method_4232( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodReconDriver*)o)->setReconInputFileName)((const char*)arg[0]);
}

static  void method_4235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodReconDriver*)o)->Class)());
  else   (((::TLikelihoodReconDriver*)o)->Class)();
}

static  void method_4236( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodReconDriver*)o)->Class_Name)());
  else   (((::TLikelihoodReconDriver*)o)->Class_Name)();
}

static  void method_4237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TLikelihoodReconDriver*)o)->Class_Version)());
  else   (((::TLikelihoodReconDriver*)o)->Class_Version)();
}

static  void method_4238( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TLikelihoodReconDriver*)o)->Dictionary)();
}

static  void method_4239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TLikelihoodReconDriver*)o)->IsA)());
  else   (((const ::TLikelihoodReconDriver*)o)->IsA)();
}

static  void method_4240( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodReconDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4241( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodReconDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4242( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodReconDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodReconDriver*)o)->DeclFileName)());
  else   (((::TLikelihoodReconDriver*)o)->DeclFileName)();
}

static  void method_4244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodReconDriver*)o)->ImplFileLine)());
  else   (((::TLikelihoodReconDriver*)o)->ImplFileLine)();
}

static  void method_4245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodReconDriver*)o)->ImplFileName)());
  else   (((::TLikelihoodReconDriver*)o)->ImplFileName)();
}

static  void method_4246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodReconDriver*)o)->DeclFileLine)());
  else   (((::TLikelihoodReconDriver*)o)->DeclFileLine)();
}

static void method_newdel_228( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TLikelihoodReconDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TLikelihoodReconDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TLikelihoodReconDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TLikelihoodReconDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TLikelihoodReconDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TLikelihoodReconDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TLikelihoodReconDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::IBaseFunctionMultiDim")), ::Reflex::BaseOffset< ::TLikelihoodReconDriver,::ROOT::Math::IBaseFunctionMultiDim >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TLikelihoodReconDriver -------------------------------
void __TLikelihoodReconDriver_db_datamem(Reflex::Class*);
void __TLikelihoodReconDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TLikelihoodReconDriver_datamem_bld(&__TLikelihoodReconDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TLikelihoodReconDriver_funcmem_bld(&__TLikelihoodReconDriver_db_funcmem);
void __TLikelihoodReconDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TLikelihoodReconDriver"), typeid(::TLikelihoodReconDriver), sizeof(::TLikelihoodReconDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TLikelihoodReconDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2618, ::Reflex::BaseOffset< ::TLikelihoodReconDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddBase(type_4247, ::Reflex::BaseOffset< ::TLikelihoodReconDriver, ::ROOT::Math::IBaseFunctionMultiDim >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15770, type_15771), Reflex::Literal("operator="), operator_4209, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15771), Reflex::Literal("TLikelihoodReconDriver"), constructor_4210, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TLikelihoodReconDriver"), constructor_4211, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TLikelihoodReconDriver"), destructor_4212, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_228, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TLikelihoodReconDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TLikelihoodReconDriver_funcmem_bld);
}

//------Delayed data member builder for class TLikelihoodReconDriver -------------------
void __TLikelihoodReconDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_15763, Reflex::Literal("m_minimizer"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_minimizer), ::Reflex::PROTECTED)
  .AddDataMember(type_15764, Reflex::Literal("m_reconInput"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_reconInput), ::Reflex::PROTECTED)
  .AddDataMember(type_15765, Reflex::Literal("m_realSetupHandler"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_realSetupHandler), ::Reflex::PROTECTED)
  .AddDataMember(type_402, Reflex::Literal("m_fitObject"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_fitObject), ::Reflex::PROTECTED)
  .AddDataMember(type_1016, Reflex::Literal("m_fitLikelihoodMode"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_fitLikelihoodMode), ::Reflex::PROTECTED)
  .AddDataMember(type_15766, Reflex::Literal("m_ON"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_ON), ::Reflex::PROTECTED)
  .AddDataMember(type_15766, Reflex::Literal("m_disc"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_disc), ::Reflex::PROTECTED)
  .AddDataMember(type_15767, Reflex::Literal("m_Q"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_Q), ::Reflex::PROTECTED)
  .AddDataMember(type_15767, Reflex::Literal("m_T"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_T), ::Reflex::PROTECTED)
  .AddDataMember(type_150, Reflex::Literal("m_reconInputMode"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_reconInputMode), ::Reflex::PROTECTED)
  .AddDataMember(type_2955, Reflex::Literal("m_reconInputFileName"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_reconInputFileName), ::Reflex::PROTECTED)
  .AddDataMember(type_15768, Reflex::Literal("m_likelihoodCalculator"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_likelihoodCalculator), ::Reflex::PROTECTED)
  .AddDataMember(type_15661, Reflex::Literal("hX"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hX), ::Reflex::PROTECTED)
  .AddDataMember(type_15661, Reflex::Literal("hY"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hY), ::Reflex::PROTECTED)
  .AddDataMember(type_15661, Reflex::Literal("hZ"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hZ), ::Reflex::PROTECTED)
  .AddDataMember(type_15661, Reflex::Literal("hX_1"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hX_1), ::Reflex::PROTECTED)
  .AddDataMember(type_15661, Reflex::Literal("hY_1"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hY_1), ::Reflex::PROTECTED)
  .AddDataMember(type_15661, Reflex::Literal("hZ_1"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hZ_1), ::Reflex::PROTECTED)
  .AddDataMember(type_15661, Reflex::Literal("hX_2"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hX_2), ::Reflex::PROTECTED)
  .AddDataMember(type_15661, Reflex::Literal("hY_2"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hY_2), ::Reflex::PROTECTED)
  .AddDataMember(type_15661, Reflex::Literal("hZ_2"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hZ_2), ::Reflex::PROTECTED)
  .AddDataMember(type_15769, Reflex::Literal("hXY"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hXY), ::Reflex::PROTECTED)
  .AddDataMember(type_15769, Reflex::Literal("hXZ"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hXZ), ::Reflex::PROTECTED)
  .AddDataMember(type_15769, Reflex::Literal("hYZ"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hYZ), ::Reflex::PROTECTED)
  .AddDataMember(type_15769, Reflex::Literal("hXY_1"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hXY_1), ::Reflex::PROTECTED)
  .AddDataMember(type_15769, Reflex::Literal("hXZ_1"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hXZ_1), ::Reflex::PROTECTED)
  .AddDataMember(type_15769, Reflex::Literal("hYZ_1"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hYZ_1), ::Reflex::PROTECTED)
  .AddDataMember(type_15769, Reflex::Literal("hXY_2"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hXY_2), ::Reflex::PROTECTED)
  .AddDataMember(type_15769, Reflex::Literal("hXZ_2"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hXZ_2), ::Reflex::PROTECTED)
  .AddDataMember(type_15769, Reflex::Literal("hYZ_2"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hYZ_2), ::Reflex::PROTECTED)
  .AddDataMember(type_15661, Reflex::Literal("hTheta"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hTheta), ::Reflex::PROTECTED)
  .AddDataMember(type_15661, Reflex::Literal("hPhi"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hPhi), ::Reflex::PROTECTED)
  .AddDataMember(type_15661, Reflex::Literal("hNPhotons"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hNPhotons), ::Reflex::PROTECTED)
  .AddDataMember(type_15661, Reflex::Literal("hT0"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hT0), ::Reflex::PROTECTED)
  .AddDataMember(type_15661, Reflex::Literal("hTau"), OffsetOf(__shadow__::__TLikelihoodReconDriver, hTau), ::Reflex::PROTECTED)
  .AddDataMember(type_5840, Reflex::Literal("tout"), OffsetOf(__shadow__::__TLikelihoodReconDriver, tout), ::Reflex::PROTECTED)
  .AddDataMember(type_247, Reflex::Literal("m_x0"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_x0), ::Reflex::PROTECTED)
  .AddDataMember(type_247, Reflex::Literal("m_y0"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_y0), ::Reflex::PROTECTED)
  .AddDataMember(type_247, Reflex::Literal("m_z0"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_z0), ::Reflex::PROTECTED)
  .AddDataMember(type_247, Reflex::Literal("m_x1"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_x1), ::Reflex::PROTECTED)
  .AddDataMember(type_247, Reflex::Literal("m_y1"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_y1), ::Reflex::PROTECTED)
  .AddDataMember(type_247, Reflex::Literal("m_z1"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_z1), ::Reflex::PROTECTED)
  .AddDataMember(type_247, Reflex::Literal("m_N"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_N), ::Reflex::PROTECTED)
  .AddDataMember(type_247, Reflex::Literal("m_tau"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_tau), ::Reflex::PROTECTED)
  .AddDataMember(type_247, Reflex::Literal("m_beta"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_beta), ::Reflex::PROTECTED)
  .AddDataMember(type_247, Reflex::Literal("m_T0"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_T0), ::Reflex::PROTECTED)
  .AddDataMember(type_247, Reflex::Literal("m_L"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_L), ::Reflex::PROTECTED)
  .AddDataMember(type_150, Reflex::Literal("m_nON"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_nON), ::Reflex::PROTECTED)
  .AddDataMember(type_247, Reflex::Literal("m_QTOT"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_QTOT), ::Reflex::PROTECTED)
  .AddDataMember(type_150, Reflex::Literal("m_eventN"), OffsetOf(__shadow__::__TLikelihoodReconDriver, m_eventN), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class TLikelihoodReconDriver -------------------
void __TLikelihoodReconDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("initFit"), method_4213, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("doFit"), method_4214, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15763), Reflex::Literal("getMinimizer"), method_4215, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("initParameters"), method_4216, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_402), Reflex::Literal("setFitObject"), method_4217, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_1016), Reflex::Literal("setFitLikelihoodMode"), method_4218, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_402), Reflex::Literal("getFitObject"), method_4219, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016), Reflex::Literal("getFitLikelihoodMode"), method_4220, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("start"), method_4221, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("startOfData"), method_4222, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_15663), Reflex::Literal("process"), method_4223, 0, "m_event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("endOfData"), method_4224, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247, type_12392), Reflex::Literal("DoEval"), method_4225, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_218), Reflex::Literal("NDim"), method_4226, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15775), Reflex::Literal("Clone"), method_4227, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_3438), Reflex::Literal("configLikelihoodCalculator"), method_4228, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15768), Reflex::Literal("getLikelihoodCalculator"), method_4229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15768), Reflex::Literal("setLikelihoodCalculator"), method_4230, 0, "likelihoodCalculator", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_3438), Reflex::Literal("setReconInputMode"), method_4231, 0, "mode", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_3438), Reflex::Literal("setReconInputFileName"), method_4232, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_4235, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_4236, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_4237, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_4238, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_4239, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_4240, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_4241, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_4242, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_4243, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_4244, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_4245, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_4246, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TReconInput -------------------------------
static  void operator_4838( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TReconInput*)o)->operator=)(*(const ::TReconInput*)arg[0]);
  else   (((::TReconInput*)o)->operator=)(*(const ::TReconInput*)arg[0]);
}

static void constructor_4839( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TReconInput(*(const ::TReconInput*)arg[0]);
  else ::new(mem) ::TReconInput(*(const ::TReconInput*)arg[0]);
}

static void constructor_4840( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TReconInput();
  else ::new(mem) ::TReconInput();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TReconInput(*(::std::string*)arg[0]);
  else ::new(mem) ::TReconInput(*(::std::string*)arg[0]);
  }
}

static void destructor_4841(void*, void * o, const std::vector<void*>&, void *) {
((::TReconInput*)o)->::TReconInput::~TReconInput();
}
static  void method_4842( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TReconInput*)o)->getParVal)(*(int*)arg[0]));
  else   (((const ::TReconInput*)o)->getParVal)(*(int*)arg[0]);
}

static  void method_4843( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconInput*)o)->setParVal)(*(int*)arg[0],
    *(double*)arg[1]);
}

static  void method_4844( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TReconInput*)o)->isParFixed)(*(int*)arg[0]));
  else   (((const ::TReconInput*)o)->isParFixed)(*(int*)arg[0]);
}

static  void method_4845( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::TReconInput*)o)->setParFixed)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::TReconInput*)o)->setParFixed)(*(int*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_4846( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TReconInput*)o)->isParLowLimited)(*(int*)arg[0]));
  else   (((const ::TReconInput*)o)->isParLowLimited)(*(int*)arg[0]);
}

static  void method_4847( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::TReconInput*)o)->setParLowLimited)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::TReconInput*)o)->setParLowLimited)(*(int*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_4848( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TReconInput*)o)->getParLowLimit)(*(int*)arg[0]));
  else   (((const ::TReconInput*)o)->getParLowLimit)(*(int*)arg[0]);
}

static  void method_4849( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconInput*)o)->setParLowLimit)(*(int*)arg[0],
    *(double*)arg[1]);
}

static  void method_4850( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TReconInput*)o)->isParHighLimited)(*(int*)arg[0]));
  else   (((const ::TReconInput*)o)->isParHighLimited)(*(int*)arg[0]);
}

static  void method_4851( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::TReconInput*)o)->setParHighLimited)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::TReconInput*)o)->setParHighLimited)(*(int*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_4852( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TReconInput*)o)->getParHighLimit)(*(int*)arg[0]));
  else   (((const ::TReconInput*)o)->getParHighLimit)(*(int*)arg[0]);
}

static  void method_4853( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconInput*)o)->setParHighLimit)(*(int*)arg[0],
    *(double*)arg[1]);
}

static  void method_4854( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TReconInput*)o)->isParBothLimited)(*(int*)arg[0]));
  else   (((const ::TReconInput*)o)->isParBothLimited)(*(int*)arg[0]);
}

static  void method_4855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TReconInput*)o)->getFitObject)());
  else   (((const ::TReconInput*)o)->getFitObject)();
}

static  void method_4856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TReconInput*)o)->getFitLikelihoodMode)());
  else   (((::TReconInput*)o)->getFitLikelihoodMode)();
}

static  void method_4857( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::TReconInput*)o)->Print)();
}

static  void method_4858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TReconInput*)o)->Class)());
  else   (((::TReconInput*)o)->Class)();
}

static  void method_4859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TReconInput*)o)->Class_Name)());
  else   (((::TReconInput*)o)->Class_Name)();
}

static  void method_4860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TReconInput*)o)->Class_Version)());
  else   (((::TReconInput*)o)->Class_Version)();
}

static  void method_4861( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TReconInput*)o)->Dictionary)();
}

static  void method_4862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TReconInput*)o)->IsA)());
  else   (((const ::TReconInput*)o)->IsA)();
}

static  void method_4863( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconInput*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4864( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconInput*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4865( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconInput*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TReconInput*)o)->DeclFileName)());
  else   (((::TReconInput*)o)->DeclFileName)();
}

static  void method_4867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TReconInput*)o)->ImplFileLine)());
  else   (((::TReconInput*)o)->ImplFileLine)();
}

static  void method_4868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TReconInput*)o)->ImplFileName)());
  else   (((::TReconInput*)o)->ImplFileName)();
}

static  void method_4869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TReconInput*)o)->DeclFileLine)());
  else   (((::TReconInput*)o)->DeclFileLine)();
}

static void constructor_x6( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TReconInput();
  else ::new(mem) ::TReconInput();
}

static void method_newdel_523( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TReconInput >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TReconInput >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TReconInput >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TReconInput >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TReconInput >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::TReconInput,::TNamed >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TReconInput,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TReconInput -------------------------------
void __TReconInput_db_datamem(Reflex::Class*);
void __TReconInput_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TReconInput_datamem_bld(&__TReconInput_db_datamem);
Reflex::GenreflexMemberBuilder __TReconInput_funcmem_bld(&__TReconInput_db_funcmem);
void __TReconInput_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TReconInput"), typeid(::TReconInput), sizeof(::TReconInput), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TReconInput::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2698, ::Reflex::BaseOffset< ::TReconInput, ::TNamed >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15884, type_15885), Reflex::Literal("operator="), operator_4838, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15885), Reflex::Literal("TReconInput"), constructor_4839, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2955), Reflex::Literal("TReconInput"), constructor_4840, 0, "fname=\"\"", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TReconInput"), destructor_4841, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TReconInput"), constructor_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_523, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TReconInput_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TReconInput_funcmem_bld);
}

//------Delayed data member builder for class TReconInput -------------------
void __TReconInput_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_15882, Reflex::Literal("m_isParConfigured"), OffsetOf(__shadow__::__TReconInput, m_isParConfigured), ::Reflex::PRIVATE)
  .AddDataMember(type_15883, Reflex::Literal("m_parVal"), OffsetOf(__shadow__::__TReconInput, m_parVal), ::Reflex::PRIVATE)
  .AddDataMember(type_15882, Reflex::Literal("m_isParFixed"), OffsetOf(__shadow__::__TReconInput, m_isParFixed), ::Reflex::PRIVATE)
  .AddDataMember(type_15882, Reflex::Literal("m_isParLowLimited"), OffsetOf(__shadow__::__TReconInput, m_isParLowLimited), ::Reflex::PRIVATE)
  .AddDataMember(type_15882, Reflex::Literal("m_isParHighLimited"), OffsetOf(__shadow__::__TReconInput, m_isParHighLimited), ::Reflex::PRIVATE)
  .AddDataMember(type_15883, Reflex::Literal("m_parLowLimit"), OffsetOf(__shadow__::__TReconInput, m_parLowLimit), ::Reflex::PRIVATE)
  .AddDataMember(type_15883, Reflex::Literal("m_parHighLimit"), OffsetOf(__shadow__::__TReconInput, m_parHighLimit), ::Reflex::PRIVATE)
  .AddDataMember(type_402, Reflex::Literal("m_fitObject"), OffsetOf(__shadow__::__TReconInput, m_fitObject), ::Reflex::PRIVATE)
  .AddDataMember(type_1016, Reflex::Literal("m_fitLikelihoodMode"), OffsetOf(__shadow__::__TReconInput, m_fitLikelihoodMode), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TReconInput -------------------
void __TReconInput_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247, type_150), Reflex::Literal("getParVal"), method_4842, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150, type_247), Reflex::Literal("setParVal"), method_4843, 0, "id;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_150), Reflex::Literal("isParFixed"), method_4844, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150, type_150), Reflex::Literal("setParFixed"), method_4845, 0, "id;fix=1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_150), Reflex::Literal("isParLowLimited"), method_4846, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150, type_150), Reflex::Literal("setParLowLimited"), method_4847, 0, "id;limit=1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247, type_150), Reflex::Literal("getParLowLimit"), method_4848, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150, type_247), Reflex::Literal("setParLowLimit"), method_4849, 0, "id;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_150), Reflex::Literal("isParHighLimited"), method_4850, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150, type_150), Reflex::Literal("setParHighLimited"), method_4851, 0, "id;limit=1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247, type_150), Reflex::Literal("getParHighLimit"), method_4852, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150, type_247), Reflex::Literal("setParHighLimit"), method_4853, 0, "id;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_150), Reflex::Literal("isParBothLimited"), method_4854, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_402), Reflex::Literal("getFitObject"), method_4855, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016), Reflex::Literal("getFitLikelihoodMode"), method_4856, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Print"), method_4857, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_4858, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_4859, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_4860, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_4861, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_4862, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_4863, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_4864, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_4865, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_4866, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_4867, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_4868, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_4869, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TEventMarkerDriver -------------------------------
static  void operator_4922( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TEventMarkerDriver*)o)->operator=)(*(const ::TEventMarkerDriver*)arg[0]);
  else   (((::TEventMarkerDriver*)o)->operator=)(*(const ::TEventMarkerDriver*)arg[0]);
}

static void constructor_4923( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TEventMarkerDriver(*(const ::TEventMarkerDriver*)arg[0]);
  else ::new(mem) ::TEventMarkerDriver(*(const ::TEventMarkerDriver*)arg[0]);
}

static void constructor_4924( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TEventMarkerDriver();
  else ::new(mem) ::TEventMarkerDriver();
}

static void destructor_4925(void*, void * o, const std::vector<void*>&, void *) {
((::TEventMarkerDriver*)o)->::TEventMarkerDriver::~TEventMarkerDriver();
}
static  void method_4926( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TEventMarkerDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TEventMarkerDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_4927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TEventMarkerDriver*)o)->getInterval)());
  else   (((const ::TEventMarkerDriver*)o)->getInterval)();
}

static  void method_4928( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEventMarkerDriver*)o)->setInterval)(*(int*)arg[0]);
}

static  void method_4929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEventMarkerDriver*)o)->Class)());
  else   (((::TEventMarkerDriver*)o)->Class)();
}

static  void method_4930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEventMarkerDriver*)o)->Class_Name)());
  else   (((::TEventMarkerDriver*)o)->Class_Name)();
}

static  void method_4931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TEventMarkerDriver*)o)->Class_Version)());
  else   (((::TEventMarkerDriver*)o)->Class_Version)();
}

static  void method_4932( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TEventMarkerDriver*)o)->Dictionary)();
}

static  void method_4933( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TEventMarkerDriver*)o)->IsA)());
  else   (((const ::TEventMarkerDriver*)o)->IsA)();
}

static  void method_4934( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEventMarkerDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4935( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEventMarkerDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4936( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEventMarkerDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEventMarkerDriver*)o)->DeclFileName)());
  else   (((::TEventMarkerDriver*)o)->DeclFileName)();
}

static  void method_4938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TEventMarkerDriver*)o)->ImplFileLine)());
  else   (((::TEventMarkerDriver*)o)->ImplFileLine)();
}

static  void method_4939( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEventMarkerDriver*)o)->ImplFileName)());
  else   (((::TEventMarkerDriver*)o)->ImplFileName)();
}

static  void method_4940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TEventMarkerDriver*)o)->DeclFileLine)());
  else   (((::TEventMarkerDriver*)o)->DeclFileLine)();
}

static void method_newdel_587( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TEventMarkerDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TEventMarkerDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TEventMarkerDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TEventMarkerDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TEventMarkerDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TEventMarkerDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TEventMarkerDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TEventMarkerDriver -------------------------------
void __TEventMarkerDriver_db_datamem(Reflex::Class*);
void __TEventMarkerDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TEventMarkerDriver_datamem_bld(&__TEventMarkerDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TEventMarkerDriver_funcmem_bld(&__TEventMarkerDriver_db_funcmem);
void __TEventMarkerDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TEventMarkerDriver"), typeid(::TEventMarkerDriver), sizeof(::TEventMarkerDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TEventMarkerDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2618, ::Reflex::BaseOffset< ::TEventMarkerDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15896, type_15897), Reflex::Literal("operator="), operator_4922, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15897), Reflex::Literal("TEventMarkerDriver"), constructor_4923, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TEventMarkerDriver"), constructor_4924, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TEventMarkerDriver"), destructor_4925, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_587, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TEventMarkerDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TEventMarkerDriver_funcmem_bld);
}

//------Delayed data member builder for class TEventMarkerDriver -------------------
void __TEventMarkerDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_150, Reflex::Literal("m_interval"), OffsetOf(__shadow__::__TEventMarkerDriver, m_interval), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TEventMarkerDriver -------------------
void __TEventMarkerDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_15663), Reflex::Literal("process"), method_4926, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getInterval"), method_4927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setInterval"), method_4928, 0, "interval", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_4929, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_4930, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_4931, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_4932, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_4933, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_4934, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_4935, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_4936, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_4937, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_4938, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_4939, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_4940, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TTofpetDummyAnalysisDriver -------------------------------
static  void operator_5061( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TTofpetDummyAnalysisDriver*)o)->operator=)(*(const ::TTofpetDummyAnalysisDriver*)arg[0]);
  else   (((::TTofpetDummyAnalysisDriver*)o)->operator=)(*(const ::TTofpetDummyAnalysisDriver*)arg[0]);
}

static void constructor_5062( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetDummyAnalysisDriver(*(const ::TTofpetDummyAnalysisDriver*)arg[0]);
  else ::new(mem) ::TTofpetDummyAnalysisDriver(*(const ::TTofpetDummyAnalysisDriver*)arg[0]);
}

static void constructor_5063( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetDummyAnalysisDriver();
  else ::new(mem) ::TTofpetDummyAnalysisDriver();
}

static void destructor_5064(void*, void * o, const std::vector<void*>&, void *) {
((::TTofpetDummyAnalysisDriver*)o)->::TTofpetDummyAnalysisDriver::~TTofpetDummyAnalysisDriver();
}
static  void method_5065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetDummyAnalysisDriver*)o)->startOfData)());
  else   (((::TTofpetDummyAnalysisDriver*)o)->startOfData)();
}

static  void method_5066( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetDummyAnalysisDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TTofpetDummyAnalysisDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_5067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetDummyAnalysisDriver*)o)->end)());
  else   (((::TTofpetDummyAnalysisDriver*)o)->end)();
}

static  void method_5068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetDummyAnalysisDriver*)o)->Class)());
  else   (((::TTofpetDummyAnalysisDriver*)o)->Class)();
}

static  void method_5069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetDummyAnalysisDriver*)o)->Class_Name)());
  else   (((::TTofpetDummyAnalysisDriver*)o)->Class_Name)();
}

static  void method_5070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TTofpetDummyAnalysisDriver*)o)->Class_Version)());
  else   (((::TTofpetDummyAnalysisDriver*)o)->Class_Version)();
}

static  void method_5071( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetDummyAnalysisDriver*)o)->Dictionary)();
}

static  void method_5072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetDummyAnalysisDriver*)o)->IsA)());
  else   (((const ::TTofpetDummyAnalysisDriver*)o)->IsA)();
}

static  void method_5073( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetDummyAnalysisDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5074( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetDummyAnalysisDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5075( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetDummyAnalysisDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetDummyAnalysisDriver*)o)->DeclFileName)());
  else   (((::TTofpetDummyAnalysisDriver*)o)->DeclFileName)();
}

static  void method_5077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetDummyAnalysisDriver*)o)->ImplFileLine)());
  else   (((::TTofpetDummyAnalysisDriver*)o)->ImplFileLine)();
}

static  void method_5078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetDummyAnalysisDriver*)o)->ImplFileName)());
  else   (((::TTofpetDummyAnalysisDriver*)o)->ImplFileName)();
}

static  void method_5079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetDummyAnalysisDriver*)o)->DeclFileLine)());
  else   (((::TTofpetDummyAnalysisDriver*)o)->DeclFileLine)();
}

static void method_newdel_742( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TTofpetDummyAnalysisDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TTofpetDummyAnalysisDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TTofpetDummyAnalysisDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TTofpetDummyAnalysisDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TTofpetDummyAnalysisDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TTofpetDummyAnalysisDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TTofpetDummyAnalysisDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TTofpetDummyAnalysisDriver -------------------------------
void __TTofpetDummyAnalysisDriver_db_datamem(Reflex::Class*);
void __TTofpetDummyAnalysisDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TTofpetDummyAnalysisDriver_datamem_bld(&__TTofpetDummyAnalysisDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TTofpetDummyAnalysisDriver_funcmem_bld(&__TTofpetDummyAnalysisDriver_db_funcmem);
void __TTofpetDummyAnalysisDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TTofpetDummyAnalysisDriver"), typeid(::TTofpetDummyAnalysisDriver), sizeof(::TTofpetDummyAnalysisDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TTofpetDummyAnalysisDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2618, ::Reflex::BaseOffset< ::TTofpetDummyAnalysisDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15932, type_15933), Reflex::Literal("operator="), operator_5061, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15933), Reflex::Literal("TTofpetDummyAnalysisDriver"), constructor_5062, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TTofpetDummyAnalysisDriver"), constructor_5063, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TTofpetDummyAnalysisDriver"), destructor_5064, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_742, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TTofpetDummyAnalysisDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TTofpetDummyAnalysisDriver_funcmem_bld);
}

//------Delayed data member builder for class TTofpetDummyAnalysisDriver -------------------
void __TTofpetDummyAnalysisDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_15929, Reflex::Literal("hMultiplicity0"), OffsetOf(__shadow__::__TTofpetDummyAnalysisDriver, hMultiplicity0), ::Reflex::PRIVATE)
  .AddDataMember(type_15930, Reflex::Literal("hMultiplicity1"), OffsetOf(__shadow__::__TTofpetDummyAnalysisDriver, hMultiplicity1), ::Reflex::PRIVATE)
  .AddDataMember(type_15929, Reflex::Literal("hMultiplicity2"), OffsetOf(__shadow__::__TTofpetDummyAnalysisDriver, hMultiplicity2), ::Reflex::PRIVATE)
  .AddDataMember(type_15769, Reflex::Literal("hMultiplicityAverage"), OffsetOf(__shadow__::__TTofpetDummyAnalysisDriver, hMultiplicityAverage), ::Reflex::PRIVATE)
  .AddDataMember(type_15930, Reflex::Literal("hToT0"), OffsetOf(__shadow__::__TTofpetDummyAnalysisDriver, hToT0), ::Reflex::PRIVATE)
  .AddDataMember(type_15930, Reflex::Literal("hToT1"), OffsetOf(__shadow__::__TTofpetDummyAnalysisDriver, hToT1), ::Reflex::PRIVATE)
  .AddDataMember(type_15930, Reflex::Literal("hToTCh"), OffsetOf(__shadow__::__TTofpetDummyAnalysisDriver, hToTCh), ::Reflex::PRIVATE)
  .AddDataMember(type_15931, Reflex::Literal("m_TofpetRun"), OffsetOf(__shadow__::__TTofpetDummyAnalysisDriver, m_TofpetRun), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_Nsteps"), OffsetOf(__shadow__::__TTofpetDummyAnalysisDriver, m_Nsteps), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TTofpetDummyAnalysisDriver -------------------
void __TTofpetDummyAnalysisDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("startOfData"), method_5065, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_15663), Reflex::Literal("process"), method_5066, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("end"), method_5067, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_5068, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_5069, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_5070, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_5071, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_5072, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_5073, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_5074, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_5075, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_5076, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_5077, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_5078, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_5079, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TChargeAnalysisPoissonDriver -------------------------------
static void constructor_5167( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TChargeAnalysisPoissonDriver();
  else ::new(mem) ::TChargeAnalysisPoissonDriver();
}

static void destructor_5168(void*, void * o, const std::vector<void*>&, void *) {
((::TChargeAnalysisPoissonDriver*)o)->::TChargeAnalysisPoissonDriver::~TChargeAnalysisPoissonDriver();
}
static  void method_5169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TChargeAnalysisPoissonDriver*)o)->start)());
  else   (((::TChargeAnalysisPoissonDriver*)o)->start)();
}

static  void method_5170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TChargeAnalysisPoissonDriver*)o)->startOfData)());
  else   (((::TChargeAnalysisPoissonDriver*)o)->startOfData)();
}

static  void method_5171( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TChargeAnalysisPoissonDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TChargeAnalysisPoissonDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_5172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TChargeAnalysisPoissonDriver*)o)->end)());
  else   (((::TChargeAnalysisPoissonDriver*)o)->end)();
}

static  void method_5173( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TChargeAnalysisPoissonDriver*)o)->setWriteOutFileName)((const char*)arg[0]);
}

static  void method_5174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TChargeAnalysisPoissonDriver*)o)->getEventsProduced)());
  else   (((const ::TChargeAnalysisPoissonDriver*)o)->getEventsProduced)();
}

static  void method_5175( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TChargeAnalysisPoissonDriver*)o)->setEventsProduced)(*(int*)arg[0]);
}

static  void method_5176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TChargeAnalysisPoissonDriver*)o)->Class)());
  else   (((::TChargeAnalysisPoissonDriver*)o)->Class)();
}

static  void method_5177( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TChargeAnalysisPoissonDriver*)o)->Class_Name)());
  else   (((::TChargeAnalysisPoissonDriver*)o)->Class_Name)();
}

static  void method_5178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TChargeAnalysisPoissonDriver*)o)->Class_Version)());
  else   (((::TChargeAnalysisPoissonDriver*)o)->Class_Version)();
}

static  void method_5179( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TChargeAnalysisPoissonDriver*)o)->Dictionary)();
}

static  void method_5180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TChargeAnalysisPoissonDriver*)o)->IsA)());
  else   (((const ::TChargeAnalysisPoissonDriver*)o)->IsA)();
}

static  void method_5181( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TChargeAnalysisPoissonDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5182( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TChargeAnalysisPoissonDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5183( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TChargeAnalysisPoissonDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TChargeAnalysisPoissonDriver*)o)->DeclFileName)());
  else   (((::TChargeAnalysisPoissonDriver*)o)->DeclFileName)();
}

static  void method_5185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TChargeAnalysisPoissonDriver*)o)->ImplFileLine)());
  else   (((::TChargeAnalysisPoissonDriver*)o)->ImplFileLine)();
}

static  void method_5186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TChargeAnalysisPoissonDriver*)o)->ImplFileName)());
  else   (((::TChargeAnalysisPoissonDriver*)o)->ImplFileName)();
}

static  void method_5187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TChargeAnalysisPoissonDriver*)o)->DeclFileLine)());
  else   (((::TChargeAnalysisPoissonDriver*)o)->DeclFileLine)();
}

static void method_newdel_835( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TChargeAnalysisPoissonDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TChargeAnalysisPoissonDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TChargeAnalysisPoissonDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TChargeAnalysisPoissonDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TChargeAnalysisPoissonDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TChargeAnalysisPoissonDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TChargeAnalysisPoissonDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TChargeAnalysisPoissonDriver -------------------------------
void __TChargeAnalysisPoissonDriver_db_datamem(Reflex::Class*);
void __TChargeAnalysisPoissonDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TChargeAnalysisPoissonDriver_datamem_bld(&__TChargeAnalysisPoissonDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TChargeAnalysisPoissonDriver_funcmem_bld(&__TChargeAnalysisPoissonDriver_db_funcmem);
void __TChargeAnalysisPoissonDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TChargeAnalysisPoissonDriver"), typeid(::TChargeAnalysisPoissonDriver), sizeof(::TChargeAnalysisPoissonDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TChargeAnalysisPoissonDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2618, ::Reflex::BaseOffset< ::TChargeAnalysisPoissonDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TChargeAnalysisPoissonDriver"), constructor_5167, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TChargeAnalysisPoissonDriver"), destructor_5168, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_835, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TChargeAnalysisPoissonDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TChargeAnalysisPoissonDriver_funcmem_bld);
}

//------Delayed data member builder for class TChargeAnalysisPoissonDriver -------------------
void __TChargeAnalysisPoissonDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_150, Reflex::Literal("m_nPixels"), OffsetOf(__shadow__::__TChargeAnalysisPoissonDriver, m_nPixels), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_nDetectors"), OffsetOf(__shadow__::__TChargeAnalysisPoissonDriver, m_nDetectors), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_eventsProduced"), OffsetOf(__shadow__::__TChargeAnalysisPoissonDriver, m_eventsProduced), ::Reflex::PRIVATE)
  .AddDataMember(type_2955, Reflex::Literal("m_writeOutFileName"), OffsetOf(__shadow__::__TChargeAnalysisPoissonDriver, m_writeOutFileName), ::Reflex::PRIVATE)
  .AddDataMember(type_1376, Reflex::Literal("m_writeOutFile"), OffsetOf(__shadow__::__TChargeAnalysisPoissonDriver, m_writeOutFile), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_2918, Reflex::Literal("m_Q"), OffsetOf(__shadow__::__TChargeAnalysisPoissonDriver, m_Q), ::Reflex::PRIVATE)
  .AddDataMember(type_15660, Reflex::Literal("hPixels2D"), OffsetOf(__shadow__::__TChargeAnalysisPoissonDriver, hPixels2D), ::Reflex::PRIVATE)
  .AddDataMember(type_15661, Reflex::Literal("hPixelsMC"), OffsetOf(__shadow__::__TChargeAnalysisPoissonDriver, hPixelsMC), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TChargeAnalysisPoissonDriver -------------------
void __TChargeAnalysisPoissonDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("start"), method_5169, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("startOfData"), method_5170, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_15663), Reflex::Literal("process"), method_5171, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("end"), method_5172, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_3438), Reflex::Literal("setWriteOutFileName"), method_5173, 0, "fname", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getEventsProduced"), method_5174, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setEventsProduced"), method_5175, 0, "eventsProduced", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_5176, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_5177, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_5178, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_5179, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_5180, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_5181, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_5182, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_5183, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_5184, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_5185, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_5186, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_5187, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TRootSaveDriver -------------------------------
static  void operator_6342( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TRootSaveDriver*)o)->operator=)(*(const ::TRootSaveDriver*)arg[0]);
  else   (((::TRootSaveDriver*)o)->operator=)(*(const ::TRootSaveDriver*)arg[0]);
}

static void constructor_6343( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TRootSaveDriver(*(const ::TRootSaveDriver*)arg[0]);
  else ::new(mem) ::TRootSaveDriver(*(const ::TRootSaveDriver*)arg[0]);
}

static void constructor_6344( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TRootSaveDriver();
  else ::new(mem) ::TRootSaveDriver();
}

static void destructor_6345(void*, void * o, const std::vector<void*>&, void *) {
((::TRootSaveDriver*)o)->::TRootSaveDriver::~TRootSaveDriver();
}
static  void method_6346( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TRootSaveDriver*)o)->setOutFileName)((const char*)arg[0]);
}

static  void method_6347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TRootSaveDriver*)o)->end)());
  else   (((::TRootSaveDriver*)o)->end)();
}

static  void method_6348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TRootSaveDriver*)o)->Class)());
  else   (((::TRootSaveDriver*)o)->Class)();
}

static  void method_6349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TRootSaveDriver*)o)->Class_Name)());
  else   (((::TRootSaveDriver*)o)->Class_Name)();
}

static  void method_6350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TRootSaveDriver*)o)->Class_Version)());
  else   (((::TRootSaveDriver*)o)->Class_Version)();
}

static  void method_6351( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TRootSaveDriver*)o)->Dictionary)();
}

static  void method_6352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TRootSaveDriver*)o)->IsA)());
  else   (((const ::TRootSaveDriver*)o)->IsA)();
}

static  void method_6353( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TRootSaveDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_6354( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TRootSaveDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_6355( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TRootSaveDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_6356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TRootSaveDriver*)o)->DeclFileName)());
  else   (((::TRootSaveDriver*)o)->DeclFileName)();
}

static  void method_6357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TRootSaveDriver*)o)->ImplFileLine)());
  else   (((::TRootSaveDriver*)o)->ImplFileLine)();
}

static  void method_6358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TRootSaveDriver*)o)->ImplFileName)());
  else   (((::TRootSaveDriver*)o)->ImplFileName)();
}

static  void method_6359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TRootSaveDriver*)o)->DeclFileLine)());
  else   (((::TRootSaveDriver*)o)->DeclFileLine)();
}

static void method_newdel_1138( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TRootSaveDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TRootSaveDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TRootSaveDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TRootSaveDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TRootSaveDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TRootSaveDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TRootSaveDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TRootSaveDriver -------------------------------
void __TRootSaveDriver_db_datamem(Reflex::Class*);
void __TRootSaveDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TRootSaveDriver_datamem_bld(&__TRootSaveDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TRootSaveDriver_funcmem_bld(&__TRootSaveDriver_db_funcmem);
void __TRootSaveDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TRootSaveDriver"), typeid(::TRootSaveDriver), sizeof(::TRootSaveDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TRootSaveDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2618, ::Reflex::BaseOffset< ::TRootSaveDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16609, type_16610), Reflex::Literal("operator="), operator_6342, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16610), Reflex::Literal("TRootSaveDriver"), constructor_6343, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TRootSaveDriver"), constructor_6344, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TRootSaveDriver"), destructor_6345, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1138, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TRootSaveDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TRootSaveDriver_funcmem_bld);
}

//------Delayed data member builder for class TRootSaveDriver -------------------
void __TRootSaveDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2955, Reflex::Literal("m_fname"), OffsetOf(__shadow__::__TRootSaveDriver, m_fname), ::Reflex::PRIVATE)
  .AddDataMember(type_15958, Reflex::Literal("m_fout"), OffsetOf(__shadow__::__TRootSaveDriver, m_fout), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TRootSaveDriver -------------------
void __TRootSaveDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_3438), Reflex::Literal("setOutFileName"), method_6346, 0, "m_fname", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("end"), method_6347, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_6348, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_6349, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_6350, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_6351, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_6352, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_6353, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_6354, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_6355, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_6356, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_6357, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_6358, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_6359, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TLikelihoodCalculatorIdeal -------------------------------
static  void operator_6483( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TLikelihoodCalculatorIdeal*)o)->operator=)(*(const ::TLikelihoodCalculatorIdeal*)arg[0]);
  else   (((::TLikelihoodCalculatorIdeal*)o)->operator=)(*(const ::TLikelihoodCalculatorIdeal*)arg[0]);
}

static void constructor_6484( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TLikelihoodCalculatorIdeal(*(const ::TLikelihoodCalculatorIdeal*)arg[0]);
  else ::new(mem) ::TLikelihoodCalculatorIdeal(*(const ::TLikelihoodCalculatorIdeal*)arg[0]);
}

static void constructor_6485( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TLikelihoodCalculatorIdeal();
  else ::new(mem) ::TLikelihoodCalculatorIdeal();
}

static void destructor_6486(void*, void * o, const std::vector<void*>&, void *) {
((::TLikelihoodCalculatorIdeal*)o)->::TLikelihoodCalculatorIdeal::~TLikelihoodCalculatorIdeal();
}
static  void method_6487( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodCalculatorIdeal*)o)->CalculateLikelihood)((const double*)arg[0]));
  else   (((const ::TLikelihoodCalculatorIdeal*)o)->CalculateLikelihood)((const double*)arg[0]);
}

static  void method_6488( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodCalculatorIdeal*)o)->PointLikelihoodCharge)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]));
  else   (((const ::TLikelihoodCalculatorIdeal*)o)->PointLikelihoodCharge)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]);
}

static  void method_6489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodCalculatorIdeal*)o)->PointLikelihoodTime)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]));
  else   (((const ::TLikelihoodCalculatorIdeal*)o)->PointLikelihoodTime)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]);
}

static  void method_6490( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodCalculatorIdeal*)o)->TrackLikelihoodCharge)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]));
  else   (((const ::TLikelihoodCalculatorIdeal*)o)->TrackLikelihoodCharge)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]);
}

static  void method_6491( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodCalculatorIdeal*)o)->TrackLikelihoodTime)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]));
  else   (((const ::TLikelihoodCalculatorIdeal*)o)->TrackLikelihoodTime)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]);
}

static  void method_6492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodCalculatorIdeal*)o)->Class)());
  else   (((::TLikelihoodCalculatorIdeal*)o)->Class)();
}

static  void method_6493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodCalculatorIdeal*)o)->Class_Name)());
  else   (((::TLikelihoodCalculatorIdeal*)o)->Class_Name)();
}

static  void method_6494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TLikelihoodCalculatorIdeal*)o)->Class_Version)());
  else   (((::TLikelihoodCalculatorIdeal*)o)->Class_Version)();
}

static  void method_6495( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TLikelihoodCalculatorIdeal*)o)->Dictionary)();
}

static  void method_6496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TLikelihoodCalculatorIdeal*)o)->IsA)());
  else   (((const ::TLikelihoodCalculatorIdeal*)o)->IsA)();
}

static  void method_6497( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodCalculatorIdeal*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_6498( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodCalculatorIdeal*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_6499( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodCalculatorIdeal*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_6500( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodCalculatorIdeal*)o)->DeclFileName)());
  else   (((::TLikelihoodCalculatorIdeal*)o)->DeclFileName)();
}

static  void method_6501( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodCalculatorIdeal*)o)->ImplFileLine)());
  else   (((::TLikelihoodCalculatorIdeal*)o)->ImplFileLine)();
}

static  void method_6502( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodCalculatorIdeal*)o)->ImplFileName)());
  else   (((::TLikelihoodCalculatorIdeal*)o)->ImplFileName)();
}

static  void method_6503( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodCalculatorIdeal*)o)->DeclFileLine)());
  else   (((::TLikelihoodCalculatorIdeal*)o)->DeclFileLine)();
}

static void method_newdel_1170( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TLikelihoodCalculatorIdeal >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TLikelihoodCalculatorIdeal >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TLikelihoodCalculatorIdeal >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TLikelihoodCalculatorIdeal >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TLikelihoodCalculatorIdeal >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x18( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TLikelihoodCalculator")), ::Reflex::BaseOffset< ::TLikelihoodCalculatorIdeal,::TLikelihoodCalculator >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TLikelihoodCalculatorIdeal,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TLikelihoodCalculatorIdeal -------------------------------
void __TLikelihoodCalculatorIdeal_db_datamem(Reflex::Class*);
void __TLikelihoodCalculatorIdeal_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TLikelihoodCalculatorIdeal_datamem_bld(&__TLikelihoodCalculatorIdeal_db_datamem);
Reflex::GenreflexMemberBuilder __TLikelihoodCalculatorIdeal_funcmem_bld(&__TLikelihoodCalculatorIdeal_db_funcmem);
void __TLikelihoodCalculatorIdeal_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TLikelihoodCalculatorIdeal"), typeid(::TLikelihoodCalculatorIdeal), sizeof(::TLikelihoodCalculatorIdeal), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TLikelihoodCalculatorIdeal::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2679, ::Reflex::BaseOffset< ::TLikelihoodCalculatorIdeal, ::TLikelihoodCalculator >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16615, type_16616), Reflex::Literal("operator="), operator_6483, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16616), Reflex::Literal("TLikelihoodCalculatorIdeal"), constructor_6484, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TLikelihoodCalculatorIdeal"), constructor_6485, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TLikelihoodCalculatorIdeal"), destructor_6486, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1170, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x18, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__TLikelihoodCalculatorIdeal_funcmem_bld);
}

//------Delayed data member builder for class TLikelihoodCalculatorIdeal -------------------
void __TLikelihoodCalculatorIdeal_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class TLikelihoodCalculatorIdeal -------------------
void __TLikelihoodCalculatorIdeal_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247, type_12392), Reflex::Literal("CalculateLikelihood"), method_6487, 0, "x", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247, type_150, type_150, type_150, type_12392), Reflex::Literal("PointLikelihoodCharge"), method_6488, 0, "iface;idetector;id;para", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247, type_150, type_150, type_150, type_12392), Reflex::Literal("PointLikelihoodTime"), method_6489, 0, "iface;idetector;id;para", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247, type_150, type_150, type_150, type_12392), Reflex::Literal("TrackLikelihoodCharge"), method_6490, 0, "iface;idetector;id;para", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247, type_150, type_150, type_150, type_12392), Reflex::Literal("TrackLikelihoodTime"), method_6491, 0, "iface;idetector;id;para", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_6492, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_6493, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_6494, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_6495, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_6496, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_6497, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_6498, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_6499, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_6500, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_6501, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_6502, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_6503, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TMatrixWriterDriver -------------------------------
static  void operator_6798( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TMatrixWriterDriver*)o)->operator=)(*(const ::TMatrixWriterDriver*)arg[0]);
  else   (((::TMatrixWriterDriver*)o)->operator=)(*(const ::TMatrixWriterDriver*)arg[0]);
}

static void constructor_6799( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMatrixWriterDriver(*(const ::TMatrixWriterDriver*)arg[0]);
  else ::new(mem) ::TMatrixWriterDriver(*(const ::TMatrixWriterDriver*)arg[0]);
}

static void constructor_6800( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMatrixWriterDriver();
  else ::new(mem) ::TMatrixWriterDriver();
}

static void destructor_6801(void*, void * o, const std::vector<void*>&, void *) {
((::TMatrixWriterDriver*)o)->::TMatrixWriterDriver::~TMatrixWriterDriver();
}
static  void method_6802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixWriterDriver*)o)->start)());
  else   (((::TMatrixWriterDriver*)o)->start)();
}

static  void method_6803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixWriterDriver*)o)->startOfData)());
  else   (((::TMatrixWriterDriver*)o)->startOfData)();
}

static  void method_6804( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixWriterDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TMatrixWriterDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_6805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixWriterDriver*)o)->end)());
  else   (((::TMatrixWriterDriver*)o)->end)();
}

static  void method_6806( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixWriterDriver*)o)->setVoxelID)(*(int*)arg[0]);
}

static  void method_6807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixWriterDriver*)o)->Class)());
  else   (((::TMatrixWriterDriver*)o)->Class)();
}

static  void method_6808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixWriterDriver*)o)->Class_Name)());
  else   (((::TMatrixWriterDriver*)o)->Class_Name)();
}

static  void method_6809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TMatrixWriterDriver*)o)->Class_Version)());
  else   (((::TMatrixWriterDriver*)o)->Class_Version)();
}

static  void method_6810( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TMatrixWriterDriver*)o)->Dictionary)();
}

static  void method_6811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMatrixWriterDriver*)o)->IsA)());
  else   (((const ::TMatrixWriterDriver*)o)->IsA)();
}

static  void method_6812( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixWriterDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_6813( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixWriterDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_6814( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixWriterDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_6815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixWriterDriver*)o)->DeclFileName)());
  else   (((::TMatrixWriterDriver*)o)->DeclFileName)();
}

static  void method_6816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixWriterDriver*)o)->ImplFileLine)());
  else   (((::TMatrixWriterDriver*)o)->ImplFileLine)();
}

static  void method_6817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixWriterDriver*)o)->ImplFileName)());
  else   (((::TMatrixWriterDriver*)o)->ImplFileName)();
}

static  void method_6818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixWriterDriver*)o)->DeclFileLine)());
  else   (((::TMatrixWriterDriver*)o)->DeclFileLine)();
}

static void method_newdel_1226( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TMatrixWriterDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TMatrixWriterDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TMatrixWriterDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TMatrixWriterDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TMatrixWriterDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x20( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TMatrixWriterDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TMatrixWriterDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TMatrixWriterDriver -------------------------------
void __TMatrixWriterDriver_db_datamem(Reflex::Class*);
void __TMatrixWriterDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TMatrixWriterDriver_datamem_bld(&__TMatrixWriterDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TMatrixWriterDriver_funcmem_bld(&__TMatrixWriterDriver_db_funcmem);
void __TMatrixWriterDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TMatrixWriterDriver"), typeid(::TMatrixWriterDriver), sizeof(::TMatrixWriterDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TMatrixWriterDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2618, ::Reflex::BaseOffset< ::TMatrixWriterDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16659, type_16660), Reflex::Literal("operator="), operator_6798, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16660), Reflex::Literal("TMatrixWriterDriver"), constructor_6799, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TMatrixWriterDriver"), constructor_6800, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TMatrixWriterDriver"), destructor_6801, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1226, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TMatrixWriterDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TMatrixWriterDriver_funcmem_bld);
}

//------Delayed data member builder for class TMatrixWriterDriver -------------------
void __TMatrixWriterDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_15661, Reflex::Literal("hPixels"), OffsetOf(__shadow__::__TMatrixWriterDriver, hPixels), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_nPixels"), OffsetOf(__shadow__::__TMatrixWriterDriver, m_nPixels), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_nDetectors"), OffsetOf(__shadow__::__TMatrixWriterDriver, m_nDetectors), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_voxelID"), OffsetOf(__shadow__::__TMatrixWriterDriver, m_voxelID), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TMatrixWriterDriver -------------------
void __TMatrixWriterDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("start"), method_6802, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("startOfData"), method_6803, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_15663), Reflex::Literal("process"), method_6804, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("end"), method_6805, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setVoxelID"), method_6806, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_6807, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_6808, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_6809, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_6810, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_6811, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_6812, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_6813, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_6814, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_6815, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_6816, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_6817, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_6818, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TTofpetTimeAnalysisDriver -------------------------------
static  void operator_6839( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TTofpetTimeAnalysisDriver*)o)->operator=)(*(const ::TTofpetTimeAnalysisDriver*)arg[0]);
  else   (((::TTofpetTimeAnalysisDriver*)o)->operator=)(*(const ::TTofpetTimeAnalysisDriver*)arg[0]);
}

static void constructor_6840( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetTimeAnalysisDriver(*(const ::TTofpetTimeAnalysisDriver*)arg[0]);
  else ::new(mem) ::TTofpetTimeAnalysisDriver(*(const ::TTofpetTimeAnalysisDriver*)arg[0]);
}

static void constructor_6841( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetTimeAnalysisDriver();
  else ::new(mem) ::TTofpetTimeAnalysisDriver();
}

static  void method_6842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetTimeAnalysisDriver*)o)->startOfData)());
  else   (((::TTofpetTimeAnalysisDriver*)o)->startOfData)();
}

static  void method_6843( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetTimeAnalysisDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TTofpetTimeAnalysisDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_6844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetTimeAnalysisDriver*)o)->end)());
  else   (((::TTofpetTimeAnalysisDriver*)o)->end)();
}

static void destructor_6845(void*, void * o, const std::vector<void*>&, void *) {
((::TTofpetTimeAnalysisDriver*)o)->::TTofpetTimeAnalysisDriver::~TTofpetTimeAnalysisDriver();
}
static  void method_6846( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetTimeAnalysisDriver*)o)->setCh1)(*(int*)arg[0]);
}

static  void method_6847( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetTimeAnalysisDriver*)o)->setCh2)(*(int*)arg[0]);
}

static  void method_6848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetTimeAnalysisDriver*)o)->Class)());
  else   (((::TTofpetTimeAnalysisDriver*)o)->Class)();
}

static  void method_6849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetTimeAnalysisDriver*)o)->Class_Name)());
  else   (((::TTofpetTimeAnalysisDriver*)o)->Class_Name)();
}

static  void method_6850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TTofpetTimeAnalysisDriver*)o)->Class_Version)());
  else   (((::TTofpetTimeAnalysisDriver*)o)->Class_Version)();
}

static  void method_6851( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetTimeAnalysisDriver*)o)->Dictionary)();
}

static  void method_6852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetTimeAnalysisDriver*)o)->IsA)());
  else   (((const ::TTofpetTimeAnalysisDriver*)o)->IsA)();
}

static  void method_6853( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetTimeAnalysisDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_6854( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetTimeAnalysisDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_6855( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetTimeAnalysisDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_6856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetTimeAnalysisDriver*)o)->DeclFileName)());
  else   (((::TTofpetTimeAnalysisDriver*)o)->DeclFileName)();
}

static  void method_6857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetTimeAnalysisDriver*)o)->ImplFileLine)());
  else   (((::TTofpetTimeAnalysisDriver*)o)->ImplFileLine)();
}

static  void method_6858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetTimeAnalysisDriver*)o)->ImplFileName)());
  else   (((::TTofpetTimeAnalysisDriver*)o)->ImplFileName)();
}

static  void method_6859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetTimeAnalysisDriver*)o)->DeclFileLine)());
  else   (((::TTofpetTimeAnalysisDriver*)o)->DeclFileLine)();
}

static void method_newdel_1233( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TTofpetTimeAnalysisDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TTofpetTimeAnalysisDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TTofpetTimeAnalysisDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TTofpetTimeAnalysisDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TTofpetTimeAnalysisDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TTofpetTimeAnalysisDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TTofpetTimeAnalysisDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TTofpetTimeAnalysisDriver -------------------------------
void __TTofpetTimeAnalysisDriver_db_datamem(Reflex::Class*);
void __TTofpetTimeAnalysisDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TTofpetTimeAnalysisDriver_datamem_bld(&__TTofpetTimeAnalysisDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TTofpetTimeAnalysisDriver_funcmem_bld(&__TTofpetTimeAnalysisDriver_db_funcmem);
void __TTofpetTimeAnalysisDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TTofpetTimeAnalysisDriver"), typeid(::TTofpetTimeAnalysisDriver), sizeof(::TTofpetTimeAnalysisDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TTofpetTimeAnalysisDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2618, ::Reflex::BaseOffset< ::TTofpetTimeAnalysisDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16661, type_16662), Reflex::Literal("operator="), operator_6839, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16662), Reflex::Literal("TTofpetTimeAnalysisDriver"), constructor_6840, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TTofpetTimeAnalysisDriver"), constructor_6841, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TTofpetTimeAnalysisDriver"), destructor_6845, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1233, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TTofpetTimeAnalysisDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TTofpetTimeAnalysisDriver_funcmem_bld);
}

//------Delayed data member builder for class TTofpetTimeAnalysisDriver -------------------
void __TTofpetTimeAnalysisDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_15661, Reflex::Literal("hMultiplicity0"), OffsetOf(__shadow__::__TTofpetTimeAnalysisDriver, hMultiplicity0), ::Reflex::PRIVATE)
  .AddDataMember(type_15661, Reflex::Literal("hMultiplicity1"), OffsetOf(__shadow__::__TTofpetTimeAnalysisDriver, hMultiplicity1), ::Reflex::PRIVATE)
  .AddDataMember(type_15661, Reflex::Literal("hMultiplicity2"), OffsetOf(__shadow__::__TTofpetTimeAnalysisDriver, hMultiplicity2), ::Reflex::PRIVATE)
  .AddDataMember(type_15661, Reflex::Literal("hEntries0"), OffsetOf(__shadow__::__TTofpetTimeAnalysisDriver, hEntries0), ::Reflex::PRIVATE)
  .AddDataMember(type_15661, Reflex::Literal("hEntries1"), OffsetOf(__shadow__::__TTofpetTimeAnalysisDriver, hEntries1), ::Reflex::PRIVATE)
  .AddDataMember(type_15929, Reflex::Literal("hToT0"), OffsetOf(__shadow__::__TTofpetTimeAnalysisDriver, hToT0), ::Reflex::PRIVATE)
  .AddDataMember(type_15929, Reflex::Literal("hToT1"), OffsetOf(__shadow__::__TTofpetTimeAnalysisDriver, hToT1), ::Reflex::PRIVATE)
  .AddDataMember(type_15769, Reflex::Literal("hToTch1VSch2"), OffsetOf(__shadow__::__TTofpetTimeAnalysisDriver, hToTch1VSch2), ::Reflex::PRIVATE)
  .AddDataMember(type_15661, Reflex::Literal("hDeltaT"), OffsetOf(__shadow__::__TTofpetTimeAnalysisDriver, hDeltaT), ::Reflex::PRIVATE)
  .AddDataMember(type_15931, Reflex::Literal("m_TofpetRun"), OffsetOf(__shadow__::__TTofpetTimeAnalysisDriver, m_TofpetRun), ::Reflex::PRIVATE)
  .AddDataMember(type_5840, Reflex::Literal("tout"), OffsetOf(__shadow__::__TTofpetTimeAnalysisDriver, tout), ::Reflex::PRIVATE)
  .AddDataMember(type_247, Reflex::Literal("m_Q1"), OffsetOf(__shadow__::__TTofpetTimeAnalysisDriver, m_Q1), ::Reflex::PRIVATE)
  .AddDataMember(type_247, Reflex::Literal("m_Q2"), OffsetOf(__shadow__::__TTofpetTimeAnalysisDriver, m_Q2), ::Reflex::PRIVATE)
  .AddDataMember(type_1950, Reflex::Literal("m_T1"), OffsetOf(__shadow__::__TTofpetTimeAnalysisDriver, m_T1), ::Reflex::PRIVATE)
  .AddDataMember(type_1950, Reflex::Literal("m_T2"), OffsetOf(__shadow__::__TTofpetTimeAnalysisDriver, m_T2), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_Nsteps"), OffsetOf(__shadow__::__TTofpetTimeAnalysisDriver, m_Nsteps), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_ch1"), OffsetOf(__shadow__::__TTofpetTimeAnalysisDriver, m_ch1), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_ch2"), OffsetOf(__shadow__::__TTofpetTimeAnalysisDriver, m_ch2), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TTofpetTimeAnalysisDriver -------------------
void __TTofpetTimeAnalysisDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("startOfData"), method_6842, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_15663), Reflex::Literal("process"), method_6843, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("end"), method_6844, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setCh1"), method_6846, 0, "ch1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setCh2"), method_6847, 0, "ch2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_6848, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_6849, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_6850, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_6851, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_6852, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_6853, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_6854, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_6855, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_6856, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_6857, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_6858, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_6859, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TJobManager -------------------------------
static void constructor_7499( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TJobManager();
  else ::new(mem) ::TJobManager();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TJobManager((::TTree*)arg[0]);
  else ::new(mem) ::TJobManager((::TTree*)arg[0]);
  }
}

static void destructor_7500(void*, void * o, const std::vector<void*>&, void *) {
((::TJobManager*)o)->::TJobManager::~TJobManager();
}
static  void method_7501( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::TJobManager*)o)->Version)());
  else   (((const ::TJobManager*)o)->Version)();
}

static  void method_7502( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->Begin)((::TTree*)arg[0]);
}

static  void method_7503( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->SlaveBegin)((::TTree*)arg[0]);
}

static  void method_7504( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Int_t)((((::TJobManager*)o)->GetEntry)(*(::Long64_t*)arg[0]));
    else     (((::TJobManager*)o)->GetEntry)(*(::Long64_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Int_t)((((::TJobManager*)o)->GetEntry)(*(::Long64_t*)arg[0],
      *(::Int_t*)arg[1]));
    else     (((::TJobManager*)o)->GetEntry)(*(::Long64_t*)arg[0],
      *(::Int_t*)arg[1]);
  }
}

static  void method_7505( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->SetOption)((const char*)arg[0]);
}

static  void method_7506( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->SetObject)((::TObject*)arg[0]);
}

static  void method_7507( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->SetInputList)((::TList*)arg[0]);
}

static  void method_7508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TJobManager*)o)->GetOutputList)());
  else   (((const ::TJobManager*)o)->GetOutputList)();
}

static  void method_7509( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TJobManager*)o)->SlaveTerminate)();
}

static  void method_7510( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TJobManager*)o)->Terminate)();
}

static  void method_7511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((::TJobManager*)o)->Notify)());
  else   (((::TJobManager*)o)->Notify)();
}

static  void method_7512( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->Init)((::TTree*)arg[0]);
}

static  void method_7513( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((::TJobManager*)o)->Process)(*(::Long64_t*)arg[0]));
  else   (((::TJobManager*)o)->Process)(*(::Long64_t*)arg[0]);
}

static  void method_7514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TJobManager*)o)->ClassName)());
  else   (((const ::TJobManager*)o)->ClassName)();
}

static  void method_7515( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::TJobManager*)o)->Config)();
  }
  else if ( arg.size() == 1 ) { 
    (((::TJobManager*)o)->Config)(*(::std::string*)arg[0]);
  }
}

static  void method_7516( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setVariable)(*(::std::string*)arg[0],
    *(::std::string*)arg[1]);
}

static  void method_7517( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->hasVariable)(*(::std::string*)arg[0]));
  else   (((const ::TJobManager*)o)->hasVariable)(*(::std::string*)arg[0]);
}

static  void method_7518( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::TJobManager*)o)->getVariable)(*(::std::string*)arg[0]));
  else   (((const ::TJobManager*)o)->getVariable)(*(::std::string*)arg[0]);
}

static  void method_7519( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::TJobManager*)o)->printVariables)();
}

static  void method_7520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TJobManager*)o)->getDrivers)());
  else   (((::TJobManager*)o)->getDrivers)();
}

static  void method_7521( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TJobManager*)o)->getDriver)(*(int*)arg[0]));
  else   (((::TJobManager*)o)->getDriver)(*(int*)arg[0]);
}

static  void method_7522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getEventN)());
  else   (((const ::TJobManager*)o)->getEventN)();
}

static  void method_7523( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setEventN)(*(int*)arg[0]);
}

static  void method_7524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getDoProof)());
  else   (((const ::TJobManager*)o)->getDoProof)();
}

static  void method_7525( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setDoProof)(*(int*)arg[0]);
}

static  void method_7526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getDoProofDiag)());
  else   (((const ::TJobManager*)o)->getDoProofDiag)();
}

static  void method_7527( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setDoProofDiag)(*(int*)arg[0]);
}

static  void method_7528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getNumberOfEvents)());
  else   (((const ::TJobManager*)o)->getNumberOfEvents)();
}

static  void method_7529( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setNumberOfEvents)(*(int*)arg[0]);
}

static  void method_7530( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getSkipEvents)());
  else   (((const ::TJobManager*)o)->getSkipEvents)();
}

static  void method_7531( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setSkipEvents)(*(int*)arg[0]);
}

static  void method_7532( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getVerboseLevel)());
  else   (((const ::TJobManager*)o)->getVerboseLevel)();
}

static  void method_7533( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setVerboseLevel)(*(int*)arg[0]);
}

static  void method_7534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getDryRun)());
  else   (((const ::TJobManager*)o)->getDryRun)();
}

static  void method_7535( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setDryRun)(*(int*)arg[0]);
}

static  void method_7536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getNumberOfWorkers)());
  else   (((const ::TJobManager*)o)->getNumberOfWorkers)();
}

static  void method_7537( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setNumberOfWorkers)(*(int*)arg[0]);
}

static  void method_7538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getIterationN)());
  else   (((const ::TJobManager*)o)->getIterationN)();
}

static  void method_7539( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setIterationN)(*(int*)arg[0]);
}

static  void method_7540( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TJobManager*)o)->incrementIterationN)();
}

static  void method_7541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->isLastIteration)());
  else   (((const ::TJobManager*)o)->isLastIteration)();
}

static  void method_7542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->isFirstIteration)());
  else   (((const ::TJobManager*)o)->isFirstIteration)();
}

static  void method_7543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->getNumberOfIterations)());
  else   (((const ::TJobManager*)o)->getNumberOfIterations)();
}

static  void method_7544( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setNumberOfIterations)(*(int*)arg[0]);
}

static  void method_7545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TJobManager*)o)->getDetector)());
  else   (((const ::TJobManager*)o)->getDetector)();
}

static  void method_7546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TJobManager*)o)->getDetectorUtils)());
  else   (((const ::TJobManager*)o)->getDetectorUtils)();
}

static  void method_7547( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setDetector)((::TDetector*)arg[0]);
}

static  void method_7548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->isProofCompatible)());
  else   (((const ::TJobManager*)o)->isProofCompatible)();
}

static  void method_7549( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->hasObject)((::TClass*)arg[0]));
    else     (((const ::TJobManager*)o)->hasObject)((::TClass*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (int)((((const ::TJobManager*)o)->hasObject)((::TClass*)arg[0],
      *(::std::string*)arg[1]));
    else     (((const ::TJobManager*)o)->hasObject)((::TClass*)arg[0],
      *(::std::string*)arg[1]);
  }
}

static  void method_7550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TJobManager*)o)->getObject)((::TClass*)arg[0]));
    else     (((const ::TJobManager*)o)->getObject)((::TClass*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TJobManager*)o)->getObject)((::TClass*)arg[0],
      *(::std::string*)arg[1]));
    else     (((const ::TJobManager*)o)->getObject)((::TClass*)arg[0],
      *(::std::string*)arg[1]);
  }
}

static  void method_7551( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::TJobManager*)o)->addObject)((::TObject*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::TJobManager*)o)->addObject)((::TObject*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_7552( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TJobManager*)o)->getRandomGenerator)());
  else   (((const ::TJobManager*)o)->getRandomGenerator)();
}

static  void method_7553( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->setRandomGenerator)((::TRandom3*)arg[0]);
}

static  void method_7554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TJobManager*)o)->Class)());
  else   (((::TJobManager*)o)->Class)();
}

static  void method_7555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TJobManager*)o)->Class_Name)());
  else   (((::TJobManager*)o)->Class_Name)();
}

static  void method_7556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TJobManager*)o)->Class_Version)());
  else   (((::TJobManager*)o)->Class_Version)();
}

static  void method_7557( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TJobManager*)o)->Dictionary)();
}

static  void method_7558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TJobManager*)o)->IsA)());
  else   (((const ::TJobManager*)o)->IsA)();
}

static  void method_7559( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_7560( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_7561( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TJobManager*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_7562( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TJobManager*)o)->DeclFileName)());
  else   (((::TJobManager*)o)->DeclFileName)();
}

static  void method_7563( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TJobManager*)o)->ImplFileLine)());
  else   (((::TJobManager*)o)->ImplFileLine)();
}

static  void method_7564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TJobManager*)o)->ImplFileName)());
  else   (((::TJobManager*)o)->ImplFileName)();
}

static  void method_7565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TJobManager*)o)->DeclFileLine)());
  else   (((::TJobManager*)o)->DeclFileLine)();
}

static void constructor_x23( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TJobManager();
  else ::new(mem) ::TJobManager();
}

static void method_newdel_1365( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TJobManager >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TJobManager >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TJobManager >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TJobManager >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TJobManager >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x25( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TSelector")), ::Reflex::BaseOffset< ::TJobManager,::TSelector >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TJobManager,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TJobManager -------------------------------
void __TJobManager_db_datamem(Reflex::Class*);
void __TJobManager_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TJobManager_datamem_bld(&__TJobManager_db_datamem);
Reflex::GenreflexMemberBuilder __TJobManager_funcmem_bld(&__TJobManager_db_funcmem);
void __TJobManager_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TJobManager"), typeid(::TJobManager), sizeof(::TJobManager), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TJobManager::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_413, ::Reflex::BaseOffset< ::TJobManager, ::TSelector >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5840), Reflex::Literal("TJobManager"), constructor_7499, 0, "t=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TJobManager"), destructor_7500, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TJobManager"), constructor_x23, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1365, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x25, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TJobManager_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TJobManager_funcmem_bld);
}

//------Delayed data member builder for class TJobManager -------------------
void __TJobManager_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5840, Reflex::Literal("fTree"), OffsetOf(__shadow__::__TJobManager, fTree), ::Reflex::PRIVATE)
  .AddDataMember(type_5839, Reflex::Literal("b_event"), OffsetOf(__shadow__::__TJobManager, b_event), ::Reflex::PRIVATE)
  .AddDataMember(type_15663, Reflex::Literal("m_event"), OffsetOf(__shadow__::__TJobManager, m_event), ::Reflex::PRIVATE)
  .AddDataMember(type_16739, Reflex::Literal("m_xmlHandler"), OffsetOf(__shadow__::__TJobManager, m_xmlHandler), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_16740, Reflex::Literal("m_drivers"), OffsetOf(__shadow__::__TJobManager, m_drivers), ::Reflex::PRIVATE)
  .AddDataMember(type_16741, Reflex::Literal("m_detector"), OffsetOf(__shadow__::__TJobManager, m_detector), ::Reflex::PRIVATE)
  .AddDataMember(type_16742, Reflex::Literal("m_detectorUtils"), OffsetOf(__shadow__::__TJobManager, m_detectorUtils), ::Reflex::PRIVATE)
  .AddDataMember(type_16743, Reflex::Literal("m_variables"), OffsetOf(__shadow__::__TJobManager, m_variables), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_150, Reflex::Literal("m_eventN"), OffsetOf(__shadow__::__TJobManager, m_eventN), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_doProof"), OffsetOf(__shadow__::__TJobManager, m_doProof), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_doProofDiag"), OffsetOf(__shadow__::__TJobManager, m_doProofDiag), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_skipEvents"), OffsetOf(__shadow__::__TJobManager, m_skipEvents), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_numberOfEvents"), OffsetOf(__shadow__::__TJobManager, m_numberOfEvents), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_verboseLevel"), OffsetOf(__shadow__::__TJobManager, m_verboseLevel), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_dryRun"), OffsetOf(__shadow__::__TJobManager, m_dryRun), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_numberOfWorkers"), OffsetOf(__shadow__::__TJobManager, m_numberOfWorkers), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_numberOfIterations"), OffsetOf(__shadow__::__TJobManager, m_numberOfIterations), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_iterationN"), OffsetOf(__shadow__::__TJobManager, m_iterationN), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_isProofCompatible"), OffsetOf(__shadow__::__TJobManager, m_isProofCompatible), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TJobManager -------------------
void __TJobManager_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_883), Reflex::Literal("Version"), method_7501, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_5840), Reflex::Literal("Begin"), method_7502, 0, "tree", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_5840), Reflex::Literal("SlaveBegin"), method_7503, 0, "tree", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_883, type_1951, type_883), Reflex::Literal("GetEntry"), method_7504, 0, "entry;getall=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_3438), Reflex::Literal("SetOption"), method_7505, 0, "option", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_13947), Reflex::Literal("SetObject"), method_7506, 0, "obj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15838), Reflex::Literal("SetInputList"), method_7507, 0, "input", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15838), Reflex::Literal("GetOutputList"), method_7508, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("SlaveTerminate"), method_7509, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Terminate"), method_7510, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_662), Reflex::Literal("Notify"), method_7511, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_5840), Reflex::Literal("Init"), method_7512, 0, "tree", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_662, type_1951), Reflex::Literal("Process"), method_7513, 0, "entry", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ClassName"), method_7514, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_2955), Reflex::Literal("Config"), method_7515, 0, "fname=\"reconstruction.xml\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_2955, type_2955), Reflex::Literal("setVariable"), method_7516, 0, "name;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_2955), Reflex::Literal("hasVariable"), method_7517, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2955, type_2955), Reflex::Literal("getVariable"), method_7518, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("printVariables"), method_7519, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16740), Reflex::Literal("getDrivers"), method_7520, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9059, type_150), Reflex::Literal("getDriver"), method_7521, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getEventN"), method_7522, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setEventN"), method_7523, 0, "eventN", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getDoProof"), method_7524, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setDoProof"), method_7525, 0, "doProof", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getDoProofDiag"), method_7526, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setDoProofDiag"), method_7527, 0, "doProofDiag", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getNumberOfEvents"), method_7528, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setNumberOfEvents"), method_7529, 0, "numberOfEvents", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getSkipEvents"), method_7530, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setSkipEvents"), method_7531, 0, "skipEvents", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getVerboseLevel"), method_7532, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setVerboseLevel"), method_7533, 0, "verboseLevel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getDryRun"), method_7534, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setDryRun"), method_7535, 0, "dryRun", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getNumberOfWorkers"), method_7536, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setNumberOfWorkers"), method_7537, 0, "numberOfWorkers", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getIterationN"), method_7538, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setIterationN"), method_7539, 0, "iterationN", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("incrementIterationN"), method_7540, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("isLastIteration"), method_7541, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("isFirstIteration"), method_7542, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getNumberOfIterations"), method_7543, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setNumberOfIterations"), method_7544, 0, "numberOfIterations", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16741), Reflex::Literal("getDetector"), method_7545, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16742), Reflex::Literal("getDetectorUtils"), method_7546, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_16741), Reflex::Literal("setDetector"), method_7547, 0, "detector", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("isProofCompatible"), method_7548, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_789, type_2955), Reflex::Literal("hasObject"), method_7549, 0, "theClass;name=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13947, type_789, type_2955), Reflex::Literal("getObject"), method_7550, 0, "theClass;name=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_13947, type_150), Reflex::Literal("addObject"), method_7551, 0, "object;doExistingCheck=1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16746), Reflex::Literal("getRandomGenerator"), method_7552, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_16746), Reflex::Literal("setRandomGenerator"), method_7553, 0, "generator", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_7554, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_7555, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_7556, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_7557, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_7558, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_7559, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_7560, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_7561, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_7562, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_7563, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_7564, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_7565, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TMatrixInterpreterDriver -------------------------------
static  void operator_7617( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TMatrixInterpreterDriver*)o)->operator=)(*(const ::TMatrixInterpreterDriver*)arg[0]);
  else   (((::TMatrixInterpreterDriver*)o)->operator=)(*(const ::TMatrixInterpreterDriver*)arg[0]);
}

static void constructor_7618( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMatrixInterpreterDriver(*(const ::TMatrixInterpreterDriver*)arg[0]);
  else ::new(mem) ::TMatrixInterpreterDriver(*(const ::TMatrixInterpreterDriver*)arg[0]);
}

static void constructor_7619( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMatrixInterpreterDriver();
  else ::new(mem) ::TMatrixInterpreterDriver();
}

static void destructor_7620(void*, void * o, const std::vector<void*>&, void *) {
((::TMatrixInterpreterDriver*)o)->::TMatrixInterpreterDriver::~TMatrixInterpreterDriver();
}
static  void method_7621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixInterpreterDriver*)o)->startOfData)());
  else   (((::TMatrixInterpreterDriver*)o)->startOfData)();
}

static  void method_7622( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixInterpreterDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TMatrixInterpreterDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_7623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixInterpreterDriver*)o)->Class)());
  else   (((::TMatrixInterpreterDriver*)o)->Class)();
}

static  void method_7624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixInterpreterDriver*)o)->Class_Name)());
  else   (((::TMatrixInterpreterDriver*)o)->Class_Name)();
}

static  void method_7625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TMatrixInterpreterDriver*)o)->Class_Version)());
  else   (((::TMatrixInterpreterDriver*)o)->Class_Version)();
}

static  void method_7626( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TMatrixInterpreterDriver*)o)->Dictionary)();
}

static  void method_7627( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMatrixInterpreterDriver*)o)->IsA)());
  else   (((const ::TMatrixInterpreterDriver*)o)->IsA)();
}

static  void method_7628( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixInterpreterDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_7629( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixInterpreterDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_7630( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixInterpreterDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_7631( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixInterpreterDriver*)o)->DeclFileName)());
  else   (((::TMatrixInterpreterDriver*)o)->DeclFileName)();
}

static  void method_7632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixInterpreterDriver*)o)->ImplFileLine)());
  else   (((::TMatrixInterpreterDriver*)o)->ImplFileLine)();
}

static  void method_7633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixInterpreterDriver*)o)->ImplFileName)());
  else   (((::TMatrixInterpreterDriver*)o)->ImplFileName)();
}

static  void method_7634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixInterpreterDriver*)o)->DeclFileLine)());
  else   (((::TMatrixInterpreterDriver*)o)->DeclFileLine)();
}

static void method_newdel_1435( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TMatrixInterpreterDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TMatrixInterpreterDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TMatrixInterpreterDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TMatrixInterpreterDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TMatrixInterpreterDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TMatrixInterpreterDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TMatrixInterpreterDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TMatrixInterpreterDriver -------------------------------
void __TMatrixInterpreterDriver_db_datamem(Reflex::Class*);
void __TMatrixInterpreterDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TMatrixInterpreterDriver_datamem_bld(&__TMatrixInterpreterDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TMatrixInterpreterDriver_funcmem_bld(&__TMatrixInterpreterDriver_db_funcmem);
void __TMatrixInterpreterDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TMatrixInterpreterDriver"), typeid(::TMatrixInterpreterDriver), sizeof(::TMatrixInterpreterDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TMatrixInterpreterDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2618, ::Reflex::BaseOffset< ::TMatrixInterpreterDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16758, type_16759), Reflex::Literal("operator="), operator_7617, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16759), Reflex::Literal("TMatrixInterpreterDriver"), constructor_7618, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TMatrixInterpreterDriver"), constructor_7619, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TMatrixInterpreterDriver"), destructor_7620, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1435, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TMatrixInterpreterDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TMatrixInterpreterDriver_funcmem_bld);
}

//------Delayed data member builder for class TMatrixInterpreterDriver -------------------
void __TMatrixInterpreterDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_16757, Reflex::Literal("hVoxelRecon"), OffsetOf(__shadow__::__TMatrixInterpreterDriver, hVoxelRecon), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TMatrixInterpreterDriver -------------------
void __TMatrixInterpreterDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("startOfData"), method_7621, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_15663), Reflex::Literal("process"), method_7622, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_7623, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_7624, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_7625, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_7626, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_7627, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_7628, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_7629, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_7630, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_7631, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_7632, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_7633, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_7634, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TLikelihoodComputationDriver -------------------------------
static  void operator_7714( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TLikelihoodComputationDriver*)o)->operator=)(*(const ::TLikelihoodComputationDriver*)arg[0]);
  else   (((::TLikelihoodComputationDriver*)o)->operator=)(*(const ::TLikelihoodComputationDriver*)arg[0]);
}

static void constructor_7715( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TLikelihoodComputationDriver(*(const ::TLikelihoodComputationDriver*)arg[0]);
  else ::new(mem) ::TLikelihoodComputationDriver(*(const ::TLikelihoodComputationDriver*)arg[0]);
}

static void constructor_7716( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TLikelihoodComputationDriver();
  else ::new(mem) ::TLikelihoodComputationDriver();
}

static void destructor_7717(void*, void * o, const std::vector<void*>&, void *) {
((::TLikelihoodComputationDriver*)o)->::TLikelihoodComputationDriver::~TLikelihoodComputationDriver();
}
static  void method_7718( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TLikelihoodComputationDriver*)o)->initParameters)();
}

static  void method_7719( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodComputationDriver*)o)->setFitObject)(*(::fitObject_t*)arg[0]);
}

static  void method_7720( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodComputationDriver*)o)->setFitLikelihoodMode)(*(::fitLikelihoodMode_t*)arg[0]);
}

static  void method_7721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodComputationDriver*)o)->getFitObject)());
  else   (((::TLikelihoodComputationDriver*)o)->getFitObject)();
}

static  void method_7722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodComputationDriver*)o)->getFitLikelihoodMode)());
  else   (((::TLikelihoodComputationDriver*)o)->getFitLikelihoodMode)();
}

static  void method_7723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodComputationDriver*)o)->start)());
  else   (((::TLikelihoodComputationDriver*)o)->start)();
}

static  void method_7724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodComputationDriver*)o)->startOfData)());
  else   (((::TLikelihoodComputationDriver*)o)->startOfData)();
}

static  void method_7725( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodComputationDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TLikelihoodComputationDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_7726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodComputationDriver*)o)->end)());
  else   (((::TLikelihoodComputationDriver*)o)->end)();
}

static  void method_7727( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodComputationDriver*)o)->configLikelihoodCalculator)((const char*)arg[0]);
}

static  void method_7728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TLikelihoodComputationDriver*)o)->getLikelihoodCalculator)());
  else   (((const ::TLikelihoodComputationDriver*)o)->getLikelihoodCalculator)();
}

static  void method_7729( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodComputationDriver*)o)->setLikelihoodCalculator)((::TLikelihoodCalculator*)arg[0]);
}

static  void method_7730( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodComputationDriver*)o)->setReconInputMode)((const char*)arg[0]);
}

static  void method_7731( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodComputationDriver*)o)->setReconInputFileName)((const char*)arg[0]);
}

static  void method_7733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodComputationDriver*)o)->Class)());
  else   (((::TLikelihoodComputationDriver*)o)->Class)();
}

static  void method_7734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodComputationDriver*)o)->Class_Name)());
  else   (((::TLikelihoodComputationDriver*)o)->Class_Name)();
}

static  void method_7735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TLikelihoodComputationDriver*)o)->Class_Version)());
  else   (((::TLikelihoodComputationDriver*)o)->Class_Version)();
}

static  void method_7736( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TLikelihoodComputationDriver*)o)->Dictionary)();
}

static  void method_7737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TLikelihoodComputationDriver*)o)->IsA)());
  else   (((const ::TLikelihoodComputationDriver*)o)->IsA)();
}

static  void method_7738( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodComputationDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_7739( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodComputationDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_7740( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodComputationDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_7741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodComputationDriver*)o)->DeclFileName)());
  else   (((::TLikelihoodComputationDriver*)o)->DeclFileName)();
}

static  void method_7742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodComputationDriver*)o)->ImplFileLine)());
  else   (((::TLikelihoodComputationDriver*)o)->ImplFileLine)();
}

static  void method_7743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodComputationDriver*)o)->ImplFileName)());
  else   (((::TLikelihoodComputationDriver*)o)->ImplFileName)();
}

static  void method_7744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodComputationDriver*)o)->DeclFileLine)());
  else   (((::TLikelihoodComputationDriver*)o)->DeclFileLine)();
}

static void method_newdel_1518( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TLikelihoodComputationDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TLikelihoodComputationDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TLikelihoodComputationDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TLikelihoodComputationDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TLikelihoodComputationDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x29( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TLikelihoodComputationDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TLikelihoodComputationDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TLikelihoodComputationDriver -------------------------------
void __TLikelihoodComputationDriver_db_datamem(Reflex::Class*);
void __TLikelihoodComputationDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TLikelihoodComputationDriver_datamem_bld(&__TLikelihoodComputationDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TLikelihoodComputationDriver_funcmem_bld(&__TLikelihoodComputationDriver_db_funcmem);
void __TLikelihoodComputationDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TLikelihoodComputationDriver"), typeid(::TLikelihoodComputationDriver), sizeof(::TLikelihoodComputationDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TLikelihoodComputationDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2618, ::Reflex::BaseOffset< ::TLikelihoodComputationDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16775, type_16776), Reflex::Literal("operator="), operator_7714, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16776), Reflex::Literal("TLikelihoodComputationDriver"), constructor_7715, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TLikelihoodComputationDriver"), constructor_7716, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TLikelihoodComputationDriver"), destructor_7717, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1518, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x29, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TLikelihoodComputationDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TLikelihoodComputationDriver_funcmem_bld);
}

//------Delayed data member builder for class TLikelihoodComputationDriver -------------------
void __TLikelihoodComputationDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_15764, Reflex::Literal("m_reconInput"), OffsetOf(__shadow__::__TLikelihoodComputationDriver, m_reconInput), ::Reflex::PROTECTED)
  .AddDataMember(type_15765, Reflex::Literal("m_realSetupHandler"), OffsetOf(__shadow__::__TLikelihoodComputationDriver, m_realSetupHandler), ::Reflex::PROTECTED)
  .AddDataMember(type_402, Reflex::Literal("m_fitObject"), OffsetOf(__shadow__::__TLikelihoodComputationDriver, m_fitObject), ::Reflex::PROTECTED)
  .AddDataMember(type_1016, Reflex::Literal("m_fitLikelihoodMode"), OffsetOf(__shadow__::__TLikelihoodComputationDriver, m_fitLikelihoodMode), ::Reflex::PROTECTED)
  .AddDataMember(type_15766, Reflex::Literal("m_ON"), OffsetOf(__shadow__::__TLikelihoodComputationDriver, m_ON), ::Reflex::PROTECTED)
  .AddDataMember(type_15766, Reflex::Literal("m_disc"), OffsetOf(__shadow__::__TLikelihoodComputationDriver, m_disc), ::Reflex::PROTECTED)
  .AddDataMember(type_15767, Reflex::Literal("m_Q"), OffsetOf(__shadow__::__TLikelihoodComputationDriver, m_Q), ::Reflex::PROTECTED)
  .AddDataMember(type_15767, Reflex::Literal("m_T"), OffsetOf(__shadow__::__TLikelihoodComputationDriver, m_T), ::Reflex::PROTECTED)
  .AddDataMember(type_150, Reflex::Literal("m_reconInputMode"), OffsetOf(__shadow__::__TLikelihoodComputationDriver, m_reconInputMode), ::Reflex::PROTECTED)
  .AddDataMember(type_2955, Reflex::Literal("m_reconInputFileName"), OffsetOf(__shadow__::__TLikelihoodComputationDriver, m_reconInputFileName), ::Reflex::PROTECTED)
  .AddDataMember(type_15768, Reflex::Literal("m_likelihoodCalculator"), OffsetOf(__shadow__::__TLikelihoodComputationDriver, m_likelihoodCalculator), ::Reflex::PROTECTED)
  .AddDataMember(type_15661, Reflex::Literal("hX"), OffsetOf(__shadow__::__TLikelihoodComputationDriver, hX), ::Reflex::PROTECTED)
  .AddDataMember(type_15661, Reflex::Literal("hY"), OffsetOf(__shadow__::__TLikelihoodComputationDriver, hY), ::Reflex::PROTECTED)
  .AddDataMember(type_15661, Reflex::Literal("hZ"), OffsetOf(__shadow__::__TLikelihoodComputationDriver, hZ), ::Reflex::PROTECTED)
  .AddDataMember(type_15769, Reflex::Literal("hXY"), OffsetOf(__shadow__::__TLikelihoodComputationDriver, hXY), ::Reflex::PROTECTED)
  .AddDataMember(type_15769, Reflex::Literal("hXZ"), OffsetOf(__shadow__::__TLikelihoodComputationDriver, hXZ), ::Reflex::PROTECTED)
  .AddDataMember(type_15769, Reflex::Literal("hYZ"), OffsetOf(__shadow__::__TLikelihoodComputationDriver, hYZ), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class TLikelihoodComputationDriver -------------------
void __TLikelihoodComputationDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("initParameters"), method_7718, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_402), Reflex::Literal("setFitObject"), method_7719, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_1016), Reflex::Literal("setFitLikelihoodMode"), method_7720, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_402), Reflex::Literal("getFitObject"), method_7721, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016), Reflex::Literal("getFitLikelihoodMode"), method_7722, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("start"), method_7723, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("startOfData"), method_7724, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_15663), Reflex::Literal("process"), method_7725, 0, "m_event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("end"), method_7726, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_3438), Reflex::Literal("configLikelihoodCalculator"), method_7727, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15768), Reflex::Literal("getLikelihoodCalculator"), method_7728, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15768), Reflex::Literal("setLikelihoodCalculator"), method_7729, 0, "likelihoodCalculator", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_3438), Reflex::Literal("setReconInputMode"), method_7730, 0, "mode", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_3438), Reflex::Literal("setReconInputFileName"), method_7731, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_7733, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_7734, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_7735, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_7736, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_7737, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_7738, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_7739, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_7740, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_7741, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_7742, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_7743, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_7744, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TMarocSetupHandlerDriver -------------------------------
static  void operator_7751( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TMarocSetupHandlerDriver*)o)->operator=)(*(const ::TMarocSetupHandlerDriver*)arg[0]);
  else   (((::TMarocSetupHandlerDriver*)o)->operator=)(*(const ::TMarocSetupHandlerDriver*)arg[0]);
}

static void constructor_7752( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMarocSetupHandlerDriver(*(const ::TMarocSetupHandlerDriver*)arg[0]);
  else ::new(mem) ::TMarocSetupHandlerDriver(*(const ::TMarocSetupHandlerDriver*)arg[0]);
}

static void constructor_7753( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMarocSetupHandlerDriver();
  else ::new(mem) ::TMarocSetupHandlerDriver();
}

static void destructor_7754(void*, void * o, const std::vector<void*>&, void *) {
((::TMarocSetupHandlerDriver*)o)->::TMarocSetupHandlerDriver::~TMarocSetupHandlerDriver();
}
static  void method_7755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocSetupHandlerDriver*)o)->start)());
  else   (((::TMarocSetupHandlerDriver*)o)->start)();
}

static  void method_7756( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocSetupHandlerDriver*)o)->setSource)(*(int*)arg[0]);
}

static  void method_7757( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocSetupHandlerDriver*)o)->setFileName)((const char*)arg[0]);
}

static  void method_7758( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocSetupHandlerDriver*)o)->Class)());
  else   (((::TMarocSetupHandlerDriver*)o)->Class)();
}

static  void method_7759( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocSetupHandlerDriver*)o)->Class_Name)());
  else   (((::TMarocSetupHandlerDriver*)o)->Class_Name)();
}

static  void method_7760( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TMarocSetupHandlerDriver*)o)->Class_Version)());
  else   (((::TMarocSetupHandlerDriver*)o)->Class_Version)();
}

static  void method_7761( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TMarocSetupHandlerDriver*)o)->Dictionary)();
}

static  void method_7762( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMarocSetupHandlerDriver*)o)->IsA)());
  else   (((const ::TMarocSetupHandlerDriver*)o)->IsA)();
}

static  void method_7763( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocSetupHandlerDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_7764( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocSetupHandlerDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_7765( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocSetupHandlerDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_7766( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocSetupHandlerDriver*)o)->DeclFileName)());
  else   (((::TMarocSetupHandlerDriver*)o)->DeclFileName)();
}

static  void method_7767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocSetupHandlerDriver*)o)->ImplFileLine)());
  else   (((::TMarocSetupHandlerDriver*)o)->ImplFileLine)();
}

static  void method_7768( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocSetupHandlerDriver*)o)->ImplFileName)());
  else   (((::TMarocSetupHandlerDriver*)o)->ImplFileName)();
}

static  void method_7769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocSetupHandlerDriver*)o)->DeclFileLine)());
  else   (((::TMarocSetupHandlerDriver*)o)->DeclFileLine)();
}

static void method_newdel_1529( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TMarocSetupHandlerDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TMarocSetupHandlerDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TMarocSetupHandlerDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TMarocSetupHandlerDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TMarocSetupHandlerDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x31( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TMarocSetupHandlerDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TMarocSetupHandlerDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TMarocSetupHandlerDriver -------------------------------
void __TMarocSetupHandlerDriver_db_datamem(Reflex::Class*);
void __TMarocSetupHandlerDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TMarocSetupHandlerDriver_datamem_bld(&__TMarocSetupHandlerDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TMarocSetupHandlerDriver_funcmem_bld(&__TMarocSetupHandlerDriver_db_funcmem);
void __TMarocSetupHandlerDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TMarocSetupHandlerDriver"), typeid(::TMarocSetupHandlerDriver), sizeof(::TMarocSetupHandlerDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TMarocSetupHandlerDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2618, ::Reflex::BaseOffset< ::TMarocSetupHandlerDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16778, type_16779), Reflex::Literal("operator="), operator_7751, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16779), Reflex::Literal("TMarocSetupHandlerDriver"), constructor_7752, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TMarocSetupHandlerDriver"), constructor_7753, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TMarocSetupHandlerDriver"), destructor_7754, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1529, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x31, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TMarocSetupHandlerDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TMarocSetupHandlerDriver_funcmem_bld);
}

//------Delayed data member builder for class TMarocSetupHandlerDriver -------------------
void __TMarocSetupHandlerDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_150, Reflex::Literal("m_source"), OffsetOf(__shadow__::__TMarocSetupHandlerDriver, m_source), ::Reflex::PRIVATE)
  .AddDataMember(type_2955, Reflex::Literal("m_fname"), OffsetOf(__shadow__::__TMarocSetupHandlerDriver, m_fname), ::Reflex::PRIVATE)
  .AddDataMember(type_16777, Reflex::Literal("m_setupHandler"), OffsetOf(__shadow__::__TMarocSetupHandlerDriver, m_setupHandler), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TMarocSetupHandlerDriver -------------------
void __TMarocSetupHandlerDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("start"), method_7755, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setSource"), method_7756, 0, "source", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_3438), Reflex::Literal("setFileName"), method_7757, 0, "fname", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_7758, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_7759, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_7760, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_7761, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_7762, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_7763, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_7764, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_7765, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_7766, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_7767, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_7768, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_7769, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TMCDataReaderDriver -------------------------------
static  void operator_8504( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TMCDataReaderDriver*)o)->operator=)(*(const ::TMCDataReaderDriver*)arg[0]);
  else   (((::TMCDataReaderDriver*)o)->operator=)(*(const ::TMCDataReaderDriver*)arg[0]);
}

static void constructor_8505( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMCDataReaderDriver(*(const ::TMCDataReaderDriver*)arg[0]);
  else ::new(mem) ::TMCDataReaderDriver(*(const ::TMCDataReaderDriver*)arg[0]);
}

static void constructor_8506( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMCDataReaderDriver();
  else ::new(mem) ::TMCDataReaderDriver();
}

static void destructor_8507(void*, void * o, const std::vector<void*>&, void *) {
((::TMCDataReaderDriver*)o)->::TMCDataReaderDriver::~TMCDataReaderDriver();
}
static  void method_8508( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMCDataReaderDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TMCDataReaderDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_8509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMCDataReaderDriver*)o)->startOfData)());
  else   (((::TMCDataReaderDriver*)o)->startOfData)();
}

static  void method_8510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCDataReaderDriver*)o)->Class)());
  else   (((::TMCDataReaderDriver*)o)->Class)();
}

static  void method_8511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCDataReaderDriver*)o)->Class_Name)());
  else   (((::TMCDataReaderDriver*)o)->Class_Name)();
}

static  void method_8512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TMCDataReaderDriver*)o)->Class_Version)());
  else   (((::TMCDataReaderDriver*)o)->Class_Version)();
}

static  void method_8513( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TMCDataReaderDriver*)o)->Dictionary)();
}

static  void method_8514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMCDataReaderDriver*)o)->IsA)());
  else   (((const ::TMCDataReaderDriver*)o)->IsA)();
}

static  void method_8515( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCDataReaderDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_8516( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCDataReaderDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_8517( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCDataReaderDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_8518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCDataReaderDriver*)o)->DeclFileName)());
  else   (((::TMCDataReaderDriver*)o)->DeclFileName)();
}

static  void method_8519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMCDataReaderDriver*)o)->ImplFileLine)());
  else   (((::TMCDataReaderDriver*)o)->ImplFileLine)();
}

static  void method_8520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCDataReaderDriver*)o)->ImplFileName)());
  else   (((::TMCDataReaderDriver*)o)->ImplFileName)();
}

static  void method_8521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMCDataReaderDriver*)o)->DeclFileLine)());
  else   (((::TMCDataReaderDriver*)o)->DeclFileLine)();
}

static void method_newdel_1849( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TMCDataReaderDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TMCDataReaderDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TMCDataReaderDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TMCDataReaderDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TMCDataReaderDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x33( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TMCDataReaderDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TMCDataReaderDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TMCDataReaderDriver -------------------------------
void __TMCDataReaderDriver_db_datamem(Reflex::Class*);
void __TMCDataReaderDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TMCDataReaderDriver_datamem_bld(&__TMCDataReaderDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TMCDataReaderDriver_funcmem_bld(&__TMCDataReaderDriver_db_funcmem);
void __TMCDataReaderDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TMCDataReaderDriver"), typeid(::TMCDataReaderDriver), sizeof(::TMCDataReaderDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TMCDataReaderDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2618, ::Reflex::BaseOffset< ::TMCDataReaderDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17573, type_17574), Reflex::Literal("operator="), operator_8504, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17574), Reflex::Literal("TMCDataReaderDriver"), constructor_8505, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TMCDataReaderDriver"), constructor_8506, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TMCDataReaderDriver"), destructor_8507, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1849, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x33, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TMCDataReaderDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TMCDataReaderDriver_funcmem_bld);
}

//------Delayed data member builder for class TMCDataReaderDriver -------------------
void __TMCDataReaderDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_12451, Reflex::Literal("m_reconHitCollection"), OffsetOf(__shadow__::__TMCDataReaderDriver, m_reconHitCollection), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TMCDataReaderDriver -------------------
void __TMCDataReaderDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_15663), Reflex::Literal("process"), method_8508, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("startOfData"), method_8509, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_8510, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_8511, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_8512, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_8513, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_8514, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_8515, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_8516, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_8517, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_8518, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_8519, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_8520, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_8521, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TMarocDataReaderDriver -------------------------------
static  void operator_9075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TMarocDataReaderDriver*)o)->operator=)(*(const ::TMarocDataReaderDriver*)arg[0]);
  else   (((::TMarocDataReaderDriver*)o)->operator=)(*(const ::TMarocDataReaderDriver*)arg[0]);
}

static void constructor_9076( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMarocDataReaderDriver(*(const ::TMarocDataReaderDriver*)arg[0]);
  else ::new(mem) ::TMarocDataReaderDriver(*(const ::TMarocDataReaderDriver*)arg[0]);
}

static void constructor_9077( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMarocDataReaderDriver();
  else ::new(mem) ::TMarocDataReaderDriver();
}

static void destructor_9078(void*, void * o, const std::vector<void*>&, void *) {
((::TMarocDataReaderDriver*)o)->::TMarocDataReaderDriver::~TMarocDataReaderDriver();
}
static  void method_9079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocDataReaderDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TMarocDataReaderDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_9080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocDataReaderDriver*)o)->startOfData)());
  else   (((::TMarocDataReaderDriver*)o)->startOfData)();
}

static  void method_9081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TMarocDataReaderDriver*)o)->getChargeCutMax)());
  else   (((const ::TMarocDataReaderDriver*)o)->getChargeCutMax)();
}

static  void method_9082( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocDataReaderDriver*)o)->setChargeCutMax)(*(double*)arg[0]);
}

static  void method_9083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TMarocDataReaderDriver*)o)->getChargeCutMin)());
  else   (((const ::TMarocDataReaderDriver*)o)->getChargeCutMin)();
}

static  void method_9084( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocDataReaderDriver*)o)->setChargeCutMin)(*(double*)arg[0]);
}

static  void method_9085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TMarocDataReaderDriver*)o)->getMultCutMax)());
  else   (((const ::TMarocDataReaderDriver*)o)->getMultCutMax)();
}

static  void method_9086( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocDataReaderDriver*)o)->setMultCutMax)(*(double*)arg[0]);
}

static  void method_9087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TMarocDataReaderDriver*)o)->getMultCutMin)());
  else   (((const ::TMarocDataReaderDriver*)o)->getMultCutMin)();
}

static  void method_9088( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocDataReaderDriver*)o)->setMultCutMin)(*(double*)arg[0]);
}

static  void method_9089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocDataReaderDriver*)o)->Class)());
  else   (((::TMarocDataReaderDriver*)o)->Class)();
}

static  void method_9090( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocDataReaderDriver*)o)->Class_Name)());
  else   (((::TMarocDataReaderDriver*)o)->Class_Name)();
}

static  void method_9091( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TMarocDataReaderDriver*)o)->Class_Version)());
  else   (((::TMarocDataReaderDriver*)o)->Class_Version)();
}

static  void method_9092( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TMarocDataReaderDriver*)o)->Dictionary)();
}

static  void method_9093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMarocDataReaderDriver*)o)->IsA)());
  else   (((const ::TMarocDataReaderDriver*)o)->IsA)();
}

static  void method_9094( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocDataReaderDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_9095( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocDataReaderDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_9096( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocDataReaderDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_9097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocDataReaderDriver*)o)->DeclFileName)());
  else   (((::TMarocDataReaderDriver*)o)->DeclFileName)();
}

static  void method_9098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocDataReaderDriver*)o)->ImplFileLine)());
  else   (((::TMarocDataReaderDriver*)o)->ImplFileLine)();
}

static  void method_9099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocDataReaderDriver*)o)->ImplFileName)());
  else   (((::TMarocDataReaderDriver*)o)->ImplFileName)();
}

static  void method_9100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocDataReaderDriver*)o)->DeclFileLine)());
  else   (((::TMarocDataReaderDriver*)o)->DeclFileLine)();
}

static void method_newdel_2025( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TMarocDataReaderDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TMarocDataReaderDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TMarocDataReaderDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TMarocDataReaderDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TMarocDataReaderDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x35( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TMarocDataReaderDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TMarocDataReaderDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TMarocDataReaderDriver -------------------------------
void __TMarocDataReaderDriver_db_datamem(Reflex::Class*);
void __TMarocDataReaderDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TMarocDataReaderDriver_datamem_bld(&__TMarocDataReaderDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TMarocDataReaderDriver_funcmem_bld(&__TMarocDataReaderDriver_db_funcmem);
void __TMarocDataReaderDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TMarocDataReaderDriver"), typeid(::TMarocDataReaderDriver), sizeof(::TMarocDataReaderDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TMarocDataReaderDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2618, ::Reflex::BaseOffset< ::TMarocDataReaderDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17625, type_17626), Reflex::Literal("operator="), operator_9075, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17626), Reflex::Literal("TMarocDataReaderDriver"), constructor_9076, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TMarocDataReaderDriver"), constructor_9077, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TMarocDataReaderDriver"), destructor_9078, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2025, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x35, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TMarocDataReaderDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TMarocDataReaderDriver_funcmem_bld);
}

//------Delayed data member builder for class TMarocDataReaderDriver -------------------
void __TMarocDataReaderDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_12451, Reflex::Literal("m_reconHitCollection"), OffsetOf(__shadow__::__TMarocDataReaderDriver, m_reconHitCollection), ::Reflex::PRIVATE)
  .AddDataMember(type_16777, Reflex::Literal("m_marocSetupHandler"), OffsetOf(__shadow__::__TMarocDataReaderDriver, m_marocSetupHandler), ::Reflex::PRIVATE)
  .AddDataMember(type_17624, Reflex::Literal("m_marocEventHeader"), OffsetOf(__shadow__::__TMarocDataReaderDriver, m_marocEventHeader), ::Reflex::PRIVATE)
  .AddDataMember(type_247, Reflex::Literal("m_ChargeCutMin"), OffsetOf(__shadow__::__TMarocDataReaderDriver, m_ChargeCutMin), ::Reflex::PRIVATE)
  .AddDataMember(type_247, Reflex::Literal("m_ChargeCutMax"), OffsetOf(__shadow__::__TMarocDataReaderDriver, m_ChargeCutMax), ::Reflex::PRIVATE)
  .AddDataMember(type_247, Reflex::Literal("m_MultCutMin"), OffsetOf(__shadow__::__TMarocDataReaderDriver, m_MultCutMin), ::Reflex::PRIVATE)
  .AddDataMember(type_247, Reflex::Literal("m_MultCutMax"), OffsetOf(__shadow__::__TMarocDataReaderDriver, m_MultCutMax), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TMarocDataReaderDriver -------------------
void __TMarocDataReaderDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_15663), Reflex::Literal("process"), method_9079, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("startOfData"), method_9080, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247), Reflex::Literal("getChargeCutMax"), method_9081, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_247), Reflex::Literal("setChargeCutMax"), method_9082, 0, "chargeCutMax", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247), Reflex::Literal("getChargeCutMin"), method_9083, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_247), Reflex::Literal("setChargeCutMin"), method_9084, 0, "chargeCutMin", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247), Reflex::Literal("getMultCutMax"), method_9085, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_247), Reflex::Literal("setMultCutMax"), method_9086, 0, "multCutMax", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247), Reflex::Literal("getMultCutMin"), method_9087, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_247), Reflex::Literal("setMultCutMin"), method_9088, 0, "multCutMin", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_9089, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_9090, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_9091, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_9092, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_9093, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_9094, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_9095, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_9096, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_9097, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_9098, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_9099, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_9100, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TMatrixReconDriver -------------------------------
static  void operator_9367( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TMatrixReconDriver*)o)->operator=)(*(const ::TMatrixReconDriver*)arg[0]);
  else   (((::TMatrixReconDriver*)o)->operator=)(*(const ::TMatrixReconDriver*)arg[0]);
}

static void constructor_9368( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMatrixReconDriver(*(const ::TMatrixReconDriver*)arg[0]);
  else ::new(mem) ::TMatrixReconDriver(*(const ::TMatrixReconDriver*)arg[0]);
}

static void constructor_9369( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMatrixReconDriver();
  else ::new(mem) ::TMatrixReconDriver();
}

static void destructor_9370(void*, void * o, const std::vector<void*>&, void *) {
((::TMatrixReconDriver*)o)->::TMatrixReconDriver::~TMatrixReconDriver();
}
static  void method_9371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixReconDriver*)o)->start)());
  else   (((::TMatrixReconDriver*)o)->start)();
}

static  void method_9372( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixReconDriver*)o)->startOfData)());
  else   (((::TMatrixReconDriver*)o)->startOfData)();
}

static  void method_9373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixReconDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TMatrixReconDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_9374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixReconDriver*)o)->endOfData)());
  else   (((::TMatrixReconDriver*)o)->endOfData)();
}

static  void method_9375( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixReconDriver*)o)->setMatrixSource)((const char*)arg[0]);
}

static  void method_9376( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixReconDriver*)o)->setMatrixFileName)((const char*)arg[0]);
}

static  void method_9377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixReconDriver*)o)->Class)());
  else   (((::TMatrixReconDriver*)o)->Class)();
}

static  void method_9378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixReconDriver*)o)->Class_Name)());
  else   (((::TMatrixReconDriver*)o)->Class_Name)();
}

static  void method_9379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TMatrixReconDriver*)o)->Class_Version)());
  else   (((::TMatrixReconDriver*)o)->Class_Version)();
}

static  void method_9380( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TMatrixReconDriver*)o)->Dictionary)();
}

static  void method_9381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMatrixReconDriver*)o)->IsA)());
  else   (((const ::TMatrixReconDriver*)o)->IsA)();
}

static  void method_9382( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixReconDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_9383( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixReconDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_9384( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMatrixReconDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_9385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixReconDriver*)o)->DeclFileName)());
  else   (((::TMatrixReconDriver*)o)->DeclFileName)();
}

static  void method_9386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixReconDriver*)o)->ImplFileLine)());
  else   (((::TMatrixReconDriver*)o)->ImplFileLine)();
}

static  void method_9387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMatrixReconDriver*)o)->ImplFileName)());
  else   (((::TMatrixReconDriver*)o)->ImplFileName)();
}

static  void method_9388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMatrixReconDriver*)o)->DeclFileLine)());
  else   (((::TMatrixReconDriver*)o)->DeclFileLine)();
}

static void method_newdel_2124( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TMatrixReconDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TMatrixReconDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TMatrixReconDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TMatrixReconDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TMatrixReconDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x37( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TMatrixReconDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TMatrixReconDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TMatrixReconDriver -------------------------------
void __TMatrixReconDriver_db_datamem(Reflex::Class*);
void __TMatrixReconDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TMatrixReconDriver_datamem_bld(&__TMatrixReconDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TMatrixReconDriver_funcmem_bld(&__TMatrixReconDriver_db_funcmem);
void __TMatrixReconDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TMatrixReconDriver"), typeid(::TMatrixReconDriver), sizeof(::TMatrixReconDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TMatrixReconDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2618, ::Reflex::BaseOffset< ::TMatrixReconDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17766, type_17767), Reflex::Literal("operator="), operator_9367, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17767), Reflex::Literal("TMatrixReconDriver"), constructor_9368, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TMatrixReconDriver"), constructor_9369, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TMatrixReconDriver"), destructor_9370, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2124, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x37, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TMatrixReconDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TMatrixReconDriver_funcmem_bld);
}

//------Delayed data member builder for class TMatrixReconDriver -------------------
void __TMatrixReconDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17765, Reflex::Literal("m_matrix"), OffsetOf(__shadow__::__TMatrixReconDriver, m_matrix), ::Reflex::PRIVATE)
  .AddDataMember(type_156, Reflex::Literal("m_matrixInverse"), OffsetOf(__shadow__::__TMatrixReconDriver, m_matrixInverse), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_matrixSource"), OffsetOf(__shadow__::__TMatrixReconDriver, m_matrixSource), ::Reflex::PRIVATE)
  .AddDataMember(type_15958, Reflex::Literal("m_matrixFile"), OffsetOf(__shadow__::__TMatrixReconDriver, m_matrixFile), ::Reflex::PRIVATE)
  .AddDataMember(type_2955, Reflex::Literal("m_matrixFileName"), OffsetOf(__shadow__::__TMatrixReconDriver, m_matrixFileName), ::Reflex::PRIVATE)
  .AddDataMember(type_16757, Reflex::Literal("hVoxelsInput"), OffsetOf(__shadow__::__TMatrixReconDriver, hVoxelsInput), ::Reflex::PRIVATE)
  .AddDataMember(type_16757, Reflex::Literal("hVoxelsReconAll"), OffsetOf(__shadow__::__TMatrixReconDriver, hVoxelsReconAll), ::Reflex::PRIVATE)
  .AddDataMember(type_156, Reflex::Literal("m_pixelDataAll"), OffsetOf(__shadow__::__TMatrixReconDriver, m_pixelDataAll), ::Reflex::PRIVATE)
  .AddDataMember(type_156, Reflex::Literal("m_voxelDataAll"), OffsetOf(__shadow__::__TMatrixReconDriver, m_voxelDataAll), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TMatrixReconDriver -------------------
void __TMatrixReconDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("start"), method_9371, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("startOfData"), method_9372, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_15663), Reflex::Literal("process"), method_9373, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("endOfData"), method_9374, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_3438), Reflex::Literal("setMatrixSource"), method_9375, 0, "source", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_3438), Reflex::Literal("setMatrixFileName"), method_9376, 0, "fname", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_9377, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_9378, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_9379, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_9380, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_9381, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_9382, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_9383, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_9384, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_9385, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_9386, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_9387, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_9388, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TTofpetThresholdCalibrationDriver -------------------------------
static  void operator_10324( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TTofpetThresholdCalibrationDriver*)o)->operator=)(*(const ::TTofpetThresholdCalibrationDriver*)arg[0]);
  else   (((::TTofpetThresholdCalibrationDriver*)o)->operator=)(*(const ::TTofpetThresholdCalibrationDriver*)arg[0]);
}

static void constructor_10325( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetThresholdCalibrationDriver(*(const ::TTofpetThresholdCalibrationDriver*)arg[0]);
  else ::new(mem) ::TTofpetThresholdCalibrationDriver(*(const ::TTofpetThresholdCalibrationDriver*)arg[0]);
}

static void constructor_10326( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TTofpetThresholdCalibrationDriver();
  else ::new(mem) ::TTofpetThresholdCalibrationDriver();
}

static void destructor_10327(void*, void * o, const std::vector<void*>&, void *) {
((::TTofpetThresholdCalibrationDriver*)o)->::TTofpetThresholdCalibrationDriver::~TTofpetThresholdCalibrationDriver();
}
static  void method_10328( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibrationDriver*)o)->start)());
  else   (((::TTofpetThresholdCalibrationDriver*)o)->start)();
}

static  void method_10329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibrationDriver*)o)->startOfData)());
  else   (((::TTofpetThresholdCalibrationDriver*)o)->startOfData)();
}

static  void method_10330( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibrationDriver*)o)->end)());
  else   (((::TTofpetThresholdCalibrationDriver*)o)->end)();
}

static  void method_10331( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibrationDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TTofpetThresholdCalibrationDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_10332( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TTofpetThresholdCalibrationDriver*)o)->getHToT0Max)());
  else   (((const ::TTofpetThresholdCalibrationDriver*)o)->getHToT0Max)();
}

static  void method_10333( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetThresholdCalibrationDriver*)o)->setHToT0Max)(*(double*)arg[0]);
}

static  void method_10334( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TTofpetThresholdCalibrationDriver*)o)->getHToT0Min)());
  else   (((const ::TTofpetThresholdCalibrationDriver*)o)->getHToT0Min)();
}

static  void method_10335( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetThresholdCalibrationDriver*)o)->setHToT0Min)(*(double*)arg[0]);
}

static  void method_10336( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetThresholdCalibrationDriver*)o)->getHToT0Nbins)());
  else   (((const ::TTofpetThresholdCalibrationDriver*)o)->getHToT0Nbins)();
}

static  void method_10337( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetThresholdCalibrationDriver*)o)->setHToT0Nbins)(*(int*)arg[0]);
}

static  void method_10338( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetThresholdCalibrationDriver*)o)->setThrFileName)((const char*)arg[0]);
}

static  void method_10339( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TTofpetThresholdCalibrationDriver*)o)->getIsInteractive)());
  else   (((const ::TTofpetThresholdCalibrationDriver*)o)->getIsInteractive)();
}

static  void method_10340( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetThresholdCalibrationDriver*)o)->setIsInteractive)(*(int*)arg[0]);
}

static  void method_10341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetThresholdCalibrationDriver*)o)->Class)());
  else   (((::TTofpetThresholdCalibrationDriver*)o)->Class)();
}

static  void method_10342( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetThresholdCalibrationDriver*)o)->Class_Name)());
  else   (((::TTofpetThresholdCalibrationDriver*)o)->Class_Name)();
}

static  void method_10343( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TTofpetThresholdCalibrationDriver*)o)->Class_Version)());
  else   (((::TTofpetThresholdCalibrationDriver*)o)->Class_Version)();
}

static  void method_10344( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TTofpetThresholdCalibrationDriver*)o)->Dictionary)();
}

static  void method_10345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TTofpetThresholdCalibrationDriver*)o)->IsA)());
  else   (((const ::TTofpetThresholdCalibrationDriver*)o)->IsA)();
}

static  void method_10346( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetThresholdCalibrationDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_10347( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetThresholdCalibrationDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_10348( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TTofpetThresholdCalibrationDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_10349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetThresholdCalibrationDriver*)o)->DeclFileName)());
  else   (((::TTofpetThresholdCalibrationDriver*)o)->DeclFileName)();
}

static  void method_10350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibrationDriver*)o)->ImplFileLine)());
  else   (((::TTofpetThresholdCalibrationDriver*)o)->ImplFileLine)();
}

static  void method_10351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TTofpetThresholdCalibrationDriver*)o)->ImplFileName)());
  else   (((::TTofpetThresholdCalibrationDriver*)o)->ImplFileName)();
}

static  void method_10352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TTofpetThresholdCalibrationDriver*)o)->DeclFileLine)());
  else   (((::TTofpetThresholdCalibrationDriver*)o)->DeclFileLine)();
}

static void method_newdel_2533( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TTofpetThresholdCalibrationDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TTofpetThresholdCalibrationDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TTofpetThresholdCalibrationDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TTofpetThresholdCalibrationDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TTofpetThresholdCalibrationDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x39( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TTofpetThresholdCalibrationDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TTofpetThresholdCalibrationDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TTofpetThresholdCalibrationDriver -------------------------------
void __TTofpetThresholdCalibrationDriver_db_datamem(Reflex::Class*);
void __TTofpetThresholdCalibrationDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TTofpetThresholdCalibrationDriver_datamem_bld(&__TTofpetThresholdCalibrationDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TTofpetThresholdCalibrationDriver_funcmem_bld(&__TTofpetThresholdCalibrationDriver_db_funcmem);
void __TTofpetThresholdCalibrationDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TTofpetThresholdCalibrationDriver"), typeid(::TTofpetThresholdCalibrationDriver), sizeof(::TTofpetThresholdCalibrationDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TTofpetThresholdCalibrationDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2618, ::Reflex::BaseOffset< ::TTofpetThresholdCalibrationDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18059, type_18060), Reflex::Literal("operator="), operator_10324, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18060), Reflex::Literal("TTofpetThresholdCalibrationDriver"), constructor_10325, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TTofpetThresholdCalibrationDriver"), constructor_10326, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TTofpetThresholdCalibrationDriver"), destructor_10327, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2533, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x39, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TTofpetThresholdCalibrationDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TTofpetThresholdCalibrationDriver_funcmem_bld);
}

//------Delayed data member builder for class TTofpetThresholdCalibrationDriver -------------------
void __TTofpetThresholdCalibrationDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_15929, Reflex::Literal("hToT0"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationDriver, hToT0), ::Reflex::PRIVATE)
  .AddDataMember(type_15930, Reflex::Literal("hToTvsThr"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationDriver, hToTvsThr), ::Reflex::PRIVATE)
  .AddDataMember(type_15931, Reflex::Literal("m_TTofpetRun"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationDriver, m_TTofpetRun), ::Reflex::PRIVATE)
  .AddDataMember(type_15682, Reflex::Literal("m_TTofpetSetupHandler"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationDriver, m_TTofpetSetupHandler), ::Reflex::PRIVATE)
  .AddDataMember(type_18058, Reflex::Literal("m_TTofpetThresholdCalibration"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationDriver, m_TTofpetThresholdCalibration), ::Reflex::PRIVATE)
  .AddDataMember(type_16741, Reflex::Literal("m_detector"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationDriver, m_detector), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_Nsteps"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationDriver, m_Nsteps), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_Nchannels"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationDriver, m_Nchannels), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_NhToT0"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationDriver, m_NhToT0), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_NhToTCalib"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationDriver, m_NhToTCalib), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_hToT0_nbins"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationDriver, m_hToT0_nbins), ::Reflex::PRIVATE)
  .AddDataMember(type_247, Reflex::Literal("m_hToT0_min"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationDriver, m_hToT0_min), ::Reflex::PRIVATE)
  .AddDataMember(type_247, Reflex::Literal("m_hToT0_max"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationDriver, m_hToT0_max), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("m_isInteractive"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationDriver, m_isInteractive), ::Reflex::PRIVATE)
  .AddDataMember(type_2955, Reflex::Literal("m_Thrfname"), OffsetOf(__shadow__::__TTofpetThresholdCalibrationDriver, m_Thrfname), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TTofpetThresholdCalibrationDriver -------------------
void __TTofpetThresholdCalibrationDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("start"), method_10328, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("startOfData"), method_10329, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("end"), method_10330, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_15663), Reflex::Literal("process"), method_10331, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247), Reflex::Literal("getHToT0Max"), method_10332, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_247), Reflex::Literal("setHToT0Max"), method_10333, 0, "hToT0Max", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247), Reflex::Literal("getHToT0Min"), method_10334, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_247), Reflex::Literal("setHToT0Min"), method_10335, 0, "hToT0Min", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getHToT0Nbins"), method_10336, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setHToT0Nbins"), method_10337, 0, "hToT0Nbins", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_3438), Reflex::Literal("setThrFileName"), method_10338, 0, "fname", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getIsInteractive"), method_10339, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setIsInteractive"), method_10340, 0, "isInteractive", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_10341, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_10342, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_10343, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_10344, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_10345, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_10346, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_10347, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_10348, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_10349, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_10350, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_10351, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_10352, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TDriver -------------------------------
static  void operator_10379( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TDriver*)o)->operator=)(*(const ::TDriver*)arg[0]);
  else   (((::TDriver*)o)->operator=)(*(const ::TDriver*)arg[0]);
}

static void constructor_10380( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TDriver(*(const ::TDriver*)arg[0]);
  else ::new(mem) ::TDriver(*(const ::TDriver*)arg[0]);
}

static void constructor_10381( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TDriver();
  else ::new(mem) ::TDriver();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TDriver((::TJobManager*)arg[0]);
  else ::new(mem) ::TDriver((::TJobManager*)arg[0]);
  }
}

static void destructor_10382(void*, void * o, const std::vector<void*>&, void *) {
((::TDriver*)o)->::TDriver::~TDriver();
}
static  void method_10383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->start)());
  else   (((::TDriver*)o)->start)();
}

static  void method_10384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->startOfData)());
  else   (((::TDriver*)o)->startOfData)();
}

static  void method_10385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->endOfData)());
  else   (((::TDriver*)o)->endOfData)();
}

static  void method_10386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->end)());
  else   (((::TDriver*)o)->end)();
}

static  void method_10387( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_10388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->detectorChanged)());
  else   (((::TDriver*)o)->detectorChanged)();
}

static  void method_10389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TDriver*)o)->getManager)());
  else   (((const ::TDriver*)o)->getManager)();
}

static  void method_10390( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->setManager)((::TJobManager*)arg[0]);
}

static  void method_10391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::TDriver*)o)->getName)();
  else   (((const ::TDriver*)o)->getName)();
}

static  void method_10392( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->setName)(*(const ::std::string*)arg[0]);
}

static  void method_10393( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDriver*)o)->getVerboseLevel)());
  else   (((const ::TDriver*)o)->getVerboseLevel)();
}

static  void method_10394( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->setVerboseLevel)(*(int*)arg[0]);
}

static  void method_10395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDriver*)o)->getIterationN)());
  else   (((const ::TDriver*)o)->getIterationN)();
}

static  void method_10396( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->setIterationN)(*(int*)arg[0]);
}

static  void method_10397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDriver*)o)->isProofCompatible)());
  else   (((const ::TDriver*)o)->isProofCompatible)();
}

static  void method_10398( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->setIsProofCompatible)(*(int*)arg[0]);
}

static  void method_10399( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->setCollectionName)((const char*)arg[0]);
}

static  void method_10400( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->setCollectionRawName)((const char*)arg[0]);
}

static  void method_10401( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->setCollectionOutName)((const char*)arg[0]);
}

static  void method_10402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDriver*)o)->Class)());
  else   (((::TDriver*)o)->Class)();
}

static  void method_10403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDriver*)o)->Class_Name)());
  else   (((::TDriver*)o)->Class_Name)();
}

static  void method_10404( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TDriver*)o)->Class_Version)());
  else   (((::TDriver*)o)->Class_Version)();
}

static  void method_10405( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TDriver*)o)->Dictionary)();
}

static  void method_10406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TDriver*)o)->IsA)());
  else   (((const ::TDriver*)o)->IsA)();
}

static  void method_10407( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_10408( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_10409( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_10410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDriver*)o)->DeclFileName)());
  else   (((::TDriver*)o)->DeclFileName)();
}

static  void method_10411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->ImplFileLine)());
  else   (((::TDriver*)o)->ImplFileLine)();
}

static  void method_10412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDriver*)o)->ImplFileName)());
  else   (((::TDriver*)o)->ImplFileName)();
}

static  void method_10413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDriver*)o)->DeclFileLine)());
  else   (((::TDriver*)o)->DeclFileLine)();
}

static void constructor_x40( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TDriver();
  else ::new(mem) ::TDriver();
}

static void method_newdel_2618( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x42( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TDriver,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TDriver -------------------------------
void __TDriver_db_datamem(Reflex::Class*);
void __TDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TDriver_datamem_bld(&__TDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TDriver_funcmem_bld(&__TDriver_db_funcmem);
void __TDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TDriver"), typeid(::TDriver), sizeof(::TDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2261, ::Reflex::BaseOffset< ::TDriver, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18064, type_18065), Reflex::Literal("operator="), operator_10379, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18065), Reflex::Literal("TDriver"), constructor_10380, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18063), Reflex::Literal("TDriver"), constructor_10381, 0, "manager=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TDriver"), destructor_10382, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TDriver"), constructor_x40, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2618, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x42, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TDriver_funcmem_bld);
}

//------Delayed data member builder for class TDriver -------------------
void __TDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_18063, Reflex::Literal("m_manager"), OffsetOf(__shadow__::__TDriver, m_manager), ::Reflex::PROTECTED)
  .AddDataMember(type_2955, Reflex::Literal("m_name"), OffsetOf(__shadow__::__TDriver, m_name), ::Reflex::PROTECTED)
  .AddDataMember(type_150, Reflex::Literal("m_verboseLevel"), OffsetOf(__shadow__::__TDriver, m_verboseLevel), ::Reflex::PROTECTED)
  .AddDataMember(type_150, Reflex::Literal("m_iterationN"), OffsetOf(__shadow__::__TDriver, m_iterationN), ::Reflex::PROTECTED)
  .AddDataMember(type_150, Reflex::Literal("m_isProofCompatible"), OffsetOf(__shadow__::__TDriver, m_isProofCompatible), ::Reflex::PROTECTED)
  .AddDataMember(type_2955, Reflex::Literal("m_collectionName"), OffsetOf(__shadow__::__TDriver, m_collectionName), ::Reflex::PROTECTED)
  .AddDataMember(type_2955, Reflex::Literal("m_collectionRawName"), OffsetOf(__shadow__::__TDriver, m_collectionRawName), ::Reflex::PROTECTED)
  .AddDataMember(type_2955, Reflex::Literal("m_collectionOutName"), OffsetOf(__shadow__::__TDriver, m_collectionOutName), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class TDriver -------------------
void __TDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("start"), method_10383, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("startOfData"), method_10384, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("endOfData"), method_10385, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("end"), method_10386, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_15663), Reflex::Literal("process"), method_10387, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("detectorChanged"), method_10388, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18063), Reflex::Literal("getManager"), method_10389, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_18063), Reflex::Literal("setManager"), method_10390, 0, "manager", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14900), Reflex::Literal("getName"), method_10391, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_14900), Reflex::Literal("setName"), method_10392, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getVerboseLevel"), method_10393, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setVerboseLevel"), method_10394, 0, "verboseLevel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getIterationN"), method_10395, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setIterationN"), method_10396, 0, "iterationN", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("isProofCompatible"), method_10397, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setIsProofCompatible"), method_10398, 0, "isProofCompatible", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_3438), Reflex::Literal("setCollectionName"), method_10399, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_3438), Reflex::Literal("setCollectionRawName"), method_10400, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_3438), Reflex::Literal("setCollectionOutName"), method_10401, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_10402, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_10403, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_10404, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_10405, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_10406, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_10407, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_10408, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_10409, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_10410, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_10411, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_10412, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_10413, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TLikelihoodCalculatorMaroc1 -------------------------------
static  void operator_10415( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TLikelihoodCalculatorMaroc1*)o)->operator=)(*(const ::TLikelihoodCalculatorMaroc1*)arg[0]);
  else   (((::TLikelihoodCalculatorMaroc1*)o)->operator=)(*(const ::TLikelihoodCalculatorMaroc1*)arg[0]);
}

static void constructor_10416( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TLikelihoodCalculatorMaroc1(*(const ::TLikelihoodCalculatorMaroc1*)arg[0]);
  else ::new(mem) ::TLikelihoodCalculatorMaroc1(*(const ::TLikelihoodCalculatorMaroc1*)arg[0]);
}

static void constructor_10417( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TLikelihoodCalculatorMaroc1();
  else ::new(mem) ::TLikelihoodCalculatorMaroc1();
}

static void destructor_10418(void*, void * o, const std::vector<void*>&, void *) {
((::TLikelihoodCalculatorMaroc1*)o)->::TLikelihoodCalculatorMaroc1::~TLikelihoodCalculatorMaroc1();
}
static  void method_10419( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodCalculatorMaroc1*)o)->CalculateLikelihood)((const double*)arg[0]));
  else   (((const ::TLikelihoodCalculatorMaroc1*)o)->CalculateLikelihood)((const double*)arg[0]);
}

static  void method_10420( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodCalculatorMaroc1*)o)->PointLikelihoodCharge)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]));
  else   (((const ::TLikelihoodCalculatorMaroc1*)o)->PointLikelihoodCharge)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]);
}

static  void method_10421( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodCalculatorMaroc1*)o)->PointLikelihoodTime)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]));
  else   (((const ::TLikelihoodCalculatorMaroc1*)o)->PointLikelihoodTime)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]);
}

static  void method_10422( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodCalculatorMaroc1*)o)->TrackLikelihoodCharge)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]));
  else   (((const ::TLikelihoodCalculatorMaroc1*)o)->TrackLikelihoodCharge)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]);
}

static  void method_10423( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodCalculatorMaroc1*)o)->TrackLikelihoodTime)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]));
  else   (((const ::TLikelihoodCalculatorMaroc1*)o)->TrackLikelihoodTime)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    (const double*)arg[3]);
}

static  void method_10424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodCalculatorMaroc1*)o)->Class)());
  else   (((::TLikelihoodCalculatorMaroc1*)o)->Class)();
}

static  void method_10425( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodCalculatorMaroc1*)o)->Class_Name)());
  else   (((::TLikelihoodCalculatorMaroc1*)o)->Class_Name)();
}

static  void method_10426( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TLikelihoodCalculatorMaroc1*)o)->Class_Version)());
  else   (((::TLikelihoodCalculatorMaroc1*)o)->Class_Version)();
}

static  void method_10427( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TLikelihoodCalculatorMaroc1*)o)->Dictionary)();
}

static  void method_10428( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TLikelihoodCalculatorMaroc1*)o)->IsA)());
  else   (((const ::TLikelihoodCalculatorMaroc1*)o)->IsA)();
}

static  void method_10429( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodCalculatorMaroc1*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_10430( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodCalculatorMaroc1*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_10431( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodCalculatorMaroc1*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_10432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodCalculatorMaroc1*)o)->DeclFileName)());
  else   (((::TLikelihoodCalculatorMaroc1*)o)->DeclFileName)();
}

static  void method_10433( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodCalculatorMaroc1*)o)->ImplFileLine)());
  else   (((::TLikelihoodCalculatorMaroc1*)o)->ImplFileLine)();
}

static  void method_10434( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodCalculatorMaroc1*)o)->ImplFileName)());
  else   (((::TLikelihoodCalculatorMaroc1*)o)->ImplFileName)();
}

static  void method_10435( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodCalculatorMaroc1*)o)->DeclFileLine)());
  else   (((::TLikelihoodCalculatorMaroc1*)o)->DeclFileLine)();
}

static void method_newdel_2628( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TLikelihoodCalculatorMaroc1 >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TLikelihoodCalculatorMaroc1 >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TLikelihoodCalculatorMaroc1 >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TLikelihoodCalculatorMaroc1 >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TLikelihoodCalculatorMaroc1 >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x44( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TLikelihoodCalculator")), ::Reflex::BaseOffset< ::TLikelihoodCalculatorMaroc1,::TLikelihoodCalculator >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TLikelihoodCalculatorMaroc1,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TLikelihoodCalculatorMaroc1 -------------------------------
void __TLikelihoodCalculatorMaroc1_db_datamem(Reflex::Class*);
void __TLikelihoodCalculatorMaroc1_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TLikelihoodCalculatorMaroc1_datamem_bld(&__TLikelihoodCalculatorMaroc1_db_datamem);
Reflex::GenreflexMemberBuilder __TLikelihoodCalculatorMaroc1_funcmem_bld(&__TLikelihoodCalculatorMaroc1_db_funcmem);
void __TLikelihoodCalculatorMaroc1_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TLikelihoodCalculatorMaroc1"), typeid(::TLikelihoodCalculatorMaroc1), sizeof(::TLikelihoodCalculatorMaroc1), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TLikelihoodCalculatorMaroc1::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2679, ::Reflex::BaseOffset< ::TLikelihoodCalculatorMaroc1, ::TLikelihoodCalculator >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18066, type_18067), Reflex::Literal("operator="), operator_10415, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18067), Reflex::Literal("TLikelihoodCalculatorMaroc1"), constructor_10416, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TLikelihoodCalculatorMaroc1"), constructor_10417, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TLikelihoodCalculatorMaroc1"), destructor_10418, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2628, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x44, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__TLikelihoodCalculatorMaroc1_funcmem_bld);
}

//------Delayed data member builder for class TLikelihoodCalculatorMaroc1 -------------------
void __TLikelihoodCalculatorMaroc1_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class TLikelihoodCalculatorMaroc1 -------------------
void __TLikelihoodCalculatorMaroc1_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247, type_12392), Reflex::Literal("CalculateLikelihood"), method_10419, 0, "x", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247, type_150, type_150, type_150, type_12392), Reflex::Literal("PointLikelihoodCharge"), method_10420, 0, "iface;idetector;id;para", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247, type_150, type_150, type_150, type_12392), Reflex::Literal("PointLikelihoodTime"), method_10421, 0, "iface;idetector;id;para", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247, type_150, type_150, type_150, type_12392), Reflex::Literal("TrackLikelihoodCharge"), method_10422, 0, "iface;idetector;id;para", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247, type_150, type_150, type_150, type_12392), Reflex::Literal("TrackLikelihoodTime"), method_10423, 0, "iface;idetector;id;para", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_10424, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_10425, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_10426, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_10427, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_10428, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_10429, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_10430, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_10431, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_10432, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_10433, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_10434, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_10435, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TLikelihoodCalculator -------------------------------
static  void operator_10569( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TLikelihoodCalculator*)o)->operator=)(*(const ::TLikelihoodCalculator*)arg[0]);
  else   (((::TLikelihoodCalculator*)o)->operator=)(*(const ::TLikelihoodCalculator*)arg[0]);
}

static void constructor_10570( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TLikelihoodCalculator(*(const ::TLikelihoodCalculator*)arg[0]);
  else ::new(mem) ::TLikelihoodCalculator(*(const ::TLikelihoodCalculator*)arg[0]);
}

static void constructor_10571( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TLikelihoodCalculator();
  else ::new(mem) ::TLikelihoodCalculator();
}

static void destructor_10572(void*, void * o, const std::vector<void*>&, void *) {
((::TLikelihoodCalculator*)o)->::TLikelihoodCalculator::~TLikelihoodCalculator();
}
static  void method_10573( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TLikelihoodCalculator*)o)->CalculateLikelihood)((const double*)arg[0]));
  else   (((const ::TLikelihoodCalculator*)o)->CalculateLikelihood)((const double*)arg[0]);
}

static  void method_10574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TLikelihoodCalculator*)o)->getDriver)());
  else   (((const ::TLikelihoodCalculator*)o)->getDriver)();
}

static  void method_10575( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodCalculator*)o)->setDriver)((::TDriver*)arg[0]);
}

static  void method_10576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TLikelihoodCalculator*)o)->getDetector)());
  else   (((const ::TLikelihoodCalculator*)o)->getDetector)();
}

static  void method_10577( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodCalculator*)o)->setDetector)((::TDetector*)arg[0]);
}

static  void method_10578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TLikelihoodCalculator*)o)->getDetectorUtils)());
  else   (((const ::TLikelihoodCalculator*)o)->getDetectorUtils)();
}

static  void method_10579( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodCalculator*)o)->setDetectorUtils)((::TDetectorUtils*)arg[0]);
}

static  void method_10580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TLikelihoodCalculator*)o)->getRealSetupHandler)());
  else   (((const ::TLikelihoodCalculator*)o)->getRealSetupHandler)();
}

static  void method_10581( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodCalculator*)o)->setRealSetupHandler)((::TRealSetupHandler*)arg[0]);
}

static  void method_10582( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodCalculator*)o)->SetData)((int***)arg[0],
    (int***)arg[1],
    (double***)arg[2],
    (double***)arg[3]);
}

static  void method_10583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TLikelihoodCalculator*)o)->getFitLikelihoodMode)());
  else   (((const ::TLikelihoodCalculator*)o)->getFitLikelihoodMode)();
}

static  void method_10584( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodCalculator*)o)->setFitLikelihoodMode)(*(::fitLikelihoodMode_t*)arg[0]);
}

static  void method_10585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TLikelihoodCalculator*)o)->getFitObject)());
  else   (((const ::TLikelihoodCalculator*)o)->getFitObject)();
}

static  void method_10586( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodCalculator*)o)->setFitObject)(*(::fitObject_t*)arg[0]);
}

static  void method_10587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodCalculator*)o)->Class)());
  else   (((::TLikelihoodCalculator*)o)->Class)();
}

static  void method_10588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodCalculator*)o)->Class_Name)());
  else   (((::TLikelihoodCalculator*)o)->Class_Name)();
}

static  void method_10589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TLikelihoodCalculator*)o)->Class_Version)());
  else   (((::TLikelihoodCalculator*)o)->Class_Version)();
}

static  void method_10590( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TLikelihoodCalculator*)o)->Dictionary)();
}

static  void method_10591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TLikelihoodCalculator*)o)->IsA)());
  else   (((const ::TLikelihoodCalculator*)o)->IsA)();
}

static  void method_10592( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodCalculator*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_10593( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodCalculator*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_10594( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TLikelihoodCalculator*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_10595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodCalculator*)o)->DeclFileName)());
  else   (((::TLikelihoodCalculator*)o)->DeclFileName)();
}

static  void method_10596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodCalculator*)o)->ImplFileLine)());
  else   (((::TLikelihoodCalculator*)o)->ImplFileLine)();
}

static  void method_10597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TLikelihoodCalculator*)o)->ImplFileName)());
  else   (((::TLikelihoodCalculator*)o)->ImplFileName)();
}

static  void method_10598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TLikelihoodCalculator*)o)->DeclFileLine)());
  else   (((::TLikelihoodCalculator*)o)->DeclFileLine)();
}

static void method_newdel_2679( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TLikelihoodCalculator >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TLikelihoodCalculator >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TLikelihoodCalculator >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TLikelihoodCalculator >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TLikelihoodCalculator >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x46( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TLikelihoodCalculator,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TLikelihoodCalculator -------------------------------
void __TLikelihoodCalculator_db_datamem(Reflex::Class*);
void __TLikelihoodCalculator_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TLikelihoodCalculator_datamem_bld(&__TLikelihoodCalculator_db_datamem);
Reflex::GenreflexMemberBuilder __TLikelihoodCalculator_funcmem_bld(&__TLikelihoodCalculator_db_funcmem);
void __TLikelihoodCalculator_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TLikelihoodCalculator"), typeid(::TLikelihoodCalculator), sizeof(::TLikelihoodCalculator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TLikelihoodCalculator::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2261, ::Reflex::BaseOffset< ::TLikelihoodCalculator, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18085, type_18086), Reflex::Literal("operator="), operator_10569, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18086), Reflex::Literal("TLikelihoodCalculator"), constructor_10570, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TLikelihoodCalculator"), constructor_10571, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TLikelihoodCalculator"), destructor_10572, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2679, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x46, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TLikelihoodCalculator_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TLikelihoodCalculator_funcmem_bld);
}

//------Delayed data member builder for class TLikelihoodCalculator -------------------
void __TLikelihoodCalculator_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9059, Reflex::Literal("m_driver"), OffsetOf(__shadow__::__TLikelihoodCalculator, m_driver), ::Reflex::PROTECTED)
  .AddDataMember(type_16741, Reflex::Literal("m_detector"), OffsetOf(__shadow__::__TLikelihoodCalculator, m_detector), ::Reflex::PROTECTED)
  .AddDataMember(type_16742, Reflex::Literal("m_detectorUtils"), OffsetOf(__shadow__::__TLikelihoodCalculator, m_detectorUtils), ::Reflex::PROTECTED)
  .AddDataMember(type_15765, Reflex::Literal("m_realSetupHandler"), OffsetOf(__shadow__::__TLikelihoodCalculator, m_realSetupHandler), ::Reflex::PROTECTED)
  .AddDataMember(type_15766, Reflex::Literal("m_ON"), OffsetOf(__shadow__::__TLikelihoodCalculator, m_ON), ::Reflex::PROTECTED)
  .AddDataMember(type_15766, Reflex::Literal("m_disc"), OffsetOf(__shadow__::__TLikelihoodCalculator, m_disc), ::Reflex::PROTECTED)
  .AddDataMember(type_15767, Reflex::Literal("m_Q"), OffsetOf(__shadow__::__TLikelihoodCalculator, m_Q), ::Reflex::PROTECTED)
  .AddDataMember(type_15767, Reflex::Literal("m_T"), OffsetOf(__shadow__::__TLikelihoodCalculator, m_T), ::Reflex::PROTECTED)
  .AddDataMember(type_402, Reflex::Literal("m_fitObject"), OffsetOf(__shadow__::__TLikelihoodCalculator, m_fitObject), ::Reflex::PROTECTED)
  .AddDataMember(type_1016, Reflex::Literal("m_fitLikelihoodMode"), OffsetOf(__shadow__::__TLikelihoodCalculator, m_fitLikelihoodMode), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class TLikelihoodCalculator -------------------
void __TLikelihoodCalculator_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247, type_12392), Reflex::Literal("CalculateLikelihood"), method_10573, 0, "x", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9059), Reflex::Literal("getDriver"), method_10574, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_9059), Reflex::Literal("setDriver"), method_10575, 0, "driver", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16741), Reflex::Literal("getDetector"), method_10576, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_16741), Reflex::Literal("setDetector"), method_10577, 0, "detector", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16742), Reflex::Literal("getDetectorUtils"), method_10578, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_16742), Reflex::Literal("setDetectorUtils"), method_10579, 0, "detectorUtils", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15765), Reflex::Literal("getRealSetupHandler"), method_10580, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15765), Reflex::Literal("setRealSetupHandler"), method_10581, 0, "realSetupHandler", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_18087, type_18087, type_18088, type_18088), Reflex::Literal("SetData"), method_10582, 0, "ON;disc;T;Q", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1016), Reflex::Literal("getFitLikelihoodMode"), method_10583, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_1016), Reflex::Literal("setFitLikelihoodMode"), method_10584, 0, "fitLikelihoodMode", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_402), Reflex::Literal("getFitObject"), method_10585, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_402), Reflex::Literal("setFitObject"), method_10586, 0, "fitObject", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_10587, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_10588, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_10589, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_10590, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_10591, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_10592, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_10593, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_10594, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_10595, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_10596, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_10597, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_10598, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TAnalysis -------------------------------
static  void operator_11124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TAnalysis*)o)->operator=)(*(const ::TAnalysis*)arg[0]);
  else   (((::TAnalysis*)o)->operator=)(*(const ::TAnalysis*)arg[0]);
}

static void constructor_11125( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TAnalysis(*(const ::TAnalysis*)arg[0]);
  else ::new(mem) ::TAnalysis(*(const ::TAnalysis*)arg[0]);
}

static void constructor_11126( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TAnalysis();
  else ::new(mem) ::TAnalysis();
}

static void destructor_11127(void*, void * o, const std::vector<void*>&, void *) {
((::TAnalysis*)o)->::TAnalysis::~TAnalysis();
}
static  void method_11128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TAnalysis*)o)->getChain)());
  else   (((const ::TAnalysis*)o)->getChain)();
}

static  void method_11129( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TAnalysis*)o)->setChain)((::TChain*)arg[0]);
}

static  void method_11130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TAnalysis*)o)->getManager)());
  else   (((const ::TAnalysis*)o)->getManager)();
}

static  void method_11131( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TAnalysis*)o)->setManager)((::TJobManager*)arg[0]);
}

static  void method_11132( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TAnalysis*)o)->addToInputList)((::TObject*)arg[0]);
}

static  void method_11133( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TAnalysis*)o)->configure)(*(::std::string*)arg[0]);
}

static  void method_11134( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TAnalysis*)o)->addFileToChain)(*(::std::string*)arg[0]);
}

static  void method_11135( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TAnalysis*)o)->run)();
}

static  void method_11136( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TAnalysis*)o)->ParseCommandLine)(*(int*)arg[0],
    (char**)arg[1]);
}

static  void method_11137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TAnalysis*)o)->Class)());
  else   (((::TAnalysis*)o)->Class)();
}

static  void method_11138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TAnalysis*)o)->Class_Name)());
  else   (((::TAnalysis*)o)->Class_Name)();
}

static  void method_11139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TAnalysis*)o)->Class_Version)());
  else   (((::TAnalysis*)o)->Class_Version)();
}

static  void method_11140( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TAnalysis*)o)->Dictionary)();
}

static  void method_11141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TAnalysis*)o)->IsA)());
  else   (((const ::TAnalysis*)o)->IsA)();
}

static  void method_11142( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TAnalysis*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11143( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TAnalysis*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11144( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TAnalysis*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TAnalysis*)o)->DeclFileName)());
  else   (((::TAnalysis*)o)->DeclFileName)();
}

static  void method_11146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TAnalysis*)o)->ImplFileLine)());
  else   (((::TAnalysis*)o)->ImplFileLine)();
}

static  void method_11147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TAnalysis*)o)->ImplFileName)());
  else   (((::TAnalysis*)o)->ImplFileName)();
}

static  void method_11148( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TAnalysis*)o)->DeclFileLine)());
  else   (((::TAnalysis*)o)->DeclFileLine)();
}

static void method_newdel_2738( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TAnalysis >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TAnalysis >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TAnalysis >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TAnalysis >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TAnalysis >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x48( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TAnalysis,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TAnalysis -------------------------------
void __TAnalysis_db_datamem(Reflex::Class*);
void __TAnalysis_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TAnalysis_datamem_bld(&__TAnalysis_db_datamem);
Reflex::GenreflexMemberBuilder __TAnalysis_funcmem_bld(&__TAnalysis_db_funcmem);
void __TAnalysis_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TAnalysis"), typeid(::TAnalysis), sizeof(::TAnalysis), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TAnalysis::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2261, ::Reflex::BaseOffset< ::TAnalysis, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18116, type_18117), Reflex::Literal("operator="), operator_11124, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18117), Reflex::Literal("TAnalysis"), constructor_11125, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TAnalysis"), constructor_11126, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TAnalysis"), destructor_11127, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2738, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x48, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TAnalysis_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TAnalysis_funcmem_bld);
}

//------Delayed data member builder for class TAnalysis -------------------
void __TAnalysis_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_18063, Reflex::Literal("m_manager"), OffsetOf(__shadow__::__TAnalysis, m_manager), ::Reflex::PRIVATE)
  .AddDataMember(type_18113, Reflex::Literal("m_chain"), OffsetOf(__shadow__::__TAnalysis, m_chain), ::Reflex::PRIVATE)
  .AddDataMember(type_18114, Reflex::Literal("m_proof"), OffsetOf(__shadow__::__TAnalysis, m_proof), ::Reflex::PRIVATE)
  .AddDataMember(type_2955, Reflex::Literal("m_steeringName"), OffsetOf(__shadow__::__TAnalysis, m_steeringName), ::Reflex::PRIVATE)
  .AddDataMember(type_2955, Reflex::Literal("m_detName"), OffsetOf(__shadow__::__TAnalysis, m_detName), ::Reflex::PRIVATE)
  .AddDataMember(type_18115, Reflex::Literal("m_fileName"), OffsetOf(__shadow__::__TAnalysis, m_fileName), ::Reflex::PRIVATE)
  .AddDataMember(type_150, Reflex::Literal("isConfigured"), OffsetOf(__shadow__::__TAnalysis, isConfigured), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TAnalysis -------------------
void __TAnalysis_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18113), Reflex::Literal("getChain"), method_11128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_18113), Reflex::Literal("setChain"), method_11129, 0, "fChain", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18063), Reflex::Literal("getManager"), method_11130, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_18063), Reflex::Literal("setManager"), method_11131, 0, "manager", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_13947), Reflex::Literal("addToInputList"), method_11132, 0, "obj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_2955), Reflex::Literal("configure"), method_11133, 0, "fname", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_2955), Reflex::Literal("addFileToChain"), method_11134, 0, "fname", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("run"), method_11135, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150, type_4598), Reflex::Literal("ParseCommandLine"), method_11136, 0, "argc;argv", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_11137, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_11138, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_11139, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_11140, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_11141, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_11142, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_11143, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_11144, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_11145, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_11146, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_11147, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_11148, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TReconHit -------------------------------
static  void operator_11271( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TReconHit*)o)->operator=)(*(const ::TReconHit*)arg[0]);
  else   (((::TReconHit*)o)->operator=)(*(const ::TReconHit*)arg[0]);
}

static void constructor_11272( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TReconHit(*(const ::TReconHit*)arg[0]);
  else ::new(mem) ::TReconHit(*(const ::TReconHit*)arg[0]);
}

static void constructor_11273( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TReconHit();
  else ::new(mem) ::TReconHit();
}

static void destructor_11274(void*, void * o, const std::vector<void*>&, void *) {
((::TReconHit*)o)->::TReconHit::~TReconHit();
}
static  void method_11275( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TReconHit*)o)->getDetector)());
  else   (((const ::TReconHit*)o)->getDetector)();
}

static  void method_11276( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconHit*)o)->setDetector)(*(int*)arg[0]);
}

static  void method_11277( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TReconHit*)o)->getFace)());
  else   (((const ::TReconHit*)o)->getFace)();
}

static  void method_11278( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconHit*)o)->setFace)(*(int*)arg[0]);
}

static  void method_11279( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::TReconHit*)o)->isHit)());
  else   (((const ::TReconHit*)o)->isHit)();
}

static  void method_11280( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconHit*)o)->setHit)(*(bool*)arg[0]);
}

static  void method_11281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TReconHit*)o)->getPhe)());
  else   (((const ::TReconHit*)o)->getPhe)();
}

static  void method_11282( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconHit*)o)->setPhe)(*(int*)arg[0]);
}

static  void method_11283( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TReconHit*)o)->getPixel)());
  else   (((const ::TReconHit*)o)->getPixel)();
}

static  void method_11284( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconHit*)o)->setPixel)(*(int*)arg[0]);
}

static  void method_11285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TReconHit*)o)->getQ)());
  else   (((const ::TReconHit*)o)->getQ)();
}

static  void method_11286( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconHit*)o)->setQ)(*(double*)arg[0]);
}

static  void method_11287( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TReconHit*)o)->getT)());
  else   (((const ::TReconHit*)o)->getT)();
}

static  void method_11288( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconHit*)o)->setT)(*(double*)arg[0]);
}

static  void method_11289( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TReconHit*)o)->Class)());
  else   (((::TReconHit*)o)->Class)();
}

static  void method_11290( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TReconHit*)o)->Class_Name)());
  else   (((::TReconHit*)o)->Class_Name)();
}

static  void method_11291( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TReconHit*)o)->Class_Version)());
  else   (((::TReconHit*)o)->Class_Version)();
}

static  void method_11292( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TReconHit*)o)->Dictionary)();
}

static  void method_11293( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TReconHit*)o)->IsA)());
  else   (((const ::TReconHit*)o)->IsA)();
}

static  void method_11294( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconHit*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11295( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconHit*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11296( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TReconHit*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TReconHit*)o)->DeclFileName)());
  else   (((::TReconHit*)o)->DeclFileName)();
}

static  void method_11298( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TReconHit*)o)->ImplFileLine)());
  else   (((::TReconHit*)o)->ImplFileLine)();
}

static  void method_11299( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TReconHit*)o)->ImplFileName)());
  else   (((::TReconHit*)o)->ImplFileName)();
}

static  void method_11300( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TReconHit*)o)->DeclFileLine)());
  else   (((::TReconHit*)o)->DeclFileLine)();
}

static void method_newdel_2794( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TReconHit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TReconHit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TReconHit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TReconHit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TReconHit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x50( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TReconHit,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TReconHit -------------------------------
void __TReconHit_db_datamem(Reflex::Class*);
void __TReconHit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TReconHit_datamem_bld(&__TReconHit_db_datamem);
Reflex::GenreflexMemberBuilder __TReconHit_funcmem_bld(&__TReconHit_db_funcmem);
void __TReconHit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TReconHit"), typeid(::TReconHit), sizeof(::TReconHit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TReconHit::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2261, ::Reflex::BaseOffset< ::TReconHit, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18125, type_18126), Reflex::Literal("operator="), operator_11271, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18126), Reflex::Literal("TReconHit"), constructor_11272, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TReconHit"), constructor_11273, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TReconHit"), destructor_11274, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2794, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x50, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TReconHit_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TReconHit_funcmem_bld);
}

//------Delayed data member builder for class TReconHit -------------------
void __TReconHit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_150, Reflex::Literal("face"), OffsetOf(__shadow__::__TReconHit, face), ::Reflex::PUBLIC)
  .AddDataMember(type_150, Reflex::Literal("detector"), OffsetOf(__shadow__::__TReconHit, detector), ::Reflex::PUBLIC)
  .AddDataMember(type_150, Reflex::Literal("pixel"), OffsetOf(__shadow__::__TReconHit, pixel), ::Reflex::PUBLIC)
  .AddDataMember(type_150, Reflex::Literal("nPhe"), OffsetOf(__shadow__::__TReconHit, nPhe), ::Reflex::PUBLIC)
  .AddDataMember(type_247, Reflex::Literal("Q"), OffsetOf(__shadow__::__TReconHit, Q), ::Reflex::PUBLIC)
  .AddDataMember(type_247, Reflex::Literal("T"), OffsetOf(__shadow__::__TReconHit, T), ::Reflex::PUBLIC)
  .AddDataMember(type_661, Reflex::Literal("hit"), OffsetOf(__shadow__::__TReconHit, hit), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class TReconHit -------------------
void __TReconHit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getDetector"), method_11275, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setDetector"), method_11276, 0, "detector", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getFace"), method_11277, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setFace"), method_11278, 0, "face", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_661), Reflex::Literal("isHit"), method_11279, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_661), Reflex::Literal("setHit"), method_11280, 0, "hit", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getPhe"), method_11281, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setPhe"), method_11282, 0, "phe", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("getPixel"), method_11283, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_150), Reflex::Literal("setPixel"), method_11284, 0, "pixel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247), Reflex::Literal("getQ"), method_11285, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_247), Reflex::Literal("setQ"), method_11286, 0, "q", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_247), Reflex::Literal("getT"), method_11287, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_247), Reflex::Literal("setT"), method_11288, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_11289, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_11290, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_11291, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_11292, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_11293, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_11294, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_11295, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_11296, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_11297, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_11298, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_11299, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_11300, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TMarocBasicDriver -------------------------------
static  void operator_11681( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TMarocBasicDriver*)o)->operator=)(*(const ::TMarocBasicDriver*)arg[0]);
  else   (((::TMarocBasicDriver*)o)->operator=)(*(const ::TMarocBasicDriver*)arg[0]);
}

static void constructor_11682( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMarocBasicDriver(*(const ::TMarocBasicDriver*)arg[0]);
  else ::new(mem) ::TMarocBasicDriver(*(const ::TMarocBasicDriver*)arg[0]);
}

static void constructor_11683( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMarocBasicDriver();
  else ::new(mem) ::TMarocBasicDriver();
}

static void destructor_11684(void*, void * o, const std::vector<void*>&, void *) {
((::TMarocBasicDriver*)o)->::TMarocBasicDriver::~TMarocBasicDriver();
}
static  void method_11685( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocBasicDriver*)o)->startOfData)());
  else   (((::TMarocBasicDriver*)o)->startOfData)();
}

static  void method_11686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocBasicDriver*)o)->end)());
  else   (((::TMarocBasicDriver*)o)->end)();
}

static  void method_11687( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocBasicDriver*)o)->process)((::TEvent*)arg[0]));
  else   (((::TMarocBasicDriver*)o)->process)((::TEvent*)arg[0]);
}

static  void method_11688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocBasicDriver*)o)->Class)());
  else   (((::TMarocBasicDriver*)o)->Class)();
}

static  void method_11689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocBasicDriver*)o)->Class_Name)());
  else   (((::TMarocBasicDriver*)o)->Class_Name)();
}

static  void method_11690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TMarocBasicDriver*)o)->Class_Version)());
  else   (((::TMarocBasicDriver*)o)->Class_Version)();
}

static  void method_11691( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TMarocBasicDriver*)o)->Dictionary)();
}

static  void method_11692( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMarocBasicDriver*)o)->IsA)());
  else   (((const ::TMarocBasicDriver*)o)->IsA)();
}

static  void method_11693( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocBasicDriver*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11694( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocBasicDriver*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11695( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMarocBasicDriver*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocBasicDriver*)o)->DeclFileName)());
  else   (((::TMarocBasicDriver*)o)->DeclFileName)();
}

static  void method_11697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocBasicDriver*)o)->ImplFileLine)());
  else   (((::TMarocBasicDriver*)o)->ImplFileLine)();
}

static  void method_11698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMarocBasicDriver*)o)->ImplFileName)());
  else   (((::TMarocBasicDriver*)o)->ImplFileName)();
}

static  void method_11699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMarocBasicDriver*)o)->DeclFileLine)());
  else   (((::TMarocBasicDriver*)o)->DeclFileLine)();
}

static void method_newdel_2840( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TMarocBasicDriver >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TMarocBasicDriver >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TMarocBasicDriver >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TMarocBasicDriver >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TMarocBasicDriver >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x52( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TDriver")), ::Reflex::BaseOffset< ::TMarocBasicDriver,::TDriver >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TMarocBasicDriver,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TMarocBasicDriver -------------------------------
void __TMarocBasicDriver_db_datamem(Reflex::Class*);
void __TMarocBasicDriver_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TMarocBasicDriver_datamem_bld(&__TMarocBasicDriver_db_datamem);
Reflex::GenreflexMemberBuilder __TMarocBasicDriver_funcmem_bld(&__TMarocBasicDriver_db_funcmem);
void __TMarocBasicDriver_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TMarocBasicDriver"), typeid(::TMarocBasicDriver), sizeof(::TMarocBasicDriver), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TMarocBasicDriver::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2618, ::Reflex::BaseOffset< ::TMarocBasicDriver, ::TDriver >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18161, type_18162), Reflex::Literal("operator="), operator_11681, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18162), Reflex::Literal("TMarocBasicDriver"), constructor_11682, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TMarocBasicDriver"), constructor_11683, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TMarocBasicDriver"), destructor_11684, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2840, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x52, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TMarocBasicDriver_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TMarocBasicDriver_funcmem_bld);
}

//------Delayed data member builder for class TMarocBasicDriver -------------------
void __TMarocBasicDriver_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_15661, Reflex::Literal("hMultiplicity0"), OffsetOf(__shadow__::__TMarocBasicDriver, hMultiplicity0), ::Reflex::PRIVATE)
  .AddDataMember(type_15661, Reflex::Literal("hQTot0"), OffsetOf(__shadow__::__TMarocBasicDriver, hQTot0), ::Reflex::PRIVATE)
  .AddDataMember(type_15769, Reflex::Literal("hQTotvsMultiplicity0"), OffsetOf(__shadow__::__TMarocBasicDriver, hQTotvsMultiplicity0), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TMarocBasicDriver -------------------
void __TMarocBasicDriver_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("startOfData"), method_11685, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("end"), method_11686, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150, type_15663), Reflex::Literal("process"), method_11687, 0, "event", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("Class"), method_11688, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("Class_Name"), method_11689, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2548), Reflex::Literal("Class_Version"), method_11690, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("Dictionary"), method_11691, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_789), Reflex::Literal("IsA"), method_11692, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_15639), Reflex::Literal("ShowMembers"), method_11693, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("Streamer"), method_11694, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_4877), Reflex::Literal("StreamerNVirtual"), method_11695, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("DeclFileName"), method_11696, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("ImplFileLine"), method_11697, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("ImplFileName"), method_11698, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_150), Reflex::Literal("DeclFileLine"), method_11699, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<TDriver*,std::allocator<TDriver*> > -------------------------------
static void constructor_12156( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TDriver*>();
  else ::new(mem) ::std::vector<TDriver*>();
}

static void constructor_12157( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TDriver*>(*(const ::std::allocator<TDriver*>*)arg[0]);
  else ::new(mem) ::std::vector<TDriver*>(*(const ::std::allocator<TDriver*>*)arg[0]);
}

static void constructor_12158( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TDriver*>(*(::size_t*)arg[0]);
  else ::new(mem) ::std::vector<TDriver*>(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TDriver*>(*(::size_t*)arg[0],
      *(::TDriver* const*)arg[1]);
  else ::new(mem) ::std::vector<TDriver*>(*(::size_t*)arg[0],
      *(::TDriver* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TDriver*>(*(::size_t*)arg[0],
      *(::TDriver* const*)arg[1],
      *(const ::std::allocator<TDriver*>*)arg[2]);
  else ::new(mem) ::std::vector<TDriver*>(*(::size_t*)arg[0],
      *(::TDriver* const*)arg[1],
      *(const ::std::allocator<TDriver*>*)arg[2]);
  }
}

static void constructor_12159( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TDriver*>(*(const ::std::vector<TDriver*>*)arg[0]);
  else ::new(mem) ::std::vector<TDriver*>(*(const ::std::vector<TDriver*>*)arg[0]);
}

static void destructor_12160(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<TDriver*>*)o)->::std::vector<TDriver*>::~vector();
}
static  void operator_12161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TDriver*>*)o)->operator=)(*(const ::std::vector<TDriver*>*)arg[0]);
  else   (((::std::vector<TDriver*>*)o)->operator=)(*(const ::std::vector<TDriver*>*)arg[0]);
}

static  void method_12162( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TDriver*>*)o)->assign)(*(::size_t*)arg[0],
    *(::TDriver* const*)arg[1]);
}

static  void method_12163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >)((((::std::vector<TDriver*>*)o)->begin)());
  else   (((::std::vector<TDriver*>*)o)->begin)();
}

static  void method_12164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TDriver* const*,std::vector<TDriver*> >)((((const ::std::vector<TDriver*>*)o)->begin)());
  else   (((const ::std::vector<TDriver*>*)o)->begin)();
}

static  void method_12165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >)((((::std::vector<TDriver*>*)o)->end)());
  else   (((::std::vector<TDriver*>*)o)->end)();
}

static  void method_12166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TDriver* const*,std::vector<TDriver*> >)((((const ::std::vector<TDriver*>*)o)->end)());
  else   (((const ::std::vector<TDriver*>*)o)->end)();
}

static  void method_12171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<TDriver*>*)o)->size)());
  else   (((const ::std::vector<TDriver*>*)o)->size)();
}

static  void method_12172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<TDriver*>*)o)->max_size)());
  else   (((const ::std::vector<TDriver*>*)o)->max_size)();
}

static  void method_12173( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<TDriver*>*)o)->resize)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<TDriver*>*)o)->resize)(*(::size_t*)arg[0],
      (::TDriver*)arg[1]);
  }
}

static  void method_12174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<TDriver*>*)o)->capacity)());
  else   (((const ::std::vector<TDriver*>*)o)->capacity)();
}

static  void method_12175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<TDriver*>*)o)->empty)());
  else   (((const ::std::vector<TDriver*>*)o)->empty)();
}

static  void method_12176( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TDriver*>*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void operator_12177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TDriver*>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((::std::vector<TDriver*>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void operator_12178( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TDriver*>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((const ::std::vector<TDriver*>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_12180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TDriver*>*)o)->at)(*(::size_t*)arg[0]);
  else   (((::std::vector<TDriver*>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_12181( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TDriver*>*)o)->at)(*(::size_t*)arg[0]);
  else   (((const ::std::vector<TDriver*>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_12182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TDriver*>*)o)->front)();
  else   (((::std::vector<TDriver*>*)o)->front)();
}

static  void method_12183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TDriver*>*)o)->front)();
  else   (((const ::std::vector<TDriver*>*)o)->front)();
}

static  void method_12184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TDriver*>*)o)->back)();
  else   (((::std::vector<TDriver*>*)o)->back)();
}

static  void method_12185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TDriver*>*)o)->back)();
  else   (((const ::std::vector<TDriver*>*)o)->back)();
}

static  void method_12186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<TDriver*>*)o)->data)());
  else   (((::std::vector<TDriver*>*)o)->data)();
}

static  void method_12187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<TDriver*>*)o)->data)());
  else   (((const ::std::vector<TDriver*>*)o)->data)();
}

static  void method_12188( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TDriver*>*)o)->push_back)(*(::TDriver* const*)arg[0]);
}

static  void method_12189( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TDriver*>*)o)->pop_back)();
}

static  void method_12190( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >)((((::std::vector<TDriver*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >*)arg[0],
    *(::TDriver* const*)arg[1]));
  else   (((::std::vector<TDriver*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >*)arg[0],
    *(::TDriver* const*)arg[1]);
}

static  void method_12191( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TDriver*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >*)arg[0],
    *(::size_t*)arg[1],
    *(::TDriver* const*)arg[2]);
}

static  void method_12192( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >)((((::std::vector<TDriver*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >*)arg[0]));
  else   (((::std::vector<TDriver*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >*)arg[0]);
}

static  void method_12193( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >)((((::std::vector<TDriver*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >*)arg[1]));
  else   (((::std::vector<TDriver*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TDriver**,std::vector<TDriver*> >*)arg[1]);
}

static  void method_12194( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TDriver*>*)o)->swap)(*(::std::vector<TDriver*>*)arg[0]);
}

static  void method_12195( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TDriver*>*)o)->clear)();
}

static void method_newdel_2913( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<TDriver*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<TDriver*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<TDriver*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<TDriver*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<TDriver*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x54( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TDriver*,std::allocator<TDriver*> >")), ::Reflex::BaseOffset< ::std::vector<TDriver*>,::std::_Vector_base<TDriver*,std::allocator<TDriver*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x55( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<TDriver*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<TDriver*> >::Generate();
}

//------Dictionary for class vector<TDriver*,std::allocator<TDriver*> > -------------------------------
void __std__vector_TDriverp__db_datamem(Reflex::Class*);
void __std__vector_TDriverp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_TDriverp__datamem_bld(&__std__vector_TDriverp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_TDriverp__funcmem_bld(&__std__vector_TDriverp__db_funcmem);
void __std__vector_TDriverp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<TDriver*>"), typeid(::std::vector<TDriver*>), sizeof(::std::vector<TDriver*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2873, ::Reflex::BaseOffset< ::std::vector<TDriver*>, ::std::_Vector_base<TDriver*,std::allocator<TDriver*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_9059, Reflex::Literal("std::vector<TDriver*>::_Alloc_value_type"))
  .AddTypedef(type_2873, Reflex::Literal("std::vector<TDriver*>::_Base"))
  .AddTypedef(type_3221, Reflex::Literal("std::vector<TDriver*>::_Tp_alloc_type"))
  .AddTypedef(type_9059, Reflex::Literal("std::vector<TDriver*>::value_type"))
  .AddTypedef(type_12141, Reflex::Literal("std::vector<TDriver*>::pointer"))
  .AddTypedef(type_12143, Reflex::Literal("std::vector<TDriver*>::const_pointer"))
  .AddTypedef(type_12145, Reflex::Literal("std::vector<TDriver*>::reference"))
  .AddTypedef(type_12147, Reflex::Literal("std::vector<TDriver*>::const_reference"))
  .AddTypedef(type_8389, Reflex::Literal("std::vector<TDriver*>::iterator"))
  .AddTypedef(type_8390, Reflex::Literal("std::vector<TDriver*>::const_iterator"))
  .AddTypedef(type_3289, Reflex::Literal("std::vector<TDriver*>::const_reverse_iterator"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<TDriver*>::reverse_iterator"))
  .AddTypedef(type_1961, Reflex::Literal("std::vector<TDriver*>::size_type"))
  .AddTypedef(type_759, Reflex::Literal("std::vector<TDriver*>::difference_type"))
  .AddTypedef(type_3221, Reflex::Literal("std::vector<TDriver*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12156, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18196), Reflex::Literal("vector"), constructor_12157, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1961, type_12147, type_18196), Reflex::Literal("vector"), constructor_12158, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18323), Reflex::Literal("vector"), constructor_12159, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12160, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2913, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x54, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x55, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_TDriverp__funcmem_bld);
}

//------Delayed data member builder for class vector<TDriver*,std::allocator<TDriver*> > -------------------
void __std__vector_TDriverp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<TDriver*,std::allocator<TDriver*> > -------------------
void __std__vector_TDriverp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18324, type_18323), Reflex::Literal("operator="), operator_12161, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_1961, type_12147), Reflex::Literal("assign"), method_12162, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8389), Reflex::Literal("begin"), method_12163, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8390), Reflex::Literal("begin"), method_12164, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8389), Reflex::Literal("end"), method_12165, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8390), Reflex::Literal("end"), method_12166, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1961), Reflex::Literal("size"), method_12171, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1961), Reflex::Literal("max_size"), method_12172, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_1961, type_9059), Reflex::Literal("resize"), method_12173, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1961), Reflex::Literal("capacity"), method_12174, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_661), Reflex::Literal("empty"), method_12175, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_1961), Reflex::Literal("reserve"), method_12176, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12145, type_1961), Reflex::Literal("operator[]"), operator_12177, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12147, type_1961), Reflex::Literal("operator[]"), operator_12178, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12145, type_1961), Reflex::Literal("at"), method_12180, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12147, type_1961), Reflex::Literal("at"), method_12181, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12145), Reflex::Literal("front"), method_12182, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12147), Reflex::Literal("front"), method_12183, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12145), Reflex::Literal("back"), method_12184, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12147), Reflex::Literal("back"), method_12185, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12141), Reflex::Literal("data"), method_12186, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12143), Reflex::Literal("data"), method_12187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_12147), Reflex::Literal("push_back"), method_12188, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("pop_back"), method_12189, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8389, type_8389, type_12147), Reflex::Literal("insert"), method_12190, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_8389, type_1961, type_12147), Reflex::Literal("insert"), method_12191, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8389, type_8389), Reflex::Literal("erase"), method_12192, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8389, type_8389, type_8389), Reflex::Literal("erase"), method_12193, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210, type_18324), Reflex::Literal("swap"), method_12194, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1210), Reflex::Literal("clear"), method_12195, 0, 0, ::Reflex::PUBLIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __TChargeAnalysisDriver_dict(); 
      __TTofpetSetupHandlerDriver_dict(); 
      __TLikelihoodReconDriver_dict(); 
      __TReconInput_dict(); 
      __TEventMarkerDriver_dict(); 
      __TTofpetDummyAnalysisDriver_dict(); 
      __TChargeAnalysisPoissonDriver_dict(); 
      __TRootSaveDriver_dict(); 
      __TLikelihoodCalculatorIdeal_dict(); 
      __TMatrixWriterDriver_dict(); 
      __TTofpetTimeAnalysisDriver_dict(); 
      __TJobManager_dict(); 
      __TMatrixInterpreterDriver_dict(); 
      __TLikelihoodComputationDriver_dict(); 
      __TMarocSetupHandlerDriver_dict(); 
      __TMCDataReaderDriver_dict(); 
      __TMarocDataReaderDriver_dict(); 
      __TMatrixReconDriver_dict(); 
      __TTofpetThresholdCalibrationDriver_dict(); 
      __TDriver_dict(); 
      __TLikelihoodCalculatorMaroc1_dict(); 
      __TLikelihoodCalculator_dict(); 
      __TAnalysis_dict(); 
      __TReconHit_dict(); 
      __TMarocBasicDriver_dict(); 
      __std__vector_TDriverp__dict(); 
    }
    ~Dictionaries() {
      type_106.Unload(); // class TChargeAnalysisDriver 
      type_140.Unload(); // class TTofpetSetupHandlerDriver 
      type_228.Unload(); // class TLikelihoodReconDriver 
      type_523.Unload(); // class TReconInput 
      type_587.Unload(); // class TEventMarkerDriver 
      type_742.Unload(); // class TTofpetDummyAnalysisDriver 
      type_835.Unload(); // class TChargeAnalysisPoissonDriver 
      type_1138.Unload(); // class TRootSaveDriver 
      type_1170.Unload(); // class TLikelihoodCalculatorIdeal 
      type_1226.Unload(); // class TMatrixWriterDriver 
      type_1233.Unload(); // class TTofpetTimeAnalysisDriver 
      type_1365.Unload(); // class TJobManager 
      type_1435.Unload(); // class TMatrixInterpreterDriver 
      type_1518.Unload(); // class TLikelihoodComputationDriver 
      type_1529.Unload(); // class TMarocSetupHandlerDriver 
      type_1849.Unload(); // class TMCDataReaderDriver 
      type_2025.Unload(); // class TMarocDataReaderDriver 
      type_2124.Unload(); // class TMatrixReconDriver 
      type_2533.Unload(); // class TTofpetThresholdCalibrationDriver 
      type_2618.Unload(); // class TDriver 
      type_2628.Unload(); // class TLikelihoodCalculatorMaroc1 
      type_2679.Unload(); // class TLikelihoodCalculator 
      type_2738.Unload(); // class TAnalysis 
      type_2794.Unload(); // class TReconHit 
      type_2840.Unload(); // class TMarocBasicDriver 
      type_2913.Unload(); // class std::vector<TDriver*> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
