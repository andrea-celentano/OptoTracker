// Generated at Wed Nov 16 23:36:35 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/usr/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/usr/bin/c++"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic "
  GCCXML_EXECUTABLE="/usr/bin/gccxml_cc1plus"
  GCCXML_CPP="/usr/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__FLT_MIN__='1.17549435e-38F' -D__CHAR_BIT__='8' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='4.9406564584124654e-324' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__LP64__='1' -D__GNUC_PATCHLEVEL__='7' -D__DEC64_MAX_EXP__='385' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__unix='1' -D__LDBL_MAX_EXP__='16384' -D__linux__='1' -D__SCHAR_MAX__='127' -D__DBL_DIG__='15' -D_FORTIFY_SOURCE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209290e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__SIZEOF_LONG__='8' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='1.7976931348623157e+308' -D__DBL_HAS_INFINITY__='1' -D__DEC32_MIN_EXP__='(-94)' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__DBL_MIN__='2.2250738585072014e-308' -D__FLT_MIN_10_EXP__='(-37)' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__DBL_HAS_DENORM__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.4.7 20120313 (Red Hat 4.4.7-17)"' -D__DEC64_EPSILON__='1E-15DD' -D__DEC128_MIN_EXP__='(-6142)' -Dunix='1' -D__SIZE_TYPE__='long unsigned int' -D__ELF__='1' -D__FLT_RADIX__='2' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__GNUC_RH_RELEASE__='17' -D__k8='1' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__DEC64_MANT_DIG__='16' -D__DEC32_MAX_EXP__='97' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__k8__='1' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__DEC64_MIN_EXP__='(-382)' -D__FLT_DIG__='6' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__FLT_MAX_EXP__='128' -D__DBL_MANT_DIG__='53' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__SSP__='1' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='2.2204460492503131e-16' -D_LP64='1' -D__SIZEOF_WCHAR_T__='4' -D__DEC_EVAL_METHOD__='2' -D__INTMAX_MAX__='9223372036854775807L' -D__FLT_DENORM_MIN__='1.40129846e-45F' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282347e+38F' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='4' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__GNUC_GNU_INLINE__='1' -D_GNU_SOURCE='1' -iwrapper"/usr/share/gccxml-0.9/GCC/4.4" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/backward" -isystem"/usr/local/include" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/usr/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.4.7 20120313 (Red Hat 4.4.7-17)
Copyright (C) 2010 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/work/OptoTracker/software/packages/Common/include/CommonClasses.hh"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::Type type_117 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_841 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_2200 = ::Reflex::TypeBuilder(Reflex::Literal("TF1"));
  ::Reflex::Type type_158 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_529 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1000 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_160 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_195 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_1648 = ::Reflex::TypeBuilder(Reflex::Literal("TClass"));
  ::Reflex::Type type_700 = ::Reflex::TypeBuilder(Reflex::Literal("TBuffer"));
  ::Reflex::Type type_2215 = ::Reflex::TypeBuilder(Reflex::Literal("TNamed"));
  ::Reflex::Type type_2218 = ::Reflex::TypeBuilder(Reflex::Literal("TEvent"));
  ::Reflex::Type type_1879 = ::Reflex::TypeBuilder(Reflex::Literal("TObject"));
  ::Reflex::Type type_966 = ::Reflex::TypeBuilder(Reflex::Literal("TMCTruth"));
  ::Reflex::Type type_1716 = ::Reflex::TypeBuilder(Reflex::Literal("TVector3"));
  ::Reflex::Type type_51 = ::Reflex::TypeBuilder(Reflex::Literal("TXMLHandler"));
  ::Reflex::Type type_1875 = ::Reflex::TypeBuilder(Reflex::Literal("TDetector"));
  ::Reflex::Type type_2013 = ::Reflex::TypeBuilder(Reflex::Literal("TObjArray"));
  ::Reflex::Type type_1278 = ::Reflex::TypeBuilder(Reflex::Literal("TXMLEngine"));
  ::Reflex::Type type_605 = ::Reflex::TypeBuilder(Reflex::Literal("reconControl"));
  ::Reflex::Type type_1445 = ::Reflex::TypeBuilder(Reflex::Literal("TMCParticle"));
  ::Reflex::Type type_1019 = ::Reflex::TypeBuilder(Reflex::Literal("TEventHeader"));
  ::Reflex::Type type_1846 = ::Reflex::TypeBuilder(Reflex::Literal("TClonesArray"));
  ::Reflex::Type type_138 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_1286 = ::Reflex::TypeBuilder(Reflex::Literal("TLorentzVector"));
  ::Reflex::Type type_1200 = ::Reflex::TypeBuilder(Reflex::Literal("TDetectorUtils"));
  ::Reflex::Type type_2594 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<int>"));
  ::Reflex::Type type_346 = ::Reflex::TypeBuilder(Reflex::Literal("TMemberInspector"));
  ::Reflex::Type type_2328 = ::Reflex::TypeBuilder(Reflex::Literal("TNamedContainer"));
  ::Reflex::Type type_2568 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,int>"));
  ::Reflex::Type type_1489 = ::Reflex::TypeBuilder(Reflex::Literal("TRealSetupHandler"));
  ::Reflex::Type type_2664 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<driver>"));
  ::Reflex::Type type_2667 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_2566 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,double>"));
  ::Reflex::Type type_2408 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_2666 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<TClonesArray*>"));
  ::Reflex::Type type_2670 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const int,double>"));
  ::Reflex::Type type_2567 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::pair<int,int>,int>"));
  ::Reflex::Type type_2742 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const int,double> >"));
  ::Reflex::Type type_2421 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const int,double> >"));
  ::Reflex::Type type_2717 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const int,double> >"));
  ::Reflex::Type type_2673 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,double> >,bool>"));
  ::Reflex::Type type_2806 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const int,double> > >"));
  ::Reflex::Type type_2805 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const int,double> > >"));
  ::Reflex::Type type_2672 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,double> >,std::_Rb_tree_iterator<std::pair<const int,double> > >"));
  ::Reflex::Type type_2671 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const int,double> >,std::_Rb_tree_const_iterator<std::pair<const int,double> > >"));
  ::Reflex::Type type_2689 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<int,std::pair<const int,double>,std::_Select1st<std::pair<const int,double> >,std::less<int>,std::allocator<std::pair<const int,double> > >"));
  ::Reflex::Type type_9993 = ::Reflex::PointerBuilder(type_1278);
  ::Reflex::Type type_2417 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2408);
  ::Reflex::Type type_391 = ::Reflex::PointerBuilder(type_1000);
  ::Reflex::Type type_1268 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("XMLDocPointer_t"), type_391);
  ::Reflex::Type type_1243 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("XMLNodePointer_t"), type_391);
  ::Reflex::Type type_9994 = ::Reflex::ReferenceBuilder(type_51);
  ::Reflex::Type type_51c = ::Reflex::ConstBuilder(type_51);
  ::Reflex::Type type_9995 = ::Reflex::ReferenceBuilder(type_51c);
  ::Reflex::Type type_1398 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reconControl_struct"), type_605);
  ::Reflex::Type type_728 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Int_t"), type_117);
  ::Reflex::Type type_640 = ::Reflex::PointerBuilder(type_1648);
  ::Reflex::Type type_841c = ::Reflex::ConstBuilder(type_841);
  ::Reflex::Type type_2950 = ::Reflex::PointerBuilder(type_841c);
  ::Reflex::Type type_2074 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Version_t"), type_160);
  ::Reflex::Type type_9996 = ::Reflex::ReferenceBuilder(type_346);
  ::Reflex::Type type_3178 = ::Reflex::ReferenceBuilder(type_700);
  ::Reflex::Type type_10189 = ::Reflex::PointerBuilder(type_1286);
  ::Reflex::Type type_10190 = ::Reflex::ReferenceBuilder(type_966);
  ::Reflex::Type type_966c = ::Reflex::ConstBuilder(type_966);
  ::Reflex::Type type_10191 = ::Reflex::ReferenceBuilder(type_966c);
  ::Reflex::Type type_10199 = ::Reflex::ReferenceBuilder(type_1019);
  ::Reflex::Type type_1019c = ::Reflex::ConstBuilder(type_1019);
  ::Reflex::Type type_10200 = ::Reflex::ReferenceBuilder(type_1019c);
  ::Reflex::Type type_10246 = ::Reflex::PointerBuilder(type_1875);
  ::Reflex::Type type_10247 = ::Reflex::PointerBuilder(type_2200);
  ::Reflex::Type type_10248 = ::Reflex::ReferenceBuilder(type_1200);
  ::Reflex::Type type_1200c = ::Reflex::ConstBuilder(type_1200);
  ::Reflex::Type type_10249 = ::Reflex::ReferenceBuilder(type_1200c);
  ::Reflex::Type type_1716c = ::Reflex::ConstBuilder(type_1716);
  ::Reflex::Type type_5591 = ::Reflex::ReferenceBuilder(type_1716c);
  ::Reflex::Type type_10734 = ::Reflex::ReferenceBuilder(type_1445);
  ::Reflex::Type type_1445c = ::Reflex::ConstBuilder(type_1445);
  ::Reflex::Type type_10735 = ::Reflex::ReferenceBuilder(type_1445c);
  ::Reflex::Type type_1189 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Option_t"), type_841c);
  ::Reflex::Type type_10090 = ::Reflex::PointerBuilder(type_1189);
  ::Reflex::Type type_11772 = ::Reflex::ArrayBuilder(type_2566, 256);
  ::Reflex::Type type_10736 = ::Reflex::ArrayBuilder(type_11772, 6);
  ::Reflex::Type type_10737 = ::Reflex::ReferenceBuilder(type_1489);
  ::Reflex::Type type_1489c = ::Reflex::ConstBuilder(type_1489);
  ::Reflex::Type type_10738 = ::Reflex::ReferenceBuilder(type_1489c);
  ::Reflex::Type type_10903 = ::Reflex::ArrayBuilder(type_117, 6);
  ::Reflex::Type type_11796 = ::Reflex::ArrayBuilder(type_117, 256);
  ::Reflex::Type type_10904 = ::Reflex::ArrayBuilder(type_11796, 6);
  ::Reflex::Type type_11797 = ::Reflex::ArrayBuilder(type_2417, 256);
  ::Reflex::Type type_10905 = ::Reflex::ArrayBuilder(type_11797, 6);
  ::Reflex::Type type_11798 = ::Reflex::ArrayBuilder(type_195, 256);
  ::Reflex::Type type_10906 = ::Reflex::ArrayBuilder(type_11798, 6);
  ::Reflex::Type type_10907 = ::Reflex::ArrayBuilder(type_195, 6);
  ::Reflex::Type type_11799 = ::Reflex::ArrayBuilder(type_2667, 256);
  ::Reflex::Type type_10908 = ::Reflex::ArrayBuilder(type_11799, 6);
  ::Reflex::Type type_10909 = ::Reflex::ReferenceBuilder(type_1875);
  ::Reflex::Type type_1875c = ::Reflex::ConstBuilder(type_1875);
  ::Reflex::Type type_10910 = ::Reflex::ReferenceBuilder(type_1875c);
  ::Reflex::Type type_10278 = ::Reflex::ReferenceBuilder(type_117);
  ::Reflex::Type type_10974 = ::Reflex::PointerBuilder(type_1019);
  ::Reflex::Type type_10975 = ::Reflex::ReferenceBuilder(type_2218);
  ::Reflex::Type type_2218c = ::Reflex::ConstBuilder(type_2218);
  ::Reflex::Type type_10976 = ::Reflex::ReferenceBuilder(type_2218c);
  ::Reflex::Type type_9314 = ::Reflex::PointerBuilder(type_1879);
  ::Reflex::Type type_7968 = ::Reflex::PointerBuilder(type_1846);
  ::Reflex::Type type_10983 = ::Reflex::ReferenceBuilder(type_2328);
  ::Reflex::Type type_2328c = ::Reflex::ConstBuilder(type_2328);
  ::Reflex::Type type_10984 = ::Reflex::ReferenceBuilder(type_2328c);
  ::Reflex::Type type_7511 = ::Reflex::PointerBuilder(type_2670);
  ::Reflex::Type type_2670c = ::Reflex::ConstBuilder(type_2670);
  ::Reflex::Type type_7513 = ::Reflex::PointerBuilder(type_2670c);
  ::Reflex::Type type_7515 = ::Reflex::ReferenceBuilder(type_2670);
  ::Reflex::Type type_7517 = ::Reflex::ReferenceBuilder(type_2670c);
  ::Reflex::Type type_1630 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_138);
  ::Reflex::Type type_615 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("ptrdiff_t"), type_158);
  ::Reflex::Type type_2594c = ::Reflex::ConstBuilder(type_2594);
  ::Reflex::Type type_11329 = ::Reflex::ReferenceBuilder(type_2594c);
  ::Reflex::Type type_2742c = ::Reflex::ConstBuilder(type_2742);
  ::Reflex::Type type_11330 = ::Reflex::ReferenceBuilder(type_2742c);
  ::Reflex::Type type_2566c = ::Reflex::ConstBuilder(type_2566);
  ::Reflex::Type type_11331 = ::Reflex::ReferenceBuilder(type_2566c);
  ::Reflex::Type type_11332 = ::Reflex::ReferenceBuilder(type_2566);
  ::Reflex::Type type_8041 = ::Reflex::ReferenceBuilder(type_195);
  ::Reflex::Type type_117c = ::Reflex::ConstBuilder(type_117);
  ::Reflex::Type type_9401 = ::Reflex::ReferenceBuilder(type_117c);
  ::Reflex::Type type_195c = ::Reflex::ConstBuilder(type_195);
  ::Reflex::Type type_8043 = ::Reflex::ReferenceBuilder(type_195c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __TXMLHandler
#undef __TXMLHandler
#endif
class __TXMLHandler : public ::TObject {
  public:
  __TXMLHandler();
  virtual ~__TXMLHandler() throw();
  void* m_xml;
  ::std::string m_xmlFile;
  void* m_xmldoc;
  void* m_mainnode;
};
#ifdef __TMCTruth
#undef __TMCTruth
#endif
class __TMCTruth : public ::TNamed {
  public:
  __TMCTruth();
  virtual ~__TMCTruth() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  int m_pid;
  void* m_P0;
  void* m_x0;
  void* m_xin;
  void* m_xout;
  double m_edep;
  double m_edepVis;
  double m_pathLength;
};
#ifdef __TEventHeader
#undef __TEventHeader
#endif
class __TEventHeader : public ::TObject {
  public:
  __TEventHeader();
  virtual ~__TEventHeader() throw();
  int m_eventNumber;
  int m_runNumber;
};
#ifdef __TDetectorUtils
#undef __TDetectorUtils
#endif
class __TDetectorUtils : public ::TObject {
  public:
  __TDetectorUtils();
  virtual ~__TDetectorUtils() throw();
  void* m_detector;
  void* m_SinglePhotonTimeProbKernel;
  void* m_TrackChargeKernel;
};
#ifdef __TMCParticle
#undef __TMCParticle
#endif
class __TMCParticle : public ::TObject {
  public:
  __TMCParticle();
  virtual ~__TMCParticle() throw();
  int m_pid;
  int m_id;
  int m_parentId;
  double m_edep;
  double m_edepVis;
  void* m_x0;
  void* m_P0;
};
#ifdef __TRealSetupHandler
#undef __TRealSetupHandler
#endif
class __TRealSetupHandler : public ::TObject {
  public:
  __TRealSetupHandler();
  virtual ~__TRealSetupHandler() throw();
  ::std::map<int,int> m_reconstructionDetFace;
  ::std::map<int,int> m_reconstructionDetID;
  ::std::map<std::pair<int,int>,int> m_reconstructionRealDet;
  ::std::map<int,double> m_PixelGain1[6][256];
  ::std::map<int,double> m_PixelGain2[6][256];
  ::std::map<int,double> m_PixelGain3[6][256];
  int nRealDet;
  int m_thisReconFace;
  int m_thisReconDetID;
  int m_thisRealDetID;
  int m_thisPixel;
  int m_thisPixelFirst;
  int m_thisPixelLast;
  int m_thisGainEntry;
  double m_thisGainVal;
};
#ifdef __TDetector
#undef __TDetector
#endif
class __TDetector : public ::TObject {
  public:
  __TDetector();
  virtual ~__TDetector() throw();
  double LY;
  double fastScintTime;
  double rIndex;
  double scintSizeX;
  double scintSizeY;
  double scintSizeZ;
  int Ndet[6];
  int detPresent[6][256];
  ::std::string detName[6][256];
  double detSizeX[6][256];
  double detSizeY[6][256];
  double detPixelSizeX[6][256];
  double detPixelSizeY[6][256];
  int detNpixelsX[6][256];
  int detNpixelsY[6][256];
  double detQE[6][256];
  double detReflectivity[6][256];
  double detTimeRes[6][256];
  int detPlacementAlt[6][256];
  double detCenterX[6][256];
  double detCenterY[6][256];
  double detRotation[6][256];
  double detCouplingRIndex[6][256];
  double detCouplingThickness[6][256];
  double faceReflectivity[6];
  ::std::vector<double> posPixelX[6][256];
  ::std::vector<double> posPixelY[6][256];
  ::std::vector<double> posPixelZ[6][256];
  ::std::string m_name;
  int m_totPixels;
  int m_totDetectors;
};
#ifdef __TEvent
#undef __TEvent
#endif
class __TEvent : public ::TObject {
  public:
  __TEvent();
  virtual ~__TEvent() throw();
  void* m_eventHeader;
  ::TObjArray m_objects;
  ::std::vector<TClonesArray*> m_collections;
};
#ifdef __TNamedContainer
#undef __TNamedContainer
#endif
class __TNamedContainer : public ::TNamed {
  public:
  __TNamedContainer();
  virtual ~__TNamedContainer() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  void* m_object;
};
#ifdef __std__map_int_double_
#undef __std__map_int_double_
#endif
class __std__map_int_double_ {
  public:
  __std__map_int_double_();
  ::std::_Rb_tree<int,std::pair<const int,double>,std::_Select1st<std::pair<const int,double> >,std::less<int>,std::allocator<std::pair<const int,double> > > _M_t;
};
}


#endif // __CINT__
namespace {
} // unnamed namespace

#ifndef G__DICTIONARY
# define G__DICTIONARY
#endif
#include "TClass.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "RtypesImp.h"
#include "TIsAProxy.h"
atomic_TClass_ptr TXMLHandler::fgIsA(0);
TClass* ::TXMLHandler::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TXMLHandler");
   }
   return fgIsA;
}
const char * ::TXMLHandler::Class_Name() {return "TXMLHandler";}
void ::TXMLHandler::Dictionary() {}
const char *::TXMLHandler::ImplFileName() {return "";}
int ::TXMLHandler::ImplFileLine() {return 1;}
void ::TXMLHandler::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TXMLHandler::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_xml", &m_xml);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_xmlFile", &m_xmlFile);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_xmldoc", &m_xmldoc);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_mainnode", &m_mainnode);
   TObject::ShowMembers(R__insp);
}
void ::TXMLHandler::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TXMLHandler::Class(),this);
   } else {
      b.WriteClassBuffer(::TXMLHandler::Class(),this);
   }
}

atomic_TClass_ptr TMCTruth::fgIsA(0);
TClass* ::TMCTruth::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TMCTruth");
   }
   return fgIsA;
}
const char * ::TMCTruth::Class_Name() {return "TMCTruth";}
void ::TMCTruth::Dictionary() {}
const char *::TMCTruth::ImplFileName() {return "";}
int ::TMCTruth::ImplFileLine() {return 1;}
void ::TMCTruth::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TMCTruth::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_pid", &m_pid);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_P0", &m_P0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_x0", &m_x0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_xin", &m_xin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_xout", &m_xout);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_edep", &m_edep);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_edepVis", &m_edepVis);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_pathLength", &m_pathLength);
   TNamed::ShowMembers(R__insp);
}
void ::TMCTruth::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TMCTruth::Class(),this);
   } else {
      b.WriteClassBuffer(::TMCTruth::Class(),this);
   }
}

atomic_TClass_ptr TEventHeader::fgIsA(0);
TClass* ::TEventHeader::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TEventHeader");
   }
   return fgIsA;
}
const char * ::TEventHeader::Class_Name() {return "TEventHeader";}
void ::TEventHeader::Dictionary() {}
const char *::TEventHeader::ImplFileName() {return "";}
int ::TEventHeader::ImplFileLine() {return 1;}
void ::TEventHeader::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TEventHeader::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_eventNumber", &m_eventNumber);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_runNumber", &m_runNumber);
   TObject::ShowMembers(R__insp);
}
void ::TEventHeader::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TEventHeader::Class(),this);
   } else {
      b.WriteClassBuffer(::TEventHeader::Class(),this);
   }
}

atomic_TClass_ptr TDetectorUtils::fgIsA(0);
TClass* ::TDetectorUtils::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TDetectorUtils");
   }
   return fgIsA;
}
const char * ::TDetectorUtils::Class_Name() {return "TDetectorUtils";}
void ::TDetectorUtils::Dictionary() {}
const char *::TDetectorUtils::ImplFileName() {return "";}
int ::TDetectorUtils::ImplFileLine() {return 1;}
void ::TDetectorUtils::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TDetectorUtils::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_detector", &m_detector);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_SinglePhotonTimeProbKernel", &m_SinglePhotonTimeProbKernel);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_TrackChargeKernel", &m_TrackChargeKernel);
   TObject::ShowMembers(R__insp);
}
void ::TDetectorUtils::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TDetectorUtils::Class(),this);
   } else {
      b.WriteClassBuffer(::TDetectorUtils::Class(),this);
   }
}

atomic_TClass_ptr TMCParticle::fgIsA(0);
TClass* ::TMCParticle::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TMCParticle");
   }
   return fgIsA;
}
const char * ::TMCParticle::Class_Name() {return "TMCParticle";}
void ::TMCParticle::Dictionary() {}
const char *::TMCParticle::ImplFileName() {return "";}
int ::TMCParticle::ImplFileLine() {return 1;}
void ::TMCParticle::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TMCParticle::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_pid", &m_pid);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_id", &m_id);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_parentId", &m_parentId);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_edep", &m_edep);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_edepVis", &m_edepVis);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_x0", &m_x0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_P0", &m_P0);
   TObject::ShowMembers(R__insp);
}
void ::TMCParticle::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TMCParticle::Class(),this);
   } else {
      b.WriteClassBuffer(::TMCParticle::Class(),this);
   }
}

atomic_TClass_ptr TRealSetupHandler::fgIsA(0);
TClass* ::TRealSetupHandler::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TRealSetupHandler");
   }
   return fgIsA;
}
const char * ::TRealSetupHandler::Class_Name() {return "TRealSetupHandler";}
void ::TRealSetupHandler::Dictionary() {}
const char *::TRealSetupHandler::ImplFileName() {return "";}
int ::TRealSetupHandler::ImplFileLine() {return 1;}
void ::TRealSetupHandler::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TRealSetupHandler::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_reconstructionDetFace", &m_reconstructionDetFace);
   R__insp.InspectMember("std::map<int,int>", (void*)&m_reconstructionDetFace, "m_reconstructionDetFace.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_reconstructionDetID", &m_reconstructionDetID);
   R__insp.InspectMember("std::map<int,int>", (void*)&m_reconstructionDetID, "m_reconstructionDetID.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_reconstructionRealDet", &m_reconstructionRealDet);
   R__insp.InspectMember("std::map<std::pair<int,int>,int>", (void*)&m_reconstructionRealDet, "m_reconstructionRealDet.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_PixelGain1[6][256]", &m_PixelGain1);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_PixelGain2[6][256]", &m_PixelGain2);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_PixelGain3[6][256]", &m_PixelGain3);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "nRealDet", &nRealDet);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_thisReconFace", &m_thisReconFace);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_thisReconDetID", &m_thisReconDetID);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_thisRealDetID", &m_thisRealDetID);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_thisPixel", &m_thisPixel);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_thisPixelFirst", &m_thisPixelFirst);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_thisPixelLast", &m_thisPixelLast);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_thisGainEntry", &m_thisGainEntry);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_thisGainVal", &m_thisGainVal);
   TObject::ShowMembers(R__insp);
}
void ::TRealSetupHandler::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TRealSetupHandler::Class(),this);
   } else {
      b.WriteClassBuffer(::TRealSetupHandler::Class(),this);
   }
}

atomic_TClass_ptr TDetector::fgIsA(0);
TClass* ::TDetector::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TDetector");
   }
   return fgIsA;
}
const char * ::TDetector::Class_Name() {return "TDetector";}
void ::TDetector::Dictionary() {}
const char *::TDetector::ImplFileName() {return "";}
int ::TDetector::ImplFileLine() {return 1;}
void ::TDetector::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TDetector::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "LY", &LY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fastScintTime", &fastScintTime);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "rIndex", &rIndex);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "scintSizeX", &scintSizeX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "scintSizeY", &scintSizeY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "scintSizeZ", &scintSizeZ);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "Ndet[6]", &Ndet);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detPresent[6][256]", &detPresent);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detName[6][256]", &detName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detSizeX[6][256]", &detSizeX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detSizeY[6][256]", &detSizeY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detPixelSizeX[6][256]", &detPixelSizeX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detPixelSizeY[6][256]", &detPixelSizeY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detNpixelsX[6][256]", &detNpixelsX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detNpixelsY[6][256]", &detNpixelsY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detQE[6][256]", &detQE);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detReflectivity[6][256]", &detReflectivity);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detTimeRes[6][256]", &detTimeRes);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detPlacementAlt[6][256]", &detPlacementAlt);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detCenterX[6][256]", &detCenterX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detCenterY[6][256]", &detCenterY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detRotation[6][256]", &detRotation);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detCouplingRIndex[6][256]", &detCouplingRIndex);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "detCouplingThickness[6][256]", &detCouplingThickness);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "faceReflectivity[6]", &faceReflectivity);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "posPixelX[6][256]", &posPixelX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "posPixelY[6][256]", &posPixelY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "posPixelZ[6][256]", &posPixelZ);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_name", &m_name);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_totPixels", &m_totPixels);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_totDetectors", &m_totDetectors);
   TObject::ShowMembers(R__insp);
}
void ::TDetector::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TDetector::Class(),this);
   } else {
      b.WriteClassBuffer(::TDetector::Class(),this);
   }
}

atomic_TClass_ptr TEvent::fgIsA(0);
TClass* ::TEvent::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TEvent");
   }
   return fgIsA;
}
const char * ::TEvent::Class_Name() {return "TEvent";}
void ::TEvent::Dictionary() {}
const char *::TEvent::ImplFileName() {return "";}
int ::TEvent::ImplFileLine() {return 1;}
void ::TEvent::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TEvent::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_eventHeader", &m_eventHeader);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_objects", &m_objects);
   R__insp.InspectMember(m_objects, "m_objects.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_collections", &m_collections);
   R__insp.InspectMember("std::vector<TClonesArray*>", (void*)&m_collections, "m_collections.", false);
   TObject::ShowMembers(R__insp);
}
void ::TEvent::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TEvent::Class(),this);
   } else {
      b.WriteClassBuffer(::TEvent::Class(),this);
   }
}

atomic_TClass_ptr TNamedContainer::fgIsA(0);
TClass* ::TNamedContainer::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("TNamedContainer");
   }
   return fgIsA;
}
const char * ::TNamedContainer::Class_Name() {return "TNamedContainer";}
void ::TNamedContainer::Dictionary() {}
const char *::TNamedContainer::ImplFileName() {return "";}
int ::TNamedContainer::ImplFileLine() {return 1;}
void ::TNamedContainer::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TNamedContainer::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_object", &m_object);
   TNamed::ShowMembers(R__insp);
}
void ::TNamedContainer::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TNamedContainer::Class(),this);
   } else {
      b.WriteClassBuffer(::TNamedContainer::Class(),this);
   }
}


namespace {
//------Stub functions for class TXMLHandler -------------------------------
static  void operator_3009( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TXMLHandler*)o)->operator=)(*(const ::TXMLHandler*)arg[0]);
  else   (((::TXMLHandler*)o)->operator=)(*(const ::TXMLHandler*)arg[0]);
}

static void constructor_3010( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TXMLHandler(*(const ::TXMLHandler*)arg[0]);
  else ::new(mem) ::TXMLHandler(*(const ::TXMLHandler*)arg[0]);
}

static void constructor_3012( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TXMLHandler();
  else ::new(mem) ::TXMLHandler();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TXMLHandler(*(::std::string*)arg[0]);
  else ::new(mem) ::TXMLHandler(*(::std::string*)arg[0]);
  }
}

static void destructor_3013(void*, void * o, const std::vector<void*>&, void *) {
((::TXMLHandler*)o)->::TXMLHandler::~TXMLHandler();
}
static  void method_3014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<driver>)((((::TXMLHandler*)o)->GetDrivers)());
  else   (((::TXMLHandler*)o)->GetDrivers)();
}

static  void method_3015( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reconControl_struct)((((::TXMLHandler*)o)->GetReconControl)());
  else   (((::TXMLHandler*)o)->GetReconControl)();
}

static  void method_3016( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TXMLHandler*)o)->DisplayNodes)(*(::XMLNodePointer_t*)arg[0],
    *(::Int_t*)arg[1]);
}

static  void method_3017( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TXMLHandler*)o)->Class)());
  else   (((::TXMLHandler*)o)->Class)();
}

static  void method_3018( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TXMLHandler*)o)->Class_Name)());
  else   (((::TXMLHandler*)o)->Class_Name)();
}

static  void method_3019( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TXMLHandler*)o)->Class_Version)());
  else   (((::TXMLHandler*)o)->Class_Version)();
}

static  void method_3020( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TXMLHandler*)o)->Dictionary)();
}

static  void method_3021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TXMLHandler*)o)->IsA)());
  else   (((const ::TXMLHandler*)o)->IsA)();
}

static  void method_3022( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TXMLHandler*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_3023( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TXMLHandler*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_3024( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TXMLHandler*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_3025( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TXMLHandler*)o)->DeclFileName)());
  else   (((::TXMLHandler*)o)->DeclFileName)();
}

static  void method_3026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TXMLHandler*)o)->ImplFileLine)());
  else   (((::TXMLHandler*)o)->ImplFileLine)();
}

static  void method_3027( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TXMLHandler*)o)->ImplFileName)());
  else   (((::TXMLHandler*)o)->ImplFileName)();
}

static  void method_3028( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TXMLHandler*)o)->DeclFileLine)());
  else   (((::TXMLHandler*)o)->DeclFileLine)();
}

static void constructor_x0( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TXMLHandler();
  else ::new(mem) ::TXMLHandler();
}

static void method_newdel_51( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TXMLHandler >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TXMLHandler >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TXMLHandler >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TXMLHandler >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TXMLHandler >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x2( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TXMLHandler,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TXMLHandler -------------------------------
void __TXMLHandler_db_datamem(Reflex::Class*);
void __TXMLHandler_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TXMLHandler_datamem_bld(&__TXMLHandler_db_datamem);
Reflex::GenreflexMemberBuilder __TXMLHandler_funcmem_bld(&__TXMLHandler_db_funcmem);
void __TXMLHandler_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TXMLHandler"), typeid(::TXMLHandler), sizeof(::TXMLHandler), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TXMLHandler::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1879, ::Reflex::BaseOffset< ::TXMLHandler, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9994, type_9995), Reflex::Literal("operator="), operator_3009, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9995), Reflex::Literal("TXMLHandler"), constructor_3010, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2417), Reflex::Literal("TXMLHandler"), constructor_3012, 0, "fname=\"\"", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TXMLHandler"), destructor_3013, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TXMLHandler"), constructor_x0, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_51, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TXMLHandler_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TXMLHandler_funcmem_bld);
}

//------Delayed data member builder for class TXMLHandler -------------------
void __TXMLHandler_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9993, Reflex::Literal("m_xml"), OffsetOf(__shadow__::__TXMLHandler, m_xml), ::Reflex::PRIVATE)
  .AddDataMember(type_2417, Reflex::Literal("m_xmlFile"), OffsetOf(__shadow__::__TXMLHandler, m_xmlFile), ::Reflex::PRIVATE)
  .AddDataMember(type_1268, Reflex::Literal("m_xmldoc"), OffsetOf(__shadow__::__TXMLHandler, m_xmldoc), ::Reflex::PRIVATE)
  .AddDataMember(type_1243, Reflex::Literal("m_mainnode"), OffsetOf(__shadow__::__TXMLHandler, m_mainnode), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TXMLHandler -------------------
void __TXMLHandler_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664), Reflex::Literal("GetDrivers"), method_3014, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1398), Reflex::Literal("GetReconControl"), method_3015, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_1243, type_728), Reflex::Literal("DisplayNodes"), method_3016, 0, "node;level", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_640), Reflex::Literal("Class"), method_3017, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("Class_Name"), method_3018, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2074), Reflex::Literal("Class_Version"), method_3019, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000), Reflex::Literal("Dictionary"), method_3020, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_640), Reflex::Literal("IsA"), method_3021, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_9996), Reflex::Literal("ShowMembers"), method_3022, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_3178), Reflex::Literal("Streamer"), method_3023, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_3178), Reflex::Literal("StreamerNVirtual"), method_3024, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("DeclFileName"), method_3025, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("ImplFileLine"), method_3026, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("ImplFileName"), method_3027, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("DeclFileLine"), method_3028, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TMCTruth -------------------------------
static  void operator_3891( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TMCTruth*)o)->operator=)(*(const ::TMCTruth*)arg[0]);
  else   (((::TMCTruth*)o)->operator=)(*(const ::TMCTruth*)arg[0]);
}

static void constructor_3892( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMCTruth(*(const ::TMCTruth*)arg[0]);
  else ::new(mem) ::TMCTruth(*(const ::TMCTruth*)arg[0]);
}

static void constructor_3893( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMCTruth();
  else ::new(mem) ::TMCTruth();
}

static void destructor_3894(void*, void * o, const std::vector<void*>&, void *) {
((::TMCTruth*)o)->::TMCTruth::~TMCTruth();
}
static  void method_3895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TMCTruth*)o)->getEdep)());
  else   (((const ::TMCTruth*)o)->getEdep)();
}

static  void method_3896( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->setEdep)(*(double*)arg[0]);
}

static  void method_3897( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->addEdep)(*(double*)arg[0]);
}

static  void method_3898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TMCTruth*)o)->getEdepVis)());
  else   (((const ::TMCTruth*)o)->getEdepVis)();
}

static  void method_3899( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->setEdepVis)(*(double*)arg[0]);
}

static  void method_3900( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->addEdepVis)(*(double*)arg[0]);
}

static  void method_3901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMCTruth*)o)->getP0)());
  else   (((const ::TMCTruth*)o)->getP0)();
}

static  void method_3902( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->setP0)((::TLorentzVector*)arg[0]);
}

static  void method_3903( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TMCTruth*)o)->getPid)());
  else   (((const ::TMCTruth*)o)->getPid)();
}

static  void method_3904( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->setPid)(*(int*)arg[0]);
}

static  void method_3905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMCTruth*)o)->getX0)());
  else   (((const ::TMCTruth*)o)->getX0)();
}

static  void method_3906( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->setX0)((::TLorentzVector*)arg[0]);
}

static  void method_3907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMCTruth*)o)->getXin)());
  else   (((const ::TMCTruth*)o)->getXin)();
}

static  void method_3908( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->setXin)((::TLorentzVector*)arg[0]);
}

static  void method_3909( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMCTruth*)o)->getXout)());
  else   (((const ::TMCTruth*)o)->getXout)();
}

static  void method_3910( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->setXout)((::TLorentzVector*)arg[0]);
}

static  void method_3911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TMCTruth*)o)->getPathLength)());
  else   (((const ::TMCTruth*)o)->getPathLength)();
}

static  void method_3912( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->setPathLength)(*(double*)arg[0]);
}

static  void method_3913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCTruth*)o)->Class)());
  else   (((::TMCTruth*)o)->Class)();
}

static  void method_3914( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCTruth*)o)->Class_Name)());
  else   (((::TMCTruth*)o)->Class_Name)();
}

static  void method_3915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TMCTruth*)o)->Class_Version)());
  else   (((::TMCTruth*)o)->Class_Version)();
}

static  void method_3916( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TMCTruth*)o)->Dictionary)();
}

static  void method_3917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMCTruth*)o)->IsA)());
  else   (((const ::TMCTruth*)o)->IsA)();
}

static  void method_3918( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_3919( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_3920( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCTruth*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_3921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCTruth*)o)->DeclFileName)());
  else   (((::TMCTruth*)o)->DeclFileName)();
}

static  void method_3922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMCTruth*)o)->ImplFileLine)());
  else   (((::TMCTruth*)o)->ImplFileLine)();
}

static  void method_3923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCTruth*)o)->ImplFileName)());
  else   (((::TMCTruth*)o)->ImplFileName)();
}

static  void method_3924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMCTruth*)o)->DeclFileLine)());
  else   (((::TMCTruth*)o)->DeclFileLine)();
}

static void method_newdel_966( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TMCTruth >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TMCTruth >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TMCTruth >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TMCTruth >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TMCTruth >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::TMCTruth,::TNamed >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TMCTruth,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TMCTruth -------------------------------
void __TMCTruth_db_datamem(Reflex::Class*);
void __TMCTruth_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TMCTruth_datamem_bld(&__TMCTruth_db_datamem);
Reflex::GenreflexMemberBuilder __TMCTruth_funcmem_bld(&__TMCTruth_db_funcmem);
void __TMCTruth_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TMCTruth"), typeid(::TMCTruth), sizeof(::TMCTruth), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TMCTruth::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2215, ::Reflex::BaseOffset< ::TMCTruth, ::TNamed >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10190, type_10191), Reflex::Literal("operator="), operator_3891, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10191), Reflex::Literal("TMCTruth"), constructor_3892, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TMCTruth"), constructor_3893, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TMCTruth"), destructor_3894, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_966, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TMCTruth_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TMCTruth_funcmem_bld);
}

//------Delayed data member builder for class TMCTruth -------------------
void __TMCTruth_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_117, Reflex::Literal("m_pid"), OffsetOf(__shadow__::__TMCTruth, m_pid), ::Reflex::PRIVATE)
  .AddDataMember(type_10189, Reflex::Literal("m_P0"), OffsetOf(__shadow__::__TMCTruth, m_P0), ::Reflex::PRIVATE)
  .AddDataMember(type_10189, Reflex::Literal("m_x0"), OffsetOf(__shadow__::__TMCTruth, m_x0), ::Reflex::PRIVATE)
  .AddDataMember(type_10189, Reflex::Literal("m_xin"), OffsetOf(__shadow__::__TMCTruth, m_xin), ::Reflex::PRIVATE)
  .AddDataMember(type_10189, Reflex::Literal("m_xout"), OffsetOf(__shadow__::__TMCTruth, m_xout), ::Reflex::PRIVATE)
  .AddDataMember(type_195, Reflex::Literal("m_edep"), OffsetOf(__shadow__::__TMCTruth, m_edep), ::Reflex::PRIVATE)
  .AddDataMember(type_195, Reflex::Literal("m_edepVis"), OffsetOf(__shadow__::__TMCTruth, m_edepVis), ::Reflex::PRIVATE)
  .AddDataMember(type_195, Reflex::Literal("m_pathLength"), OffsetOf(__shadow__::__TMCTruth, m_pathLength), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TMCTruth -------------------
void __TMCTruth_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195), Reflex::Literal("getEdep"), method_3895, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_195), Reflex::Literal("setEdep"), method_3896, 0, "edep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_195), Reflex::Literal("addEdep"), method_3897, 0, "edep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195), Reflex::Literal("getEdepVis"), method_3898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_195), Reflex::Literal("setEdepVis"), method_3899, 0, "edepVis", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_195), Reflex::Literal("addEdepVis"), method_3900, 0, "edep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10189), Reflex::Literal("getP0"), method_3901, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_10189), Reflex::Literal("setP0"), method_3902, 0, "p0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("getPid"), method_3903, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117), Reflex::Literal("setPid"), method_3904, 0, "pid", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10189), Reflex::Literal("getX0"), method_3905, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_10189), Reflex::Literal("setX0"), method_3906, 0, "x0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10189), Reflex::Literal("getXin"), method_3907, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_10189), Reflex::Literal("setXin"), method_3908, 0, "xin", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10189), Reflex::Literal("getXout"), method_3909, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_10189), Reflex::Literal("setXout"), method_3910, 0, "xout", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195), Reflex::Literal("getPathLength"), method_3911, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_195), Reflex::Literal("setPathLength"), method_3912, 0, "pathLength", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_640), Reflex::Literal("Class"), method_3913, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("Class_Name"), method_3914, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2074), Reflex::Literal("Class_Version"), method_3915, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000), Reflex::Literal("Dictionary"), method_3916, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_640), Reflex::Literal("IsA"), method_3917, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_9996), Reflex::Literal("ShowMembers"), method_3918, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_3178), Reflex::Literal("Streamer"), method_3919, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_3178), Reflex::Literal("StreamerNVirtual"), method_3920, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("DeclFileName"), method_3921, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("ImplFileLine"), method_3922, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("ImplFileName"), method_3923, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("DeclFileLine"), method_3924, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TEventHeader -------------------------------
static  void operator_3988( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TEventHeader*)o)->operator=)(*(const ::TEventHeader*)arg[0]);
  else   (((::TEventHeader*)o)->operator=)(*(const ::TEventHeader*)arg[0]);
}

static void constructor_3989( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TEventHeader(*(const ::TEventHeader*)arg[0]);
  else ::new(mem) ::TEventHeader(*(const ::TEventHeader*)arg[0]);
}

static void constructor_3990( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TEventHeader();
  else ::new(mem) ::TEventHeader();
}

static  void method_3991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TEventHeader*)o)->getEventNumber)());
  else   (((const ::TEventHeader*)o)->getEventNumber)();
}

static  void method_3992( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEventHeader*)o)->setEventNumber)(*(int*)arg[0]);
}

static  void method_3993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TEventHeader*)o)->getRunNumber)());
  else   (((const ::TEventHeader*)o)->getRunNumber)();
}

static  void method_3994( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEventHeader*)o)->setRunNumber)(*(int*)arg[0]);
}

static  void method_3995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEventHeader*)o)->Class)());
  else   (((::TEventHeader*)o)->Class)();
}

static  void method_3996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEventHeader*)o)->Class_Name)());
  else   (((::TEventHeader*)o)->Class_Name)();
}

static  void method_3997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TEventHeader*)o)->Class_Version)());
  else   (((::TEventHeader*)o)->Class_Version)();
}

static  void method_3998( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TEventHeader*)o)->Dictionary)();
}

static  void method_3999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TEventHeader*)o)->IsA)());
  else   (((const ::TEventHeader*)o)->IsA)();
}

static  void method_4000( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEventHeader*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4001( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEventHeader*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4002( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEventHeader*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEventHeader*)o)->DeclFileName)());
  else   (((::TEventHeader*)o)->DeclFileName)();
}

static  void method_4004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TEventHeader*)o)->ImplFileLine)());
  else   (((::TEventHeader*)o)->ImplFileLine)();
}

static  void method_4005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEventHeader*)o)->ImplFileName)());
  else   (((::TEventHeader*)o)->ImplFileName)();
}

static  void method_4006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TEventHeader*)o)->DeclFileLine)());
  else   (((::TEventHeader*)o)->DeclFileLine)();
}

static void destructor_4007(void*, void * o, const std::vector<void*>&, void *) {
((::TEventHeader*)o)->::TEventHeader::~TEventHeader();
}
static void method_newdel_1019( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TEventHeader >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TEventHeader >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TEventHeader >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TEventHeader >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TEventHeader >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TEventHeader,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TEventHeader -------------------------------
void __TEventHeader_db_datamem(Reflex::Class*);
void __TEventHeader_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TEventHeader_datamem_bld(&__TEventHeader_db_datamem);
Reflex::GenreflexMemberBuilder __TEventHeader_funcmem_bld(&__TEventHeader_db_funcmem);
void __TEventHeader_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TEventHeader"), typeid(::TEventHeader), sizeof(::TEventHeader), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TEventHeader::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1879, ::Reflex::BaseOffset< ::TEventHeader, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10199, type_10200), Reflex::Literal("operator="), operator_3988, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10200), Reflex::Literal("TEventHeader"), constructor_3989, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TEventHeader"), constructor_3990, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TEventHeader"), destructor_4007, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1019, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TEventHeader_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TEventHeader_funcmem_bld);
}

//------Delayed data member builder for class TEventHeader -------------------
void __TEventHeader_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_117, Reflex::Literal("m_eventNumber"), OffsetOf(__shadow__::__TEventHeader, m_eventNumber), ::Reflex::PRIVATE)
  .AddDataMember(type_117, Reflex::Literal("m_runNumber"), OffsetOf(__shadow__::__TEventHeader, m_runNumber), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TEventHeader -------------------
void __TEventHeader_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("getEventNumber"), method_3991, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117), Reflex::Literal("setEventNumber"), method_3992, 0, "eventNumber", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("getRunNumber"), method_3993, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117), Reflex::Literal("setRunNumber"), method_3994, 0, "runNumber", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_640), Reflex::Literal("Class"), method_3995, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("Class_Name"), method_3996, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2074), Reflex::Literal("Class_Version"), method_3997, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000), Reflex::Literal("Dictionary"), method_3998, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_640), Reflex::Literal("IsA"), method_3999, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_9996), Reflex::Literal("ShowMembers"), method_4000, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_3178), Reflex::Literal("Streamer"), method_4001, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_3178), Reflex::Literal("StreamerNVirtual"), method_4002, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("DeclFileName"), method_4003, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("ImplFileLine"), method_4004, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("ImplFileName"), method_4005, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("DeclFileLine"), method_4006, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TDetectorUtils -------------------------------
static  void operator_4335( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TDetectorUtils*)o)->operator=)(*(const ::TDetectorUtils*)arg[0]);
  else   (((::TDetectorUtils*)o)->operator=)(*(const ::TDetectorUtils*)arg[0]);
}

static void constructor_4336( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TDetectorUtils(*(const ::TDetectorUtils*)arg[0]);
  else ::new(mem) ::TDetectorUtils(*(const ::TDetectorUtils*)arg[0]);
}

static void constructor_4343( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TDetectorUtils();
  else ::new(mem) ::TDetectorUtils();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TDetectorUtils((::TDetector*)arg[0]);
  else ::new(mem) ::TDetectorUtils((::TDetector*)arg[0]);
  }
}

static void destructor_4344(void*, void * o, const std::vector<void*>&, void *) {
((::TDetectorUtils*)o)->::TDetectorUtils::~TDetectorUtils();
}
static  void method_4345( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorUtils*)o)->SinglePhotonTimeProb)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]));
  else   (((const ::TDetectorUtils*)o)->SinglePhotonTimeProb)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4346( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorUtils*)o)->SinglePhotonIntegratedTimeProb)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]));
  else   (((const ::TDetectorUtils*)o)->SinglePhotonIntegratedTimeProb)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4347( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorUtils*)o)->SinglePixelAverageCharge)(*(const ::TVector3*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    *(int*)arg[3]));
  else   (((const ::TDetectorUtils*)o)->SinglePixelAverageCharge)(*(const ::TVector3*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    *(int*)arg[3]);
}

static  void method_4348( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorUtils*)o)->GetSolidAngle)(*(const ::TVector3*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    *(int*)arg[3]));
  else   (((const ::TDetectorUtils*)o)->GetSolidAngle)(*(const ::TVector3*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    *(int*)arg[3]);
}

static  void method_4349( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorUtils*)o)->TrackAverageCharge)(*(const ::TVector3*)arg[0],
    *(const ::TVector3*)arg[1],
    *(int*)arg[2],
    *(int*)arg[3],
    *(int*)arg[4]));
  else   (((const ::TDetectorUtils*)o)->TrackAverageCharge)(*(const ::TVector3*)arg[0],
    *(const ::TVector3*)arg[1],
    *(int*)arg[2],
    *(int*)arg[3],
    *(int*)arg[4]);
}

static  void method_4350( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetectorUtils*)o)->GetMinimalDelay)(*(const ::TVector3*)arg[0],
    *(const ::TVector3*)arg[1],
    *(double*)arg[2],
    *(int*)arg[3],
    *(int*)arg[4],
    *(int*)arg[5]));
  else   (((const ::TDetectorUtils*)o)->GetMinimalDelay)(*(const ::TVector3*)arg[0],
    *(const ::TVector3*)arg[1],
    *(double*)arg[2],
    *(int*)arg[3],
    *(int*)arg[4],
    *(int*)arg[5]);
}

static  void method_4351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDetectorUtils*)o)->Class)());
  else   (((::TDetectorUtils*)o)->Class)();
}

static  void method_4352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDetectorUtils*)o)->Class_Name)());
  else   (((::TDetectorUtils*)o)->Class_Name)();
}

static  void method_4353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TDetectorUtils*)o)->Class_Version)());
  else   (((::TDetectorUtils*)o)->Class_Version)();
}

static  void method_4354( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TDetectorUtils*)o)->Dictionary)();
}

static  void method_4355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TDetectorUtils*)o)->IsA)());
  else   (((const ::TDetectorUtils*)o)->IsA)();
}

static  void method_4356( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorUtils*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4357( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorUtils*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4358( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetectorUtils*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDetectorUtils*)o)->DeclFileName)());
  else   (((::TDetectorUtils*)o)->DeclFileName)();
}

static  void method_4360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDetectorUtils*)o)->ImplFileLine)());
  else   (((::TDetectorUtils*)o)->ImplFileLine)();
}

static  void method_4361( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDetectorUtils*)o)->ImplFileName)());
  else   (((::TDetectorUtils*)o)->ImplFileName)();
}

static  void method_4362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDetectorUtils*)o)->DeclFileLine)());
  else   (((::TDetectorUtils*)o)->DeclFileLine)();
}

static void constructor_x7( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TDetectorUtils();
  else ::new(mem) ::TDetectorUtils();
}

static void method_newdel_1200( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TDetectorUtils >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TDetectorUtils >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TDetectorUtils >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TDetectorUtils >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TDetectorUtils >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TDetectorUtils,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TDetectorUtils -------------------------------
void __TDetectorUtils_db_datamem(Reflex::Class*);
void __TDetectorUtils_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TDetectorUtils_datamem_bld(&__TDetectorUtils_db_datamem);
Reflex::GenreflexMemberBuilder __TDetectorUtils_funcmem_bld(&__TDetectorUtils_db_funcmem);
void __TDetectorUtils_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TDetectorUtils"), typeid(::TDetectorUtils), sizeof(::TDetectorUtils), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TDetectorUtils::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1879, ::Reflex::BaseOffset< ::TDetectorUtils, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10248, type_10249), Reflex::Literal("operator="), operator_4335, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10249), Reflex::Literal("TDetectorUtils"), constructor_4336, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10246), Reflex::Literal("TDetectorUtils"), constructor_4343, 0, "det=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TDetectorUtils"), destructor_4344, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TDetectorUtils"), constructor_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1200, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TDetectorUtils_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TDetectorUtils_funcmem_bld);
}

//------Delayed data member builder for class TDetectorUtils -------------------
void __TDetectorUtils_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10246, Reflex::Literal("m_detector"), OffsetOf(__shadow__::__TDetectorUtils, m_detector), ::Reflex::PRIVATE)
  .AddDataMember(type_10247, Reflex::Literal("m_SinglePhotonTimeProbKernel"), OffsetOf(__shadow__::__TDetectorUtils, m_SinglePhotonTimeProbKernel), ::Reflex::PRIVATE)
  .AddDataMember(type_10247, Reflex::Literal("m_TrackChargeKernel"), OffsetOf(__shadow__::__TDetectorUtils, m_TrackChargeKernel), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TDetectorUtils -------------------
void __TDetectorUtils_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_195, type_195, type_195), Reflex::Literal("SinglePhotonTimeProb"), method_4345, 0, "t;tau;sigma", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_195, type_195, type_195), Reflex::Literal("SinglePhotonIntegratedTimeProb"), method_4346, 0, "t;tau;sigma", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_5591, type_117, type_117, type_117), Reflex::Literal("SinglePixelAverageCharge"), method_4347, 0, "x0;iface;idetector;id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_5591, type_117, type_117, type_117), Reflex::Literal("GetSolidAngle"), method_4348, 0, "x0;iface;idetector;id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_5591, type_5591, type_117, type_117, type_117), Reflex::Literal("TrackAverageCharge"), method_4349, 0, "x0;x1;iface;idetector;id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_5591, type_5591, type_195, type_117, type_117, type_117), Reflex::Literal("GetMinimalDelay"), method_4350, 0, "x0;x1;beta;iface;idetector;id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_640), Reflex::Literal("Class"), method_4351, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("Class_Name"), method_4352, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2074), Reflex::Literal("Class_Version"), method_4353, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000), Reflex::Literal("Dictionary"), method_4354, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_640), Reflex::Literal("IsA"), method_4355, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_9996), Reflex::Literal("ShowMembers"), method_4356, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_3178), Reflex::Literal("Streamer"), method_4357, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_3178), Reflex::Literal("StreamerNVirtual"), method_4358, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("DeclFileName"), method_4359, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("ImplFileLine"), method_4360, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("ImplFileName"), method_4361, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("DeclFileLine"), method_4362, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TMCParticle -------------------------------
static  void operator_4789( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TMCParticle*)o)->operator=)(*(const ::TMCParticle*)arg[0]);
  else   (((::TMCParticle*)o)->operator=)(*(const ::TMCParticle*)arg[0]);
}

static void constructor_4790( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMCParticle(*(const ::TMCParticle*)arg[0]);
  else ::new(mem) ::TMCParticle(*(const ::TMCParticle*)arg[0]);
}

static void constructor_4791( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TMCParticle();
  else ::new(mem) ::TMCParticle();
}

static void destructor_4792(void*, void * o, const std::vector<void*>&, void *) {
((::TMCParticle*)o)->::TMCParticle::~TMCParticle();
}
static  void method_4793( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCParticle*)o)->Clear)((::Option_t*)arg[0]);
}

static  void method_4794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TMCParticle*)o)->getEdep)());
  else   (((const ::TMCParticle*)o)->getEdep)();
}

static  void method_4795( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCParticle*)o)->setEdep)(*(double*)arg[0]);
}

static  void method_4796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TMCParticle*)o)->getEdepVis)());
  else   (((const ::TMCParticle*)o)->getEdepVis)();
}

static  void method_4797( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCParticle*)o)->setEdepVis)(*(double*)arg[0]);
}

static  void method_4798( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TMCParticle*)o)->getId)());
  else   (((const ::TMCParticle*)o)->getId)();
}

static  void method_4799( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCParticle*)o)->setId)(*(int*)arg[0]);
}

static  void method_4800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TMCParticle*)o)->getParentId)());
  else   (((const ::TMCParticle*)o)->getParentId)();
}

static  void method_4801( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCParticle*)o)->setParentId)(*(int*)arg[0]);
}

static  void method_4802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TMCParticle*)o)->getPid)());
  else   (((const ::TMCParticle*)o)->getPid)();
}

static  void method_4803( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCParticle*)o)->setPid)(*(int*)arg[0]);
}

static  void method_4804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCParticle*)o)->Class)());
  else   (((::TMCParticle*)o)->Class)();
}

static  void method_4805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCParticle*)o)->Class_Name)());
  else   (((::TMCParticle*)o)->Class_Name)();
}

static  void method_4806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TMCParticle*)o)->Class_Version)());
  else   (((::TMCParticle*)o)->Class_Version)();
}

static  void method_4807( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TMCParticle*)o)->Dictionary)();
}

static  void method_4808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TMCParticle*)o)->IsA)());
  else   (((const ::TMCParticle*)o)->IsA)();
}

static  void method_4809( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCParticle*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4810( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCParticle*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4811( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TMCParticle*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCParticle*)o)->DeclFileName)());
  else   (((::TMCParticle*)o)->DeclFileName)();
}

static  void method_4813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMCParticle*)o)->ImplFileLine)());
  else   (((::TMCParticle*)o)->ImplFileLine)();
}

static  void method_4814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TMCParticle*)o)->ImplFileName)());
  else   (((::TMCParticle*)o)->ImplFileName)();
}

static  void method_4815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TMCParticle*)o)->DeclFileLine)());
  else   (((::TMCParticle*)o)->DeclFileLine)();
}

static void method_newdel_1445( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TMCParticle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TMCParticle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TMCParticle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TMCParticle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TMCParticle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TMCParticle,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TMCParticle -------------------------------
void __TMCParticle_db_datamem(Reflex::Class*);
void __TMCParticle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TMCParticle_datamem_bld(&__TMCParticle_db_datamem);
Reflex::GenreflexMemberBuilder __TMCParticle_funcmem_bld(&__TMCParticle_db_funcmem);
void __TMCParticle_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TMCParticle"), typeid(::TMCParticle), sizeof(::TMCParticle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TMCParticle::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1879, ::Reflex::BaseOffset< ::TMCParticle, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10734, type_10735), Reflex::Literal("operator="), operator_4789, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10735), Reflex::Literal("TMCParticle"), constructor_4790, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TMCParticle"), constructor_4791, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TMCParticle"), destructor_4792, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1445, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TMCParticle_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TMCParticle_funcmem_bld);
}

//------Delayed data member builder for class TMCParticle -------------------
void __TMCParticle_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_117, Reflex::Literal("m_pid"), OffsetOf(__shadow__::__TMCParticle, m_pid), ::Reflex::PRIVATE)
  .AddDataMember(type_117, Reflex::Literal("m_id"), OffsetOf(__shadow__::__TMCParticle, m_id), ::Reflex::PRIVATE)
  .AddDataMember(type_117, Reflex::Literal("m_parentId"), OffsetOf(__shadow__::__TMCParticle, m_parentId), ::Reflex::PRIVATE)
  .AddDataMember(type_195, Reflex::Literal("m_edep"), OffsetOf(__shadow__::__TMCParticle, m_edep), ::Reflex::PRIVATE)
  .AddDataMember(type_195, Reflex::Literal("m_edepVis"), OffsetOf(__shadow__::__TMCParticle, m_edepVis), ::Reflex::PRIVATE)
  .AddDataMember(type_10189, Reflex::Literal("m_x0"), OffsetOf(__shadow__::__TMCParticle, m_x0), ::Reflex::PRIVATE)
  .AddDataMember(type_10189, Reflex::Literal("m_P0"), OffsetOf(__shadow__::__TMCParticle, m_P0), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TMCParticle -------------------
void __TMCParticle_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_10090), Reflex::Literal("Clear"), method_4793, 0, "option", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195), Reflex::Literal("getEdep"), method_4794, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_195), Reflex::Literal("setEdep"), method_4795, 0, "edep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195), Reflex::Literal("getEdepVis"), method_4796, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_195), Reflex::Literal("setEdepVis"), method_4797, 0, "edepVis", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("getId"), method_4798, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117), Reflex::Literal("setId"), method_4799, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("getParentId"), method_4800, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117), Reflex::Literal("setParentId"), method_4801, 0, "parentId", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("getPid"), method_4802, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117), Reflex::Literal("setPid"), method_4803, 0, "pid", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_640), Reflex::Literal("Class"), method_4804, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("Class_Name"), method_4805, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2074), Reflex::Literal("Class_Version"), method_4806, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000), Reflex::Literal("Dictionary"), method_4807, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_640), Reflex::Literal("IsA"), method_4808, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_9996), Reflex::Literal("ShowMembers"), method_4809, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_3178), Reflex::Literal("Streamer"), method_4810, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_3178), Reflex::Literal("StreamerNVirtual"), method_4811, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("DeclFileName"), method_4812, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("ImplFileLine"), method_4813, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("ImplFileName"), method_4814, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("DeclFileLine"), method_4815, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TRealSetupHandler -------------------------------
static  void operator_4834( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TRealSetupHandler*)o)->operator=)(*(const ::TRealSetupHandler*)arg[0]);
  else   (((::TRealSetupHandler*)o)->operator=)(*(const ::TRealSetupHandler*)arg[0]);
}

static void constructor_4835( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TRealSetupHandler(*(const ::TRealSetupHandler*)arg[0]);
  else ::new(mem) ::TRealSetupHandler(*(const ::TRealSetupHandler*)arg[0]);
}

static void constructor_4837( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TRealSetupHandler(*(::std::string*)arg[0]);
  else ::new(mem) ::TRealSetupHandler(*(::std::string*)arg[0]);
}

static void constructor_4838( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TRealSetupHandler();
  else ::new(mem) ::TRealSetupHandler();
}

static  void method_4839( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TRealSetupHandler*)o)->getReconstructionDetectorFace)(*(int*)arg[0]));
  else   (((::TRealSetupHandler*)o)->getReconstructionDetectorFace)(*(int*)arg[0]);
}

static  void method_4840( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TRealSetupHandler*)o)->getReconstructionDetectorID)(*(int*)arg[0]));
  else   (((::TRealSetupHandler*)o)->getReconstructionDetectorID)(*(int*)arg[0]);
}

static  void method_4841( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::TRealSetupHandler*)o)->getRealDetectorID)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((::TRealSetupHandler*)o)->getRealDetectorID)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_4842( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (double)((((::TRealSetupHandler*)o)->getPixelGain)(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]));
    else     (((::TRealSetupHandler*)o)->getPixelGain)(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (double)((((::TRealSetupHandler*)o)->getPixelGain)(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]));
    else     (((::TRealSetupHandler*)o)->getPixelGain)(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
  }
}

static  void method_4843( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TRealSetupHandler*)o)->setPixelGain)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4]);
}

static  void method_4844( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::TRealSetupHandler*)o)->Print)();
  }
  else if ( arg.size() == 1 ) { 
    (((::TRealSetupHandler*)o)->Print)(*(int*)arg[0]);
  }
}

static  void method_4845( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TRealSetupHandler*)o)->PrintPixels)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_4846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TRealSetupHandler*)o)->Class)());
  else   (((::TRealSetupHandler*)o)->Class)();
}

static  void method_4847( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TRealSetupHandler*)o)->Class_Name)());
  else   (((::TRealSetupHandler*)o)->Class_Name)();
}

static  void method_4848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TRealSetupHandler*)o)->Class_Version)());
  else   (((::TRealSetupHandler*)o)->Class_Version)();
}

static  void method_4849( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TRealSetupHandler*)o)->Dictionary)();
}

static  void method_4850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TRealSetupHandler*)o)->IsA)());
  else   (((const ::TRealSetupHandler*)o)->IsA)();
}

static  void method_4851( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TRealSetupHandler*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4852( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TRealSetupHandler*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4853( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TRealSetupHandler*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TRealSetupHandler*)o)->DeclFileName)());
  else   (((::TRealSetupHandler*)o)->DeclFileName)();
}

static  void method_4855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TRealSetupHandler*)o)->ImplFileLine)());
  else   (((::TRealSetupHandler*)o)->ImplFileLine)();
}

static  void method_4856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TRealSetupHandler*)o)->ImplFileName)());
  else   (((::TRealSetupHandler*)o)->ImplFileName)();
}

static  void method_4857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TRealSetupHandler*)o)->DeclFileLine)());
  else   (((::TRealSetupHandler*)o)->DeclFileLine)();
}

static void destructor_4858(void*, void * o, const std::vector<void*>&, void *) {
((::TRealSetupHandler*)o)->::TRealSetupHandler::~TRealSetupHandler();
}
static void method_newdel_1489( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TRealSetupHandler >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TRealSetupHandler >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TRealSetupHandler >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TRealSetupHandler >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TRealSetupHandler >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x13( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TRealSetupHandler,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TRealSetupHandler -------------------------------
void __TRealSetupHandler_db_datamem(Reflex::Class*);
void __TRealSetupHandler_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TRealSetupHandler_datamem_bld(&__TRealSetupHandler_db_datamem);
Reflex::GenreflexMemberBuilder __TRealSetupHandler_funcmem_bld(&__TRealSetupHandler_db_funcmem);
void __TRealSetupHandler_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TRealSetupHandler"), typeid(::TRealSetupHandler), sizeof(::TRealSetupHandler), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TRealSetupHandler::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1879, ::Reflex::BaseOffset< ::TRealSetupHandler, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10737, type_10738), Reflex::Literal("operator="), operator_4834, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10738), Reflex::Literal("TRealSetupHandler"), constructor_4835, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2417), Reflex::Literal("TRealSetupHandler"), constructor_4837, 0, "fname", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TRealSetupHandler"), constructor_4838, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TRealSetupHandler"), destructor_4858, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1489, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TRealSetupHandler_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TRealSetupHandler_funcmem_bld);
}

//------Delayed data member builder for class TRealSetupHandler -------------------
void __TRealSetupHandler_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2568, Reflex::Literal("m_reconstructionDetFace"), OffsetOf(__shadow__::__TRealSetupHandler, m_reconstructionDetFace), ::Reflex::PROTECTED)
  .AddDataMember(type_2568, Reflex::Literal("m_reconstructionDetID"), OffsetOf(__shadow__::__TRealSetupHandler, m_reconstructionDetID), ::Reflex::PROTECTED)
  .AddDataMember(type_2567, Reflex::Literal("m_reconstructionRealDet"), OffsetOf(__shadow__::__TRealSetupHandler, m_reconstructionRealDet), ::Reflex::PROTECTED)
  .AddDataMember(type_10736, Reflex::Literal("m_PixelGain1"), OffsetOf(__shadow__::__TRealSetupHandler, m_PixelGain1), ::Reflex::PROTECTED)
  .AddDataMember(type_10736, Reflex::Literal("m_PixelGain2"), OffsetOf(__shadow__::__TRealSetupHandler, m_PixelGain2), ::Reflex::PROTECTED)
  .AddDataMember(type_10736, Reflex::Literal("m_PixelGain3"), OffsetOf(__shadow__::__TRealSetupHandler, m_PixelGain3), ::Reflex::PROTECTED)
  .AddDataMember(type_117, Reflex::Literal("nRealDet"), OffsetOf(__shadow__::__TRealSetupHandler, nRealDet), ::Reflex::PROTECTED)
  .AddDataMember(type_117, Reflex::Literal("m_thisReconFace"), OffsetOf(__shadow__::__TRealSetupHandler, m_thisReconFace), ::Reflex::PROTECTED)
  .AddDataMember(type_117, Reflex::Literal("m_thisReconDetID"), OffsetOf(__shadow__::__TRealSetupHandler, m_thisReconDetID), ::Reflex::PROTECTED)
  .AddDataMember(type_117, Reflex::Literal("m_thisRealDetID"), OffsetOf(__shadow__::__TRealSetupHandler, m_thisRealDetID), ::Reflex::PROTECTED)
  .AddDataMember(type_117, Reflex::Literal("m_thisPixel"), OffsetOf(__shadow__::__TRealSetupHandler, m_thisPixel), ::Reflex::PROTECTED)
  .AddDataMember(type_117, Reflex::Literal("m_thisPixelFirst"), OffsetOf(__shadow__::__TRealSetupHandler, m_thisPixelFirst), ::Reflex::PROTECTED)
  .AddDataMember(type_117, Reflex::Literal("m_thisPixelLast"), OffsetOf(__shadow__::__TRealSetupHandler, m_thisPixelLast), ::Reflex::PROTECTED)
  .AddDataMember(type_117, Reflex::Literal("m_thisGainEntry"), OffsetOf(__shadow__::__TRealSetupHandler, m_thisGainEntry), ::Reflex::PROTECTED)
  .AddDataMember(type_195, Reflex::Literal("m_thisGainVal"), OffsetOf(__shadow__::__TRealSetupHandler, m_thisGainVal), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class TRealSetupHandler -------------------
void __TRealSetupHandler_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117, type_117), Reflex::Literal("getReconstructionDetectorFace"), method_4839, 0, "idet", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117, type_117), Reflex::Literal("getReconstructionDetectorID"), method_4840, 0, "idet", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117, type_117, type_117), Reflex::Literal("getRealDetectorID"), method_4841, 0, "iface;idet", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_117, type_117, type_117, type_117), Reflex::Literal("getPixelGain"), method_4842, 0, "iface;idetector;ipixel;igain=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117, type_117, type_117, type_117, type_195), Reflex::Literal("setPixelGain"), method_4843, 0, "iface;idetector;ipixel;igain;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117), Reflex::Literal("Print"), method_4844, 0, "printPixels=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117, type_117), Reflex::Literal("PrintPixels"), method_4845, 0, "iface;idetector", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_640), Reflex::Literal("Class"), method_4846, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("Class_Name"), method_4847, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2074), Reflex::Literal("Class_Version"), method_4848, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000), Reflex::Literal("Dictionary"), method_4849, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_640), Reflex::Literal("IsA"), method_4850, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_9996), Reflex::Literal("ShowMembers"), method_4851, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_3178), Reflex::Literal("Streamer"), method_4852, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_3178), Reflex::Literal("StreamerNVirtual"), method_4853, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("DeclFileName"), method_4854, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("ImplFileLine"), method_4855, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("ImplFileName"), method_4856, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("DeclFileLine"), method_4857, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TDetector -------------------------------
static  void operator_5410( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TDetector*)o)->operator=)(*(const ::TDetector*)arg[0]);
  else   (((::TDetector*)o)->operator=)(*(const ::TDetector*)arg[0]);
}

static void constructor_5411( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TDetector(*(const ::TDetector*)arg[0]);
  else ::new(mem) ::TDetector(*(const ::TDetector*)arg[0]);
}

static void constructor_5412( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TDetector();
  else ::new(mem) ::TDetector();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TDetector(*(::std::string*)arg[0]);
  else ::new(mem) ::TDetector(*(::std::string*)arg[0]);
  }
}

static void destructor_5413(void*, void * o, const std::vector<void*>&, void *) {
((::TDetector*)o)->::TDetector::~TDetector();
}
static  void method_5414( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setScintSizeX)(*(double*)arg[0]);
}

static  void method_5415( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setScintSizeY)(*(double*)arg[0]);
}

static  void method_5416( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setScintSizeZ)(*(double*)arg[0]);
}

static  void method_5417( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getScintSizeX)());
  else   (((const ::TDetector*)o)->getScintSizeX)();
}

static  void method_5418( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getScintSizeY)());
  else   (((const ::TDetector*)o)->getScintSizeY)();
}

static  void method_5419( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getScintSizeZ)());
  else   (((const ::TDetector*)o)->getScintSizeZ)();
}

static  void method_5420( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setLY)(*(double*)arg[0]);
}

static  void method_5421( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getLY)());
  else   (((const ::TDetector*)o)->getLY)();
}

static  void method_5422( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setFastScintTime)(*(double*)arg[0]);
}

static  void method_5423( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getFastScintTime)());
  else   (((const ::TDetector*)o)->getFastScintTime)();
}

static  void method_5424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getRindex)());
  else   (((const ::TDetector*)o)->getRindex)();
}

static  void method_5425( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setRindex)(*(double*)arg[0]);
}

static  void method_5426( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getFaceReflectivity)(*(int*)arg[0]));
  else   (((const ::TDetector*)o)->getFaceReflectivity)(*(int*)arg[0]);
}

static  void method_5427( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setFaceReflectivity)(*(int*)arg[0],
    *(double*)arg[1]);
}

static  void method_5428( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setNdet)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5429( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDetector*)o)->getNdet)(*(int*)arg[0]));
  else   (((const ::TDetector*)o)->getNdet)(*(int*)arg[0]);
}

static  void method_5430( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDetector*)o)->getDetGlobalID)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getDetGlobalID)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5431( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TDetector*)o)->getFaceDetIDfromGlobal)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]);
}

static  void method_5432( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDetector*)o)->getPixelGlobalID)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]));
  else   (((const ::TDetector*)o)->getPixelGlobalID)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]);
}

static  void method_5433( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TDetector*)o)->getFaceDetPixelIDfromGlobal)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    *(int*)arg[3]);
}

static  void method_5434( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDetector*)o)->getTotDetectors)());
  else   (((::TDetector*)o)->getTotDetectors)();
}

static  void method_5435( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDetector*)o)->getTotPixels)());
  else   (((::TDetector*)o)->getTotPixels)();
}

static  void method_5436( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setDetSizeX)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_5437( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setDetSizeY)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_5438( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getDetSizeX)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getDetSizeX)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5439( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getDetSizeY)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getDetSizeY)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5440( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getDetCenterX)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getDetCenterX)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5441( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getDetCenterY)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getDetCenterY)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5442( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getDetRotation)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getDetRotation)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5443( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDetector*)o)->getDetPlacementAlt)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getDetPlacementAlt)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5444( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setDetCenterX)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_5445( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setDetCenterY)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_5446( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setDetRotation)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_5447( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setDetName)(*(int*)arg[0],
    *(int*)arg[1],
    *(::std::string*)arg[2]);
}

static  void method_5448( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::TDetector*)o)->getDetName)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((::TDetector*)o)->getDetName)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5449( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setNPixelsX)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]);
}

static  void method_5450( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setNPixelsY)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]);
}

static  void method_5451( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDetector*)o)->getNPixelsX)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getNPixelsX)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5452( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDetector*)o)->getNPixelsY)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getNPixelsY)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5453( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDetector*)o)->getNPixels)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getNPixels)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5454( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getPixelSizeX)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getPixelSizeX)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5455( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getPixelSizeY)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getPixelSizeY)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5456( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getCouplingThickness)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getCouplingThickness)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5457( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getCouplingRIndex)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getCouplingRIndex)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5458( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setDetTimeRes)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_5459( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getDetTimeRes)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getDetTimeRes)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5460( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getDetQE)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getDetQE)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5461( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setDetQE)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_5462( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TDetector*)o)->getDetReflectivity)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getDetReflectivity)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5463( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setDetReflectivity)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_5464( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TDetector*)o)->isDetPresent)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->isDetPresent)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5465( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->setName)(*(::std::string*)arg[0]);
}

static  void method_5466( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::TDetector*)o)->getName)());
  else   (((::TDetector*)o)->getName)();
}

static  void method_5467( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::TDetector*)o)->getPosPixel)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]));
  else   (((const ::TDetector*)o)->getPosPixel)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]);
}

static  void method_5468( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::TDetector*)o)->getFaceNormal)(*(int*)arg[0]));
  else   (((const ::TDetector*)o)->getFaceNormal)(*(int*)arg[0]);
}

static  void method_5469( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::TDetector*)o)->getFaceT1)(*(int*)arg[0]));
  else   (((const ::TDetector*)o)->getFaceT1)(*(int*)arg[0]);
}

static  void method_5470( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::TDetector*)o)->getFaceT2)(*(int*)arg[0]));
  else   (((const ::TDetector*)o)->getFaceT2)(*(int*)arg[0]);
}

static  void method_5471( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::TDetector*)o)->getDetectorNormal)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getDetectorNormal)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5472( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::TDetector*)o)->getDetectorT1)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getDetectorT1)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5473( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::TDetector*)o)->getDetectorT2)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::TDetector*)o)->getDetectorT2)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5474( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TDetector*)o)->init)();
}

static  void method_5475( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::TDetector*)o)->PrintPixels)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::TDetector*)o)->PrintPixels)((::Option_t*)arg[0]);
  }
}

static  void method_5476( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::TDetector*)o)->Print)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::TDetector*)o)->Print)((::Option_t*)arg[0]);
  }
}

static  void method_5477( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDetector*)o)->Class)());
  else   (((::TDetector*)o)->Class)();
}

static  void method_5478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDetector*)o)->Class_Name)());
  else   (((::TDetector*)o)->Class_Name)();
}

static  void method_5479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TDetector*)o)->Class_Version)());
  else   (((::TDetector*)o)->Class_Version)();
}

static  void method_5480( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TDetector*)o)->Dictionary)();
}

static  void method_5481( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TDetector*)o)->IsA)());
  else   (((const ::TDetector*)o)->IsA)();
}

static  void method_5482( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5483( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5484( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TDetector*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5485( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDetector*)o)->DeclFileName)());
  else   (((::TDetector*)o)->DeclFileName)();
}

static  void method_5486( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDetector*)o)->ImplFileLine)());
  else   (((::TDetector*)o)->ImplFileLine)();
}

static  void method_5487( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TDetector*)o)->ImplFileName)());
  else   (((::TDetector*)o)->ImplFileName)();
}

static  void method_5488( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TDetector*)o)->DeclFileLine)());
  else   (((::TDetector*)o)->DeclFileLine)();
}

static void constructor_x14( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TDetector();
  else ::new(mem) ::TDetector();
}

static void method_newdel_1875( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TDetector >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TDetector >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TDetector >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TDetector >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TDetector >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TDetector,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TDetector -------------------------------
void __TDetector_db_datamem(Reflex::Class*);
void __TDetector_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TDetector_datamem_bld(&__TDetector_db_datamem);
Reflex::GenreflexMemberBuilder __TDetector_funcmem_bld(&__TDetector_db_funcmem);
void __TDetector_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TDetector"), typeid(::TDetector), sizeof(::TDetector), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TDetector::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1879, ::Reflex::BaseOffset< ::TDetector, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10909, type_10910), Reflex::Literal("operator="), operator_5410, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10910), Reflex::Literal("TDetector"), constructor_5411, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2417), Reflex::Literal("TDetector"), constructor_5412, 0, "fname=\"\"", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TDetector"), destructor_5413, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TDetector"), constructor_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1875, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TDetector_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TDetector_funcmem_bld);
}

//------Delayed data member builder for class TDetector -------------------
void __TDetector_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_195, Reflex::Literal("LY"), OffsetOf(__shadow__::__TDetector, LY), ::Reflex::PRIVATE)
  .AddDataMember(type_195, Reflex::Literal("fastScintTime"), OffsetOf(__shadow__::__TDetector, fastScintTime), ::Reflex::PRIVATE)
  .AddDataMember(type_195, Reflex::Literal("rIndex"), OffsetOf(__shadow__::__TDetector, rIndex), ::Reflex::PRIVATE)
  .AddDataMember(type_195, Reflex::Literal("scintSizeX"), OffsetOf(__shadow__::__TDetector, scintSizeX), ::Reflex::PRIVATE)
  .AddDataMember(type_195, Reflex::Literal("scintSizeY"), OffsetOf(__shadow__::__TDetector, scintSizeY), ::Reflex::PRIVATE)
  .AddDataMember(type_195, Reflex::Literal("scintSizeZ"), OffsetOf(__shadow__::__TDetector, scintSizeZ), ::Reflex::PRIVATE)
  .AddDataMember(type_10903, Reflex::Literal("Ndet"), OffsetOf(__shadow__::__TDetector, Ndet), ::Reflex::PRIVATE)
  .AddDataMember(type_10904, Reflex::Literal("detPresent"), OffsetOf(__shadow__::__TDetector, detPresent), ::Reflex::PRIVATE)
  .AddDataMember(type_10905, Reflex::Literal("detName"), OffsetOf(__shadow__::__TDetector, detName), ::Reflex::PRIVATE)
  .AddDataMember(type_10906, Reflex::Literal("detSizeX"), OffsetOf(__shadow__::__TDetector, detSizeX), ::Reflex::PRIVATE)
  .AddDataMember(type_10906, Reflex::Literal("detSizeY"), OffsetOf(__shadow__::__TDetector, detSizeY), ::Reflex::PRIVATE)
  .AddDataMember(type_10906, Reflex::Literal("detPixelSizeX"), OffsetOf(__shadow__::__TDetector, detPixelSizeX), ::Reflex::PRIVATE)
  .AddDataMember(type_10906, Reflex::Literal("detPixelSizeY"), OffsetOf(__shadow__::__TDetector, detPixelSizeY), ::Reflex::PRIVATE)
  .AddDataMember(type_10904, Reflex::Literal("detNpixelsX"), OffsetOf(__shadow__::__TDetector, detNpixelsX), ::Reflex::PRIVATE)
  .AddDataMember(type_10904, Reflex::Literal("detNpixelsY"), OffsetOf(__shadow__::__TDetector, detNpixelsY), ::Reflex::PRIVATE)
  .AddDataMember(type_10906, Reflex::Literal("detQE"), OffsetOf(__shadow__::__TDetector, detQE), ::Reflex::PRIVATE)
  .AddDataMember(type_10906, Reflex::Literal("detReflectivity"), OffsetOf(__shadow__::__TDetector, detReflectivity), ::Reflex::PRIVATE)
  .AddDataMember(type_10906, Reflex::Literal("detTimeRes"), OffsetOf(__shadow__::__TDetector, detTimeRes), ::Reflex::PRIVATE)
  .AddDataMember(type_10904, Reflex::Literal("detPlacementAlt"), OffsetOf(__shadow__::__TDetector, detPlacementAlt), ::Reflex::PRIVATE)
  .AddDataMember(type_10906, Reflex::Literal("detCenterX"), OffsetOf(__shadow__::__TDetector, detCenterX), ::Reflex::PRIVATE)
  .AddDataMember(type_10906, Reflex::Literal("detCenterY"), OffsetOf(__shadow__::__TDetector, detCenterY), ::Reflex::PRIVATE)
  .AddDataMember(type_10906, Reflex::Literal("detRotation"), OffsetOf(__shadow__::__TDetector, detRotation), ::Reflex::PRIVATE)
  .AddDataMember(type_10906, Reflex::Literal("detCouplingRIndex"), OffsetOf(__shadow__::__TDetector, detCouplingRIndex), ::Reflex::PRIVATE)
  .AddDataMember(type_10906, Reflex::Literal("detCouplingThickness"), OffsetOf(__shadow__::__TDetector, detCouplingThickness), ::Reflex::PRIVATE)
  .AddDataMember(type_10907, Reflex::Literal("faceReflectivity"), OffsetOf(__shadow__::__TDetector, faceReflectivity), ::Reflex::PRIVATE)
  .AddDataMember(type_10908, Reflex::Literal("posPixelX"), OffsetOf(__shadow__::__TDetector, posPixelX), ::Reflex::PRIVATE)
  .AddDataMember(type_10908, Reflex::Literal("posPixelY"), OffsetOf(__shadow__::__TDetector, posPixelY), ::Reflex::PRIVATE)
  .AddDataMember(type_10908, Reflex::Literal("posPixelZ"), OffsetOf(__shadow__::__TDetector, posPixelZ), ::Reflex::PRIVATE)
  .AddDataMember(type_2417, Reflex::Literal("m_name"), OffsetOf(__shadow__::__TDetector, m_name), ::Reflex::PRIVATE)
  .AddDataMember(type_117, Reflex::Literal("m_totPixels"), OffsetOf(__shadow__::__TDetector, m_totPixels), ::Reflex::PRIVATE)
  .AddDataMember(type_117, Reflex::Literal("m_totDetectors"), OffsetOf(__shadow__::__TDetector, m_totDetectors), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TDetector -------------------
void __TDetector_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_195), Reflex::Literal("setScintSizeX"), method_5414, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_195), Reflex::Literal("setScintSizeY"), method_5415, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_195), Reflex::Literal("setScintSizeZ"), method_5416, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195), Reflex::Literal("getScintSizeX"), method_5417, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195), Reflex::Literal("getScintSizeY"), method_5418, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195), Reflex::Literal("getScintSizeZ"), method_5419, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_195), Reflex::Literal("setLY"), method_5420, 0, "l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195), Reflex::Literal("getLY"), method_5421, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_195), Reflex::Literal("setFastScintTime"), method_5422, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195), Reflex::Literal("getFastScintTime"), method_5423, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195), Reflex::Literal("getRindex"), method_5424, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_195), Reflex::Literal("setRindex"), method_5425, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_117), Reflex::Literal("getFaceReflectivity"), method_5426, 0, "ii", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117, type_195), Reflex::Literal("setFaceReflectivity"), method_5427, 0, "ii;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117, type_117), Reflex::Literal("setNdet"), method_5428, 0, "iface;N", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117, type_117), Reflex::Literal("getNdet"), method_5429, 0, "iface", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117, type_117, type_117), Reflex::Literal("getDetGlobalID"), method_5430, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117, type_10278, type_10278), Reflex::Literal("getFaceDetIDfromGlobal"), method_5431, 0, "global;iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117, type_117, type_117, type_117), Reflex::Literal("getPixelGlobalID"), method_5432, 0, "iface;idetector;ipixel", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117, type_10278, type_10278, type_10278), Reflex::Literal("getFaceDetPixelIDfromGlobal"), method_5433, 0, "global;iface;idetector;ipixel", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("getTotDetectors"), method_5434, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("getTotPixels"), method_5435, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117, type_117, type_195), Reflex::Literal("setDetSizeX"), method_5436, 0, "iface;idetector;s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117, type_117, type_195), Reflex::Literal("setDetSizeY"), method_5437, 0, "iface;idetector;s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_117, type_117), Reflex::Literal("getDetSizeX"), method_5438, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_117, type_117), Reflex::Literal("getDetSizeY"), method_5439, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_117, type_117), Reflex::Literal("getDetCenterX"), method_5440, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_117, type_117), Reflex::Literal("getDetCenterY"), method_5441, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_117, type_117), Reflex::Literal("getDetRotation"), method_5442, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117, type_117, type_117), Reflex::Literal("getDetPlacementAlt"), method_5443, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117, type_117, type_195), Reflex::Literal("setDetCenterX"), method_5444, 0, "iface;idetector;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117, type_117, type_195), Reflex::Literal("setDetCenterY"), method_5445, 0, "iface;idetector;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117, type_117, type_195), Reflex::Literal("setDetRotation"), method_5446, 0, "iface;idetector;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117, type_117, type_2417), Reflex::Literal("setDetName"), method_5447, 0, "iface;idetector;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2417, type_117, type_117), Reflex::Literal("getDetName"), method_5448, 0, "iface;idetector", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117, type_117, type_117), Reflex::Literal("setNPixelsX"), method_5449, 0, "iface;idetector;N", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117, type_117, type_117), Reflex::Literal("setNPixelsY"), method_5450, 0, "iface;idetector;N", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117, type_117, type_117), Reflex::Literal("getNPixelsX"), method_5451, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117, type_117, type_117), Reflex::Literal("getNPixelsY"), method_5452, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117, type_117, type_117), Reflex::Literal("getNPixels"), method_5453, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_117, type_117), Reflex::Literal("getPixelSizeX"), method_5454, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_117, type_117), Reflex::Literal("getPixelSizeY"), method_5455, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_117, type_117), Reflex::Literal("getCouplingThickness"), method_5456, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_117, type_117), Reflex::Literal("getCouplingRIndex"), method_5457, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117, type_117, type_195), Reflex::Literal("setDetTimeRes"), method_5458, 0, "iface;idetector;t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_117, type_117), Reflex::Literal("getDetTimeRes"), method_5459, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_117, type_117), Reflex::Literal("getDetQE"), method_5460, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117, type_117, type_195), Reflex::Literal("setDetQE"), method_5461, 0, "iface;idetector;QE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195, type_117, type_117), Reflex::Literal("getDetReflectivity"), method_5462, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_117, type_117, type_195), Reflex::Literal("setDetReflectivity"), method_5463, 0, "iface;idetector;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117, type_117, type_117), Reflex::Literal("isDetPresent"), method_5464, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_2417), Reflex::Literal("setName"), method_5465, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2417), Reflex::Literal("getName"), method_5466, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1716, type_117, type_117, type_117), Reflex::Literal("getPosPixel"), method_5467, 0, "iface;idetector;ipixel", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1716, type_117), Reflex::Literal("getFaceNormal"), method_5468, 0, "iface", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1716, type_117), Reflex::Literal("getFaceT1"), method_5469, 0, "iface", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1716, type_117), Reflex::Literal("getFaceT2"), method_5470, 0, "iface", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1716, type_117, type_117), Reflex::Literal("getDetectorNormal"), method_5471, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1716, type_117, type_117), Reflex::Literal("getDetectorT1"), method_5472, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1716, type_117, type_117), Reflex::Literal("getDetectorT2"), method_5473, 0, "iface;idetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000), Reflex::Literal("init"), method_5474, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_10090), Reflex::Literal("PrintPixels"), method_5475, 0, "option=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_10090), Reflex::Literal("Print"), method_5476, 0, "option=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_640), Reflex::Literal("Class"), method_5477, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("Class_Name"), method_5478, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2074), Reflex::Literal("Class_Version"), method_5479, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000), Reflex::Literal("Dictionary"), method_5480, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_640), Reflex::Literal("IsA"), method_5481, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_9996), Reflex::Literal("ShowMembers"), method_5482, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_3178), Reflex::Literal("Streamer"), method_5483, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_3178), Reflex::Literal("StreamerNVirtual"), method_5484, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("DeclFileName"), method_5485, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("ImplFileLine"), method_5486, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("ImplFileName"), method_5487, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("DeclFileLine"), method_5488, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TEvent -------------------------------
static  void operator_5963( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TEvent*)o)->operator=)(*(const ::TEvent*)arg[0]);
  else   (((::TEvent*)o)->operator=)(*(const ::TEvent*)arg[0]);
}

static void constructor_5964( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TEvent(*(const ::TEvent*)arg[0]);
  else ::new(mem) ::TEvent(*(const ::TEvent*)arg[0]);
}

static void constructor_5967( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TEvent();
  else ::new(mem) ::TEvent();
}

static void destructor_5968(void*, void * o, const std::vector<void*>&, void *) {
((::TEvent*)o)->::TEvent::~TEvent();
}
static  void method_5969( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::TEvent*)o)->Clear)();
  }
  else if ( arg.size() == 1 ) { 
    (((::TEvent*)o)->Clear)((::Option_t*)arg[0]);
  }
}

static  void method_5970( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TEvent*)o)->clearCollections)();
}

static  void method_5971( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TEvent*)o)->clearObjects)();
}

static  void method_5972( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::TEvent*)o)->printObjects)();
}

static  void method_5973( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEvent*)o)->addObject)((::TObject*)arg[0]);
}

static  void method_5974( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TEvent*)o)->getObject)(*(::std::string*)arg[0]));
  else   (((const ::TEvent*)o)->getObject)(*(::std::string*)arg[0]);
}

static  void method_5975( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TEvent*)o)->hasObject)(*(::std::string*)arg[0]));
  else   (((const ::TEvent*)o)->hasObject)(*(::std::string*)arg[0]);
}

static  void method_5976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TEvent*)o)->getNcollections)());
  else   (((const ::TEvent*)o)->getNcollections)();
}

static  void method_5977( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::TEvent*)o)->printCollections)();
}

static  void method_5978( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::TEvent*)o)->addCollection)((::TClonesArray*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::TEvent*)o)->addCollection)((::TClonesArray*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_5979( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TEvent*)o)->getCollection)((::TClass*)arg[0],
    *(::std::string*)arg[1]));
  else   (((const ::TEvent*)o)->getCollection)((::TClass*)arg[0],
    *(::std::string*)arg[1]);
}

static  void method_5980( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEvent*)o)->deleteCollection)((::TClass*)arg[0],
    *(::std::string*)arg[1]);
}

static  void method_5981( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TEvent*)o)->hasCollection)((::TClonesArray*)arg[0]));
  else   (((const ::TEvent*)o)->hasCollection)((::TClonesArray*)arg[0]);
}

static  void method_5982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TEvent*)o)->hasCollection)((::TClass*)arg[0],
    *(::std::string*)arg[1]));
  else   (((const ::TEvent*)o)->hasCollection)((::TClass*)arg[0],
    *(::std::string*)arg[1]);
}

static  void method_5983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TEvent*)o)->getEventHeader)());
  else   (((const ::TEvent*)o)->getEventHeader)();
}

static  void method_5984( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEvent*)o)->setEventHeader)((::TEventHeader*)arg[0]);
}

static  void method_5985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEvent*)o)->Class)());
  else   (((::TEvent*)o)->Class)();
}

static  void method_5986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEvent*)o)->Class_Name)());
  else   (((::TEvent*)o)->Class_Name)();
}

static  void method_5987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TEvent*)o)->Class_Version)());
  else   (((::TEvent*)o)->Class_Version)();
}

static  void method_5988( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TEvent*)o)->Dictionary)();
}

static  void method_5989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TEvent*)o)->IsA)());
  else   (((const ::TEvent*)o)->IsA)();
}

static  void method_5990( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEvent*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5991( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEvent*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5992( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TEvent*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEvent*)o)->DeclFileName)());
  else   (((::TEvent*)o)->DeclFileName)();
}

static  void method_5994( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TEvent*)o)->ImplFileLine)());
  else   (((::TEvent*)o)->ImplFileLine)();
}

static  void method_5995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TEvent*)o)->ImplFileName)());
  else   (((::TEvent*)o)->ImplFileName)();
}

static  void method_5996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TEvent*)o)->DeclFileLine)());
  else   (((::TEvent*)o)->DeclFileLine)();
}

static void method_newdel_2218( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x18( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TEvent,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TEvent -------------------------------
void __TEvent_db_datamem(Reflex::Class*);
void __TEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TEvent_datamem_bld(&__TEvent_db_datamem);
Reflex::GenreflexMemberBuilder __TEvent_funcmem_bld(&__TEvent_db_funcmem);
void __TEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TEvent"), typeid(::TEvent), sizeof(::TEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TEvent::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1879, ::Reflex::BaseOffset< ::TEvent, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10975, type_10976), Reflex::Literal("operator="), operator_5963, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10976), Reflex::Literal("TEvent"), constructor_5964, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TEvent"), constructor_5967, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TEvent"), destructor_5968, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2218, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x18, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TEvent_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TEvent_funcmem_bld);
}

//------Delayed data member builder for class TEvent -------------------
void __TEvent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10974, Reflex::Literal("m_eventHeader"), OffsetOf(__shadow__::__TEvent, m_eventHeader), ::Reflex::PRIVATE)
  .AddDataMember(type_2013, Reflex::Literal("m_objects"), OffsetOf(__shadow__::__TEvent, m_objects), ::Reflex::PRIVATE)
  .AddDataMember(type_2666, Reflex::Literal("m_collections"), OffsetOf(__shadow__::__TEvent, m_collections), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TEvent -------------------
void __TEvent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_10090), Reflex::Literal("Clear"), method_5969, 0, "option=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000), Reflex::Literal("clearCollections"), method_5970, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000), Reflex::Literal("clearObjects"), method_5971, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000), Reflex::Literal("printObjects"), method_5972, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_9314), Reflex::Literal("addObject"), method_5973, 0, "obj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9314, type_2417), Reflex::Literal("getObject"), method_5974, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117, type_2417), Reflex::Literal("hasObject"), method_5975, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("getNcollections"), method_5976, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000), Reflex::Literal("printCollections"), method_5977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_7968, type_117), Reflex::Literal("addCollection"), method_5978, 0, "coll;checkAlreadyExists=1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7968, type_640, type_2417), Reflex::Literal("getCollection"), method_5979, 0, "theClass;name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_640, type_2417), Reflex::Literal("deleteCollection"), method_5980, 0, "theClass;name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117, type_7968), Reflex::Literal("hasCollection"), method_5981, 0, "coll", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117, type_640, type_2417), Reflex::Literal("hasCollection"), method_5982, 0, "theClass;name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10974), Reflex::Literal("getEventHeader"), method_5983, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_10974), Reflex::Literal("setEventHeader"), method_5984, 0, "eventHeader", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_640), Reflex::Literal("Class"), method_5985, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("Class_Name"), method_5986, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2074), Reflex::Literal("Class_Version"), method_5987, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000), Reflex::Literal("Dictionary"), method_5988, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_640), Reflex::Literal("IsA"), method_5989, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_9996), Reflex::Literal("ShowMembers"), method_5990, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_3178), Reflex::Literal("Streamer"), method_5991, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_3178), Reflex::Literal("StreamerNVirtual"), method_5992, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("DeclFileName"), method_5993, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("ImplFileLine"), method_5994, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("ImplFileName"), method_5995, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("DeclFileLine"), method_5996, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TNamedContainer -------------------------------
static  void operator_6075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TNamedContainer*)o)->operator=)(*(const ::TNamedContainer*)arg[0]);
  else   (((::TNamedContainer*)o)->operator=)(*(const ::TNamedContainer*)arg[0]);
}

static void constructor_6076( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TNamedContainer(*(const ::TNamedContainer*)arg[0]);
  else ::new(mem) ::TNamedContainer(*(const ::TNamedContainer*)arg[0]);
}

static void constructor_6077( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TNamedContainer();
  else ::new(mem) ::TNamedContainer();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TNamedContainer((::TObject*)arg[0]);
  else ::new(mem) ::TNamedContainer((::TObject*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TNamedContainer((::TObject*)arg[0],
      *(::std::string*)arg[1]);
  else ::new(mem) ::TNamedContainer((::TObject*)arg[0],
      *(::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TNamedContainer((::TObject*)arg[0],
      *(::std::string*)arg[1],
      *(::std::string*)arg[2]);
  else ::new(mem) ::TNamedContainer((::TObject*)arg[0],
      *(::std::string*)arg[1],
      *(::std::string*)arg[2]);
  }
}

static void destructor_6078(void*, void * o, const std::vector<void*>&, void *) {
((::TNamedContainer*)o)->::TNamedContainer::~TNamedContainer();
}
static  void method_6079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TNamedContainer*)o)->getObject)());
  else   (((::TNamedContainer*)o)->getObject)();
}

static  void method_6080( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TNamedContainer*)o)->setObject)((::TObject*)arg[0]);
}

static  void method_6081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TNamedContainer*)o)->Class)());
  else   (((::TNamedContainer*)o)->Class)();
}

static  void method_6082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TNamedContainer*)o)->Class_Name)());
  else   (((::TNamedContainer*)o)->Class_Name)();
}

static  void method_6083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TNamedContainer*)o)->Class_Version)());
  else   (((::TNamedContainer*)o)->Class_Version)();
}

static  void method_6084( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TNamedContainer*)o)->Dictionary)();
}

static  void method_6085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TNamedContainer*)o)->IsA)());
  else   (((const ::TNamedContainer*)o)->IsA)();
}

static  void method_6086( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TNamedContainer*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_6087( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TNamedContainer*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_6088( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TNamedContainer*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_6089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TNamedContainer*)o)->DeclFileName)());
  else   (((::TNamedContainer*)o)->DeclFileName)();
}

static  void method_6090( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TNamedContainer*)o)->ImplFileLine)());
  else   (((::TNamedContainer*)o)->ImplFileLine)();
}

static  void method_6091( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TNamedContainer*)o)->ImplFileName)());
  else   (((::TNamedContainer*)o)->ImplFileName)();
}

static  void method_6092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TNamedContainer*)o)->DeclFileLine)());
  else   (((::TNamedContainer*)o)->DeclFileLine)();
}

static void constructor_x19( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TNamedContainer();
  else ::new(mem) ::TNamedContainer();
}

static void method_newdel_2328( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TNamedContainer >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TNamedContainer >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TNamedContainer >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TNamedContainer >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TNamedContainer >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x21( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::TNamedContainer,::TNamed >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TNamedContainer,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TNamedContainer -------------------------------
void __TNamedContainer_db_datamem(Reflex::Class*);
void __TNamedContainer_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TNamedContainer_datamem_bld(&__TNamedContainer_db_datamem);
Reflex::GenreflexMemberBuilder __TNamedContainer_funcmem_bld(&__TNamedContainer_db_funcmem);
void __TNamedContainer_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TNamedContainer"), typeid(::TNamedContainer), sizeof(::TNamedContainer), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TNamedContainer::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2215, ::Reflex::BaseOffset< ::TNamedContainer, ::TNamed >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10983, type_10984), Reflex::Literal("operator="), operator_6075, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10984), Reflex::Literal("TNamedContainer"), constructor_6076, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9314, type_2417, type_2417), Reflex::Literal("TNamedContainer"), constructor_6077, 0, "obj=0;m_name=\"\";m_title=\"\"", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TNamedContainer"), destructor_6078, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TNamedContainer"), constructor_x19, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2328, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x21, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TNamedContainer_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TNamedContainer_funcmem_bld);
}

//------Delayed data member builder for class TNamedContainer -------------------
void __TNamedContainer_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9314, Reflex::Literal("m_object"), OffsetOf(__shadow__::__TNamedContainer, m_object), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TNamedContainer -------------------
void __TNamedContainer_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9314), Reflex::Literal("getObject"), method_6079, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_9314), Reflex::Literal("setObject"), method_6080, 0, "obj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_640), Reflex::Literal("Class"), method_6081, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("Class_Name"), method_6082, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2074), Reflex::Literal("Class_Version"), method_6083, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000), Reflex::Literal("Dictionary"), method_6084, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_640), Reflex::Literal("IsA"), method_6085, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_9996), Reflex::Literal("ShowMembers"), method_6086, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_3178), Reflex::Literal("Streamer"), method_6087, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_3178), Reflex::Literal("StreamerNVirtual"), method_6088, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("DeclFileName"), method_6089, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("ImplFileLine"), method_6090, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2950), Reflex::Literal("ImplFileName"), method_6091, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_117), Reflex::Literal("DeclFileLine"), method_6092, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class map<int,double,std::less<int>,std::allocator<std::pair<const int, double> > > -------------------------------
static void destructor_7525(void*, void * o, const std::vector<void*>&, void *) {
((::std::map<int,double>*)o)->::std::map<int,double>::~map();
}
static void constructor_7526( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,double>();
  else ::new(mem) ::std::map<int,double>();
}

static void constructor_7527( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,double>(*(const ::std::less<int>*)arg[0]);
  else ::new(mem) ::std::map<int,double>(*(const ::std::less<int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,double>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,double> >*)arg[1]);
  else ::new(mem) ::std::map<int,double>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,double> >*)arg[1]);
  }
}

static void constructor_7528( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,double>(*(const ::std::map<int,double>*)arg[0]);
  else ::new(mem) ::std::map<int,double>(*(const ::std::map<int,double>*)arg[0]);
}

static  void operator_7529( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,double>*)o)->operator=)(*(const ::std::map<int,double>*)arg[0]);
  else   (((::std::map<int,double>*)o)->operator=)(*(const ::std::map<int,double>*)arg[0]);
}

static  void method_7530( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,double> >)((((const ::std::map<int,double>*)o)->get_allocator)());
  else   (((const ::std::map<int,double>*)o)->get_allocator)();
}

static  void method_7531( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,double> >)((((::std::map<int,double>*)o)->begin)());
  else   (((::std::map<int,double>*)o)->begin)();
}

static  void method_7532( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,double> >)((((const ::std::map<int,double>*)o)->begin)());
  else   (((const ::std::map<int,double>*)o)->begin)();
}

static  void method_7533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,double> >)((((::std::map<int,double>*)o)->end)());
  else   (((::std::map<int,double>*)o)->end)();
}

static  void method_7534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,double> >)((((const ::std::map<int,double>*)o)->end)());
  else   (((const ::std::map<int,double>*)o)->end)();
}

static  void method_7539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<int,double>*)o)->empty)());
  else   (((const ::std::map<int,double>*)o)->empty)();
}

static  void method_7540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,double>*)o)->size)());
  else   (((const ::std::map<int,double>*)o)->size)();
}

static  void method_7541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,double>*)o)->max_size)());
  else   (((const ::std::map<int,double>*)o)->max_size)();
}

static  void operator_7542( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,double>*)o)->operator[])(*(const int*)arg[0]);
  else   (((::std::map<int,double>*)o)->operator[])(*(const int*)arg[0]);
}

static  void method_7543( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,double>*)o)->at)(*(const int*)arg[0]);
  else   (((::std::map<int,double>*)o)->at)(*(const int*)arg[0]);
}

static  void method_7544( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<int,double>*)o)->at)(*(const int*)arg[0]);
  else   (((const ::std::map<int,double>*)o)->at)(*(const int*)arg[0]);
}

static  void method_7545( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,double> >,bool>)((((::std::map<int,double>*)o)->insert)(*(const ::std::pair<const int,double>*)arg[0]));
  else   (((::std::map<int,double>*)o)->insert)(*(const ::std::pair<const int,double>*)arg[0]);
}

static  void method_7546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,double> >)((((::std::map<int,double>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,double> >*)arg[0],
    *(const ::std::pair<const int,double>*)arg[1]));
  else   (((::std::map<int,double>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,double> >*)arg[0],
    *(const ::std::pair<const int,double>*)arg[1]);
}

static  void method_7547( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,double>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,double> >*)arg[0]);
}

static  void method_7548( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((::std::map<int,double>*)o)->erase)(*(const int*)arg[0]));
  else   (((::std::map<int,double>*)o)->erase)(*(const int*)arg[0]);
}

static  void method_7549( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,double>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,double> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const int,double> >*)arg[1]);
}

static  void method_7550( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,double>*)o)->swap)(*(::std::map<int,double>*)arg[0]);
}

static  void method_7551( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<int,double>*)o)->clear)();
}

static  void method_7552( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<int>)((((const ::std::map<int,double>*)o)->key_comp)());
  else   (((const ::std::map<int,double>*)o)->key_comp)();
}

static  void method_7554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,double> >)((((::std::map<int,double>*)o)->find)(*(const int*)arg[0]));
  else   (((::std::map<int,double>*)o)->find)(*(const int*)arg[0]);
}

static  void method_7555( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,double> >)((((const ::std::map<int,double>*)o)->find)(*(const int*)arg[0]));
  else   (((const ::std::map<int,double>*)o)->find)(*(const int*)arg[0]);
}

static  void method_7556( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::map<int,double>*)o)->count)(*(const int*)arg[0]));
  else   (((const ::std::map<int,double>*)o)->count)(*(const int*)arg[0]);
}

static  void method_7557( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,double> >)((((::std::map<int,double>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,double>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_7558( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,double> >)((((const ::std::map<int,double>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,double>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_7559( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,double> >)((((::std::map<int,double>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,double>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_7560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,double> >)((((const ::std::map<int,double>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,double>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_7561( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,double> >,std::_Rb_tree_iterator<std::pair<const int,double> > >)((((::std::map<int,double>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::std::map<int,double>*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_7562( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const int,double> >,std::_Rb_tree_const_iterator<std::pair<const int,double> > >)((((const ::std::map<int,double>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::std::map<int,double>*)o)->equal_range)(*(const int*)arg[0]);
}

static void method_newdel_2566( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<int,double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<int,double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<int,double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<int,double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<int,double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x23( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<int,double> >::Generate();
  else ::Reflex::Proxy< ::std::map<int,double> >::Generate();
}

//------Dictionary for class map<int,double,std::less<int>,std::allocator<std::pair<const int, double> > > -------------------------------
void __std__map_int_double__db_datamem(Reflex::Class*);
void __std__map_int_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_int_double__datamem_bld(&__std__map_int_double__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_int_double__funcmem_bld(&__std__map_int_double__db_funcmem);
void __std__map_int_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<int,double>"), typeid(::std::map<int,double>), sizeof(::std::map<int,double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_117, Reflex::Literal("std::map<int,double>::key_type"))
  .AddTypedef(type_195, Reflex::Literal("std::map<int,double>::mapped_type"))
  .AddTypedef(type_2670, Reflex::Literal("std::map<int,double>::value_type"))
  .AddTypedef(type_2594, Reflex::Literal("std::map<int,double>::key_compare"))
  .AddTypedef(type_2742, Reflex::Literal("std::map<int,double>::allocator_type"))
  .AddTypedef(type_2670, Reflex::Literal("std::map<int,double>::_Alloc_value_type"))
  .AddTypedef(type_2742, Reflex::Literal("std::map<int,double>::_Pair_alloc_type"))
  .AddTypedef(type_2689, Reflex::Literal("std::map<int,double>::_Rep_type"))
  .AddTypedef(type_7511, Reflex::Literal("std::map<int,double>::pointer"))
  .AddTypedef(type_7513, Reflex::Literal("std::map<int,double>::const_pointer"))
  .AddTypedef(type_7515, Reflex::Literal("std::map<int,double>::reference"))
  .AddTypedef(type_7517, Reflex::Literal("std::map<int,double>::const_reference"))
  .AddTypedef(type_2421, Reflex::Literal("std::map<int,double>::iterator"))
  .AddTypedef(type_2717, Reflex::Literal("std::map<int,double>::const_iterator"))
  .AddTypedef(type_1630, Reflex::Literal("std::map<int,double>::size_type"))
  .AddTypedef(type_615, Reflex::Literal("std::map<int,double>::difference_type"))
  .AddTypedef(type_2806, Reflex::Literal("std::map<int,double>::reverse_iterator"))
  .AddTypedef(type_2805, Reflex::Literal("std::map<int,double>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_7525, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_7526, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11329, type_11330), Reflex::Literal("map"), constructor_7527, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11331), Reflex::Literal("map"), constructor_7528, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2566, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x23, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_int_double__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_int_double__funcmem_bld);
}

//------Delayed data member builder for class map<int,double,std::less<int>,std::allocator<std::pair<const int, double> > > -------------------
void __std__map_int_double__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2689, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_int_double_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<int,double,std::less<int>,std::allocator<std::pair<const int, double> > > -------------------
void __std__map_int_double__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11332, type_11331), Reflex::Literal("operator="), operator_7529, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2742), Reflex::Literal("get_allocator"), method_7530, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2421), Reflex::Literal("begin"), method_7531, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2717), Reflex::Literal("begin"), method_7532, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2421), Reflex::Literal("end"), method_7533, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2717), Reflex::Literal("end"), method_7534, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_529), Reflex::Literal("empty"), method_7539, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630), Reflex::Literal("size"), method_7540, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630), Reflex::Literal("max_size"), method_7541, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8041, type_9401), Reflex::Literal("operator[]"), operator_7542, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8041, type_9401), Reflex::Literal("at"), method_7543, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8043, type_9401), Reflex::Literal("at"), method_7544, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2673, type_7517), Reflex::Literal("insert"), method_7545, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2421, type_2421, type_7517), Reflex::Literal("insert"), method_7546, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_2421), Reflex::Literal("erase"), method_7547, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_9401), Reflex::Literal("erase"), method_7548, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_2421, type_2421), Reflex::Literal("erase"), method_7549, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_11332), Reflex::Literal("swap"), method_7550, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000), Reflex::Literal("clear"), method_7551, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2594), Reflex::Literal("key_comp"), method_7552, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2421, type_9401), Reflex::Literal("find"), method_7554, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2717, type_9401), Reflex::Literal("find"), method_7555, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630, type_9401), Reflex::Literal("count"), method_7556, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2421, type_9401), Reflex::Literal("lower_bound"), method_7557, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2717, type_9401), Reflex::Literal("lower_bound"), method_7558, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2421, type_9401), Reflex::Literal("upper_bound"), method_7559, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2717, type_9401), Reflex::Literal("upper_bound"), method_7560, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2672, type_9401), Reflex::Literal("equal_range"), method_7561, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2671, type_9401), Reflex::Literal("equal_range"), method_7562, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __TXMLHandler_dict(); 
      __TMCTruth_dict(); 
      __TEventHeader_dict(); 
      __TDetectorUtils_dict(); 
      __TMCParticle_dict(); 
      __TRealSetupHandler_dict(); 
      __TDetector_dict(); 
      __TEvent_dict(); 
      __TNamedContainer_dict(); 
      __std__map_int_double__dict(); 
    }
    ~Dictionaries() {
      type_51.Unload(); // class TXMLHandler 
      type_966.Unload(); // class TMCTruth 
      type_1019.Unload(); // class TEventHeader 
      type_1200.Unload(); // class TDetectorUtils 
      type_1445.Unload(); // class TMCParticle 
      type_1489.Unload(); // class TRealSetupHandler 
      type_1875.Unload(); // class TDetector 
      type_2218.Unload(); // class TEvent 
      type_2328.Unload(); // class TNamedContainer 
      type_2566.Unload(); // class std::map<int,double> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
