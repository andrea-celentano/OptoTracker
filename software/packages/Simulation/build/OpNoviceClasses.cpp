// Generated at Wed Nov 16 17:08:53 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/usr/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/usr/bin/c++"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic "
  GCCXML_EXECUTABLE="/usr/bin/gccxml_cc1plus"
  GCCXML_CPP="/usr/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__FLT_MIN__='1.17549435e-38F' -D__CHAR_BIT__='8' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='4.9406564584124654e-324' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__LP64__='1' -D__GNUC_PATCHLEVEL__='7' -D__DEC64_MAX_EXP__='385' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__unix='1' -D__LDBL_MAX_EXP__='16384' -D__linux__='1' -D__SCHAR_MAX__='127' -D__DBL_DIG__='15' -D_FORTIFY_SOURCE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209290e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__SIZEOF_LONG__='8' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='1.7976931348623157e+308' -D__DBL_HAS_INFINITY__='1' -D__DEC32_MIN_EXP__='(-94)' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__DBL_MIN__='2.2250738585072014e-308' -D__FLT_MIN_10_EXP__='(-37)' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__DBL_HAS_DENORM__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.4.7 20120313 (Red Hat 4.4.7-17)"' -D__DEC64_EPSILON__='1E-15DD' -D__DEC128_MIN_EXP__='(-6142)' -Dunix='1' -D__SIZE_TYPE__='long unsigned int' -D__ELF__='1' -D__FLT_RADIX__='2' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__GNUC_RH_RELEASE__='17' -D__k8='1' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__DEC64_MANT_DIG__='16' -D__DEC32_MAX_EXP__='97' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__k8__='1' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__DEC64_MIN_EXP__='(-382)' -D__FLT_DIG__='6' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__FLT_MAX_EXP__='128' -D__DBL_MANT_DIG__='53' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__SSP__='1' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='2.2204460492503131e-16' -D_LP64='1' -D__SIZEOF_WCHAR_T__='4' -D__DEC_EVAL_METHOD__='2' -D__INTMAX_MAX__='9223372036854775807L' -D__FLT_DENORM_MIN__='1.40129846e-45F' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282347e+38F' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='4' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__GNUC_GNU_INLINE__='1' -D_GNU_SOURCE='1' -iwrapper"/usr/share/gccxml-0.9/GCC/4.4" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/backward" -isystem"/usr/local/include" -isystem"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/usr/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.4.7 20120313 (Red Hat 4.4.7-17)
Copyright (C) 2010 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/work/OptoTracker/software/packages/Simulation/include/OpNoviceClasses.hh"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("CLHEP") );
  ::Reflex::Type type_46 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_138 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_329 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_987 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_308 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_394 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_381 = ::Reflex::TypeBuilder(Reflex::Literal("TClass"));
  ::Reflex::Type type_1766 = ::Reflex::TypeBuilder(Reflex::Literal("G4VHit"));
  ::Reflex::Type type_674 = ::Reflex::TypeBuilder(Reflex::Literal("TBuffer"));
  ::Reflex::Type type_495 = ::Reflex::TypeBuilder(Reflex::Literal("G4VDigi"));
  ::Reflex::Type type_1013 = ::Reflex::TypeBuilder(Reflex::Literal("TObject"));
  ::Reflex::Type type_84 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_492 = ::Reflex::TypeBuilder(Reflex::Literal("OpNoviceDigi"));
  ::Reflex::Type type_267 = ::Reflex::TypeBuilder(Reflex::Literal("OpNoviceScintHit"));
  ::Reflex::Type type_130 = ::Reflex::TypeBuilder(Reflex::Literal("TMemberInspector"));
  ::Reflex::Type type_2367 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_1023 = ::Reflex::TypeBuilder(Reflex::Literal("CLHEP::Hep3Vector"));
  ::Reflex::Type type_1358 = ::Reflex::TypeBuilder(Reflex::Literal("G4VPhysicalVolume"));
  ::Reflex::Type type_2142 = ::Reflex::TypeBuilder(Reflex::Literal("CLHEP::HepRotation"));
  ::Reflex::Type type_2857 = ::Reflex::TypeBuilder(Reflex::Literal("CLHEP::HepAxisAngle"));
  ::Reflex::Type type_2368 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_2236 = ::Reflex::TypeBuilder(Reflex::Literal("OpNoviceDetectorHit"));
  ::Reflex::Type type_4698 = ::Reflex::TypeBuilder(Reflex::Literal("CLHEP::HepEulerAngles"));
  ::Reflex::Type type_2388 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_2374 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<G4AttValue>"));
  ::Reflex::Type type_2572 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<G4String,G4AttDef>"));
  ::Reflex::Type type_1853 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("G4double"), type_394);
  ::Reflex::Type type_1024 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("G4ThreeVector"), type_1023);
  ::Reflex::Type type_1358c = ::Reflex::ConstBuilder(type_1358);
  ::Reflex::Type type_9059 = ::Reflex::PointerBuilder(type_1358c);
  ::Reflex::Type type_5952 = ::Reflex::PointerBuilder(type_1358);
  ::Reflex::Type type_267c = ::Reflex::ConstBuilder(type_267);
  ::Reflex::Type type_5277 = ::Reflex::ReferenceBuilder(type_267c);
  ::Reflex::Type type_235 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("G4int"), type_46);
  ::Reflex::Type type_621 = ::Reflex::PointerBuilder(type_138);
  ::Reflex::Type type_1446 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_84);
  ::Reflex::Type type_329c = ::Reflex::ConstBuilder(type_329);
  ::Reflex::Type type_1863 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Option_t"), type_329c);
  ::Reflex::Type type_9060 = ::Reflex::PointerBuilder(type_1863);
  ::Reflex::Type type_2829 = ::Reflex::PointerBuilder(type_329c);
  ::Reflex::Type type_367 = ::Reflex::PointerBuilder(type_381);
  ::Reflex::Type type_1715 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Version_t"), type_308);
  ::Reflex::Type type_9061 = ::Reflex::ReferenceBuilder(type_130);
  ::Reflex::Type type_4912 = ::Reflex::ReferenceBuilder(type_674);
  ::Reflex::Type type_9661 = ::Reflex::ArrayBuilder(type_329, 50);
  ::Reflex::Type type_2401 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2388);
  ::Reflex::Type type_492c = ::Reflex::ConstBuilder(type_492);
  ::Reflex::Type type_5221 = ::Reflex::ReferenceBuilder(type_492c);
  ::Reflex::Type type_9662 = ::Reflex::ReferenceBuilder(type_495);
  ::Reflex::Type type_495c = ::Reflex::ConstBuilder(type_495);
  ::Reflex::Type type_9663 = ::Reflex::ReferenceBuilder(type_495c);
  ::Reflex::Type type_2572c = ::Reflex::ConstBuilder(type_2572);
  ::Reflex::Type type_9664 = ::Reflex::PointerBuilder(type_2572c);
  ::Reflex::Type type_9665 = ::Reflex::PointerBuilder(type_2374);
  ::Reflex::Type type_1023c = ::Reflex::ConstBuilder(type_1023);
  ::Reflex::Type type_9826 = ::Reflex::ReferenceBuilder(type_1023c);
  ::Reflex::Type type_6120 = ::Reflex::ReferenceBuilder(type_394);
  ::Reflex::Type type_9827 = ::Reflex::ReferenceBuilder(type_1023);
  ::Reflex::Type type_2142c = ::Reflex::ConstBuilder(type_2142);
  ::Reflex::Type type_9828 = ::Reflex::ReferenceBuilder(type_2142c);
  ::Reflex::Type type_2857c = ::Reflex::ConstBuilder(type_2857);
  ::Reflex::Type type_9829 = ::Reflex::ReferenceBuilder(type_2857c);
  ::Reflex::Type type_4698c = ::Reflex::ConstBuilder(type_4698);
  ::Reflex::Type type_9830 = ::Reflex::ReferenceBuilder(type_4698c);
  ::Reflex::Type type_10803 = ::Reflex::ReferenceBuilder(type_1766);
  ::Reflex::Type type_1766c = ::Reflex::ConstBuilder(type_1766);
  ::Reflex::Type type_10804 = ::Reflex::ReferenceBuilder(type_1766c);
  ::Reflex::Type type_1093 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("G4bool"), type_987);
  ::Reflex::Type type_2236c = ::Reflex::ConstBuilder(type_2236);
  ::Reflex::Type type_5305 = ::Reflex::ReferenceBuilder(type_2236c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __OpNoviceScintHit
#undef __OpNoviceScintHit
#endif
class __OpNoviceScintHit : public ::TObject, public ::G4VHit {
  public:
  __OpNoviceScintHit();
  virtual ~__OpNoviceScintHit() throw();
  ::G4double fEdep;
  ::G4double fEdepVis;
  ::G4ThreeVector fPos;
  void* fPhysVol;
};
#ifdef __OpNoviceDigi
#undef __OpNoviceDigi
#endif
class __OpNoviceDigi : public ::TObject, public ::G4VDigi {
  public:
  __OpNoviceDigi();
  virtual ~__OpNoviceDigi() throw();
  ::G4int fDetectorNumber;
  ::G4int fPixelNumber;
  ::G4int fFaceNumber;
  char fName[50];
  ::G4int fNPhe;
  ::G4double fFirstHitTime;
  void* fPhysVolMother;
  void* fPhysVol;
};
#ifdef __G4VDigi
#undef __G4VDigi
#endif
class __G4VDigi {
  public:
  __G4VDigi();
  virtual ~__G4VDigi() throw();
};
#ifdef __CLHEP__Hep3Vector
#undef __CLHEP__Hep3Vector
#endif
class __CLHEP__Hep3Vector {
  public:
  __CLHEP__Hep3Vector();
  double dx;
  double dy;
  double dz;
};
#ifdef __G4VHit
#undef __G4VHit
#endif
class __G4VHit {
  public:
  __G4VHit();
  virtual ~__G4VHit() throw();
};
#ifdef __OpNoviceDetectorHit
#undef __OpNoviceDetectorHit
#endif
class __OpNoviceDetectorHit : public ::TObject, public ::G4VHit {
  public:
  __OpNoviceDetectorHit();
  virtual ~__OpNoviceDetectorHit() throw();
  ::G4int fDetectorNumber;
  ::G4int fFaceNumber;
  ::G4int fInFaceNumber;
  ::G4int fNPhe;
  ::G4int fNPixels;
  char fName[50];
  ::std::vector<double> fTime;
  ::std::vector<double> fEnergy;
  ::std::vector<double> fX;
  ::std::vector<double> fY;
  ::std::vector<int> fPixel;
  void* fPhysVolMother;
  void* fPhysVol;
  ::G4bool fDrawit;
  ::G4int fDrawScaleMin;
  ::G4int fDrawScaleMax;
};
}


#endif // __CINT__
namespace {
} // unnamed namespace

#ifndef G__DICTIONARY
# define G__DICTIONARY
#endif
#include "TClass.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "RtypesImp.h"
#include "TIsAProxy.h"
atomic_TClass_ptr OpNoviceScintHit::fgIsA(0);
TClass* ::OpNoviceScintHit::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("OpNoviceScintHit");
   }
   return fgIsA;
}
const char * ::OpNoviceScintHit::Class_Name() {return "OpNoviceScintHit";}
void ::OpNoviceScintHit::Dictionary() {}
const char *::OpNoviceScintHit::ImplFileName() {return "";}
int ::OpNoviceScintHit::ImplFileLine() {return 1;}
void ::OpNoviceScintHit::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::OpNoviceScintHit::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fEdep", &fEdep);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fEdepVis", &fEdepVis);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fPos", &fPos);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*fPhysVol", &fPhysVol);
   TObject::ShowMembers(R__insp);
   R__insp.GenericShowMembers("G4VHit", ( ::G4VHit *)(this), false);
}
void ::OpNoviceScintHit::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::OpNoviceScintHit::Class(),this);
   } else {
      b.WriteClassBuffer(::OpNoviceScintHit::Class(),this);
   }
}

atomic_TClass_ptr OpNoviceDigi::fgIsA(0);
TClass* ::OpNoviceDigi::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("OpNoviceDigi");
   }
   return fgIsA;
}
const char * ::OpNoviceDigi::Class_Name() {return "OpNoviceDigi";}
void ::OpNoviceDigi::Dictionary() {}
const char *::OpNoviceDigi::ImplFileName() {return "";}
int ::OpNoviceDigi::ImplFileLine() {return 1;}
void ::OpNoviceDigi::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::OpNoviceDigi::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fDetectorNumber", &fDetectorNumber);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fPixelNumber", &fPixelNumber);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fFaceNumber", &fFaceNumber);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fName[50]", &fName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fNPhe", &fNPhe);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fFirstHitTime", &fFirstHitTime);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*fPhysVolMother", &fPhysVolMother);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*fPhysVol", &fPhysVol);
   TObject::ShowMembers(R__insp);
   R__insp.GenericShowMembers("G4VDigi", ( ::G4VDigi *)(this), false);
}
void ::OpNoviceDigi::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::OpNoviceDigi::Class(),this);
   } else {
      b.WriteClassBuffer(::OpNoviceDigi::Class(),this);
   }
}

atomic_TClass_ptr OpNoviceDetectorHit::fgIsA(0);
TClass* ::OpNoviceDetectorHit::Class() {
   if (!fgIsA) {
      R__LOCKGUARD2(gCINTMutex);      if (!fgIsA)
         fgIsA = TClass::GetClass("OpNoviceDetectorHit");
   }
   return fgIsA;
}
const char * ::OpNoviceDetectorHit::Class_Name() {return "OpNoviceDetectorHit";}
void ::OpNoviceDetectorHit::Dictionary() {}
const char *::OpNoviceDetectorHit::ImplFileName() {return "";}
int ::OpNoviceDetectorHit::ImplFileLine() {return 1;}
void ::OpNoviceDetectorHit::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::OpNoviceDetectorHit::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fDetectorNumber", &fDetectorNumber);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fFaceNumber", &fFaceNumber);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fInFaceNumber", &fInFaceNumber);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fNPhe", &fNPhe);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fNPixels", &fNPixels);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fName[50]", &fName);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fTime", &fTime);
   R__insp.InspectMember("std::vector<double>", (void*)&fTime, "fTime.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fEnergy", &fEnergy);
   R__insp.InspectMember("std::vector<double>", (void*)&fEnergy, "fEnergy.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fX", &fX);
   R__insp.InspectMember("std::vector<double>", (void*)&fX, "fX.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fY", &fY);
   R__insp.InspectMember("std::vector<double>", (void*)&fY, "fY.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fPixel", &fPixel);
   R__insp.InspectMember("std::vector<int>", (void*)&fPixel, "fPixel.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*fPhysVolMother", &fPhysVolMother);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*fPhysVol", &fPhysVol);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fDrawit", &fDrawit);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fDrawScaleMin", &fDrawScaleMin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fDrawScaleMax", &fDrawScaleMax);
   TObject::ShowMembers(R__insp);
   R__insp.GenericShowMembers("G4VHit", ( ::G4VHit *)(this), false);
}
void ::OpNoviceDetectorHit::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::OpNoviceDetectorHit::Class(),this);
   } else {
      b.WriteClassBuffer(::OpNoviceDetectorHit::Class(),this);
   }
}


namespace {
//------Stub functions for class OpNoviceScintHit -------------------------------
static void constructor_3090( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::OpNoviceScintHit();
  else ::new(mem) ::OpNoviceScintHit();
}

static void constructor_3091( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::OpNoviceScintHit((::G4VPhysicalVolume*)arg[0]);
  else ::new(mem) ::OpNoviceScintHit((::G4VPhysicalVolume*)arg[0]);
}

static void destructor_3092(void*, void * o, const std::vector<void*>&, void *) {
((::OpNoviceScintHit*)o)->::OpNoviceScintHit::~OpNoviceScintHit();
}
static void constructor_3093( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::OpNoviceScintHit(*(const ::OpNoviceScintHit*)arg[0]);
  else ::new(mem) ::OpNoviceScintHit(*(const ::OpNoviceScintHit*)arg[0]);
}

static  void operator_3094( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::OpNoviceScintHit*)o)->operator=)(*(const ::OpNoviceScintHit*)arg[0]);
  else   (((::OpNoviceScintHit*)o)->operator=)(*(const ::OpNoviceScintHit*)arg[0]);
}

static  void operator_3095( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4int)((((const ::OpNoviceScintHit*)o)->operator==)(*(const ::OpNoviceScintHit*)arg[0]));
  else   (((const ::OpNoviceScintHit*)o)->operator==)(*(const ::OpNoviceScintHit*)arg[0]);
}

static  void operator_3096( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceScintHit*)o)->operator new)(*(::size_t*)arg[0]));
  else   (((::OpNoviceScintHit*)o)->operator new)(*(::size_t*)arg[0]);
}

static  void operator_3097( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceScintHit*)o)->operator delete)((void*)arg[0]);
}

static  void method_3098( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNoviceScintHit*)o)->Draw)();
}

static  void method_3099( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNoviceScintHit*)o)->Print)();
}

static  void method_3100( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceScintHit*)o)->SetEdep)(*(::G4double*)arg[0]);
}

static  void method_3101( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceScintHit*)o)->AddEdep)(*(::G4double*)arg[0]);
}

static  void method_3102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4double)((((::OpNoviceScintHit*)o)->GetEdep)());
  else   (((::OpNoviceScintHit*)o)->GetEdep)();
}

static  void method_3103( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceScintHit*)o)->SetEdepVis)(*(::G4double*)arg[0]);
}

static  void method_3104( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceScintHit*)o)->AddEdepVis)(*(::G4double*)arg[0]);
}

static  void method_3105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4double)((((::OpNoviceScintHit*)o)->GetEdepVis)());
  else   (((::OpNoviceScintHit*)o)->GetEdepVis)();
}

static  void method_3106( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceScintHit*)o)->SetPos)(*(::G4ThreeVector*)arg[0]);
}

static  void method_3107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4ThreeVector)((((::OpNoviceScintHit*)o)->GetPos)());
  else   (((::OpNoviceScintHit*)o)->GetPos)();
}

static  void method_3108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceScintHit*)o)->GetPhysV)());
  else   (((::OpNoviceScintHit*)o)->GetPhysV)();
}

static  void method_3109( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::OpNoviceScintHit*)o)->Clear)();
  }
  else if ( arg.size() == 1 ) { 
    (((::OpNoviceScintHit*)o)->Clear)((::Option_t*)arg[0]);
  }
}

static  void method_3110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::OpNoviceScintHit*)o)->GetName)());
  else   (((const ::OpNoviceScintHit*)o)->GetName)();
}

static  void method_3111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceScintHit*)o)->Class)());
  else   (((::OpNoviceScintHit*)o)->Class)();
}

static  void method_3112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceScintHit*)o)->Class_Name)());
  else   (((::OpNoviceScintHit*)o)->Class_Name)();
}

static  void method_3113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::OpNoviceScintHit*)o)->Class_Version)());
  else   (((::OpNoviceScintHit*)o)->Class_Version)();
}

static  void method_3114( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNoviceScintHit*)o)->Dictionary)();
}

static  void method_3115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::OpNoviceScintHit*)o)->IsA)());
  else   (((const ::OpNoviceScintHit*)o)->IsA)();
}

static  void method_3116( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceScintHit*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_3117( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceScintHit*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_3118( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceScintHit*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_3119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceScintHit*)o)->DeclFileName)());
  else   (((::OpNoviceScintHit*)o)->DeclFileName)();
}

static  void method_3120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::OpNoviceScintHit*)o)->ImplFileLine)());
  else   (((::OpNoviceScintHit*)o)->ImplFileLine)();
}

static  void method_3121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceScintHit*)o)->ImplFileName)());
  else   (((::OpNoviceScintHit*)o)->ImplFileName)();
}

static  void method_3122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::OpNoviceScintHit*)o)->DeclFileLine)());
  else   (((::OpNoviceScintHit*)o)->DeclFileLine)();
}

static void method_newdel_267( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::OpNoviceScintHit >::new_np_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::OpNoviceScintHit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::OpNoviceScintHit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::OpNoviceScintHit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::OpNoviceScintHit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::OpNoviceScintHit,::TObject >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("G4VHit")), ::Reflex::BaseOffset< ::OpNoviceScintHit,::G4VHit >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class OpNoviceScintHit -------------------------------
void __OpNoviceScintHit_db_datamem(Reflex::Class*);
void __OpNoviceScintHit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __OpNoviceScintHit_datamem_bld(&__OpNoviceScintHit_db_datamem);
Reflex::GenreflexMemberBuilder __OpNoviceScintHit_funcmem_bld(&__OpNoviceScintHit_db_funcmem);
void __OpNoviceScintHit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("OpNoviceScintHit"), typeid(::OpNoviceScintHit), sizeof(::OpNoviceScintHit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::OpNoviceScintHit::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1013, ::Reflex::BaseOffset< ::OpNoviceScintHit, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddBase(type_1766, ::Reflex::BaseOffset< ::OpNoviceScintHit, ::G4VHit >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("OpNoviceScintHit"), constructor_3090, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5952), Reflex::Literal("OpNoviceScintHit"), constructor_3091, 0, "pVol", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~OpNoviceScintHit"), destructor_3092, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5277), Reflex::Literal("OpNoviceScintHit"), constructor_3093, 0, "right", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_267, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__OpNoviceScintHit_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__OpNoviceScintHit_funcmem_bld);
}

//------Delayed data member builder for class OpNoviceScintHit -------------------
void __OpNoviceScintHit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1853, Reflex::Literal("fEdep"), OffsetOf(__shadow__::__OpNoviceScintHit, fEdep), ::Reflex::PRIVATE)
  .AddDataMember(type_1853, Reflex::Literal("fEdepVis"), OffsetOf(__shadow__::__OpNoviceScintHit, fEdepVis), ::Reflex::PRIVATE)
  .AddDataMember(type_1024, Reflex::Literal("fPos"), OffsetOf(__shadow__::__OpNoviceScintHit, fPos), ::Reflex::PRIVATE)
  .AddDataMember(type_9059, Reflex::Literal("fPhysVol"), OffsetOf(__shadow__::__OpNoviceScintHit, fPhysVol), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class OpNoviceScintHit -------------------
void __OpNoviceScintHit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5277, type_5277), Reflex::Literal("operator="), operator_3094, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235, type_5277), Reflex::Literal("operator=="), operator_3095, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_621, type_1446), Reflex::Literal("operator new"), operator_3096, 0, "", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_621), Reflex::Literal("operator delete"), operator_3097, 0, "aHit", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("Draw"), method_3098, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("Print"), method_3099, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_1853), Reflex::Literal("SetEdep"), method_3100, 0, "de", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_1853), Reflex::Literal("AddEdep"), method_3101, 0, "de", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1853), Reflex::Literal("GetEdep"), method_3102, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_1853), Reflex::Literal("SetEdepVis"), method_3103, 0, "de", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_1853), Reflex::Literal("AddEdepVis"), method_3104, 0, "de", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1853), Reflex::Literal("GetEdepVis"), method_3105, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_1024), Reflex::Literal("SetPos"), method_3106, 0, "xyz", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1024), Reflex::Literal("GetPos"), method_3107, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9059), Reflex::Literal("GetPhysV"), method_3108, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_9060), Reflex::Literal("Clear"), method_3109, 0, "option=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2829), Reflex::Literal("GetName"), method_3110, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_367), Reflex::Literal("Class"), method_3111, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2829), Reflex::Literal("Class_Name"), method_3112, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1715), Reflex::Literal("Class_Version"), method_3113, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("Dictionary"), method_3114, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_367), Reflex::Literal("IsA"), method_3115, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_9061), Reflex::Literal("ShowMembers"), method_3116, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_4912), Reflex::Literal("Streamer"), method_3117, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_4912), Reflex::Literal("StreamerNVirtual"), method_3118, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2829), Reflex::Literal("DeclFileName"), method_3119, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46), Reflex::Literal("ImplFileLine"), method_3120, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2829), Reflex::Literal("ImplFileName"), method_3121, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46), Reflex::Literal("DeclFileLine"), method_3122, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class OpNoviceDigi -------------------------------
static void constructor_3376( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::OpNoviceDigi();
  else ::new(mem) ::OpNoviceDigi();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::OpNoviceDigi(*(::std::string*)arg[0]);
  else ::new(mem) ::OpNoviceDigi(*(::std::string*)arg[0]);
  }
}

static void destructor_3377(void*, void * o, const std::vector<void*>&, void *) {
((::OpNoviceDigi*)o)->::OpNoviceDigi::~OpNoviceDigi();
}
static void constructor_3378( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::OpNoviceDigi(*(const ::OpNoviceDigi*)arg[0]);
  else ::new(mem) ::OpNoviceDigi(*(const ::OpNoviceDigi*)arg[0]);
}

static  void operator_3379( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::OpNoviceDigi*)o)->operator=)(*(const ::OpNoviceDigi*)arg[0]);
  else   (((::OpNoviceDigi*)o)->operator=)(*(const ::OpNoviceDigi*)arg[0]);
}

static  void operator_3380( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::OpNoviceDigi*)o)->operator==)(*(const ::OpNoviceDigi*)arg[0]));
  else   (((const ::OpNoviceDigi*)o)->operator==)(*(const ::OpNoviceDigi*)arg[0]);
}

static  void operator_3381( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDigi*)o)->operator new)(*(::size_t*)arg[0]));
  else   (((::OpNoviceDigi*)o)->operator new)(*(::size_t*)arg[0]);
}

static  void operator_3382( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->operator delete)((void*)arg[0]);
}

static  void method_3383( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNoviceDigi*)o)->Draw)();
}

static  void method_3384( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNoviceDigi*)o)->Print)();
}

static  void method_3385( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetDetectorNumber)(*(::G4int*)arg[0]);
}

static  void method_3386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNoviceDigi*)o)->GetDetectorNumber)());
  else   (((::OpNoviceDigi*)o)->GetDetectorNumber)();
}

static  void method_3387( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetFaceNumber)(*(::G4int*)arg[0]);
}

static  void method_3388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNoviceDigi*)o)->GetFaceNumber)());
  else   (((::OpNoviceDigi*)o)->GetFaceNumber)();
}

static  void method_3389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::OpNoviceDigi*)o)->GetName)());
  else   (((::OpNoviceDigi*)o)->GetName)();
}

static  void method_3390( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetPixelNumber)(*(::G4int*)arg[0]);
}

static  void method_3391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNoviceDigi*)o)->GetPixelNumber)());
  else   (((::OpNoviceDigi*)o)->GetPixelNumber)();
}

static  void method_3392( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetFirstHitTime)(*(::G4double*)arg[0]);
}

static  void method_3393( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4double)((((::OpNoviceDigi*)o)->GetFirstHitTime)());
  else   (((::OpNoviceDigi*)o)->GetFirstHitTime)();
}

static  void method_3394( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetPheCount)(*(::G4int*)arg[0]);
}

static  void method_3395( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNoviceDigi*)o)->IncrementPheCount)();
}

static  void method_3396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNoviceDigi*)o)->GetPheCount)());
  else   (((::OpNoviceDigi*)o)->GetPheCount)();
}

static  void method_3397( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetPMTPhysVol)((::G4VPhysicalVolume*)arg[0]);
}

static  void method_3398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDigi*)o)->GetPMTPhysVol)());
  else   (((::OpNoviceDigi*)o)->GetPMTPhysVol)();
}

static  void method_3399( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->SetPMTPhysVolMother)((::G4VPhysicalVolume*)arg[0]);
}

static  void method_3400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDigi*)o)->GetPMTPhysVolMother)());
  else   (((::OpNoviceDigi*)o)->GetPMTPhysVolMother)();
}

static  void method_3401( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::OpNoviceDigi*)o)->Clear)();
  }
  else if ( arg.size() == 1 ) { 
    (((::OpNoviceDigi*)o)->Clear)((::Option_t*)arg[0]);
  }
}

static  void method_3402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::OpNoviceDigi*)o)->GetName)());
  else   (((const ::OpNoviceDigi*)o)->GetName)();
}

static  void method_3403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDigi*)o)->Class)());
  else   (((::OpNoviceDigi*)o)->Class)();
}

static  void method_3404( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDigi*)o)->Class_Name)());
  else   (((::OpNoviceDigi*)o)->Class_Name)();
}

static  void method_3405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::OpNoviceDigi*)o)->Class_Version)());
  else   (((::OpNoviceDigi*)o)->Class_Version)();
}

static  void method_3406( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNoviceDigi*)o)->Dictionary)();
}

static  void method_3407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::OpNoviceDigi*)o)->IsA)());
  else   (((const ::OpNoviceDigi*)o)->IsA)();
}

static  void method_3408( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_3409( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_3410( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDigi*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_3411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDigi*)o)->DeclFileName)());
  else   (((::OpNoviceDigi*)o)->DeclFileName)();
}

static  void method_3412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::OpNoviceDigi*)o)->ImplFileLine)());
  else   (((::OpNoviceDigi*)o)->ImplFileLine)();
}

static  void method_3413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDigi*)o)->ImplFileName)());
  else   (((::OpNoviceDigi*)o)->ImplFileName)();
}

static  void method_3414( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::OpNoviceDigi*)o)->DeclFileLine)());
  else   (((::OpNoviceDigi*)o)->DeclFileLine)();
}

static void constructor_x2( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::OpNoviceDigi();
  else ::new(mem) ::OpNoviceDigi();
}

static void method_newdel_492( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::OpNoviceDigi >::new_np_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::OpNoviceDigi >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::OpNoviceDigi >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::OpNoviceDigi >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::OpNoviceDigi >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::OpNoviceDigi,::TObject >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("G4VDigi")), ::Reflex::BaseOffset< ::OpNoviceDigi,::G4VDigi >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class OpNoviceDigi -------------------------------
void __OpNoviceDigi_db_datamem(Reflex::Class*);
void __OpNoviceDigi_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __OpNoviceDigi_datamem_bld(&__OpNoviceDigi_db_datamem);
Reflex::GenreflexMemberBuilder __OpNoviceDigi_funcmem_bld(&__OpNoviceDigi_db_funcmem);
void __OpNoviceDigi_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("OpNoviceDigi"), typeid(::OpNoviceDigi), sizeof(::OpNoviceDigi), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::OpNoviceDigi::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1013, ::Reflex::BaseOffset< ::OpNoviceDigi, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddBase(type_495, ::Reflex::BaseOffset< ::OpNoviceDigi, ::G4VDigi >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2401), Reflex::Literal("OpNoviceDigi"), constructor_3376, 0, "name=\"OpNoviceDigiDefaultName\"", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~OpNoviceDigi"), destructor_3377, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5221), Reflex::Literal("OpNoviceDigi"), constructor_3378, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("OpNoviceDigi"), constructor_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_492, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__OpNoviceDigi_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__OpNoviceDigi_funcmem_bld);
}

//------Delayed data member builder for class OpNoviceDigi -------------------
void __OpNoviceDigi_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_235, Reflex::Literal("fDetectorNumber"), OffsetOf(__shadow__::__OpNoviceDigi, fDetectorNumber), ::Reflex::PRIVATE)
  .AddDataMember(type_235, Reflex::Literal("fPixelNumber"), OffsetOf(__shadow__::__OpNoviceDigi, fPixelNumber), ::Reflex::PRIVATE)
  .AddDataMember(type_235, Reflex::Literal("fFaceNumber"), OffsetOf(__shadow__::__OpNoviceDigi, fFaceNumber), ::Reflex::PRIVATE)
  .AddDataMember(type_9661, Reflex::Literal("fName"), OffsetOf(__shadow__::__OpNoviceDigi, fName), ::Reflex::PRIVATE)
  .AddDataMember(type_235, Reflex::Literal("fNPhe"), OffsetOf(__shadow__::__OpNoviceDigi, fNPhe), ::Reflex::PRIVATE)
  .AddDataMember(type_1853, Reflex::Literal("fFirstHitTime"), OffsetOf(__shadow__::__OpNoviceDigi, fFirstHitTime), ::Reflex::PRIVATE)
  .AddDataMember(type_5952, Reflex::Literal("fPhysVolMother"), OffsetOf(__shadow__::__OpNoviceDigi, fPhysVolMother), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_5952, Reflex::Literal("fPhysVol"), OffsetOf(__shadow__::__OpNoviceDigi, fPhysVol), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class OpNoviceDigi -------------------
void __OpNoviceDigi_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5221, type_5221), Reflex::Literal("operator="), operator_3379, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_5221), Reflex::Literal("operator=="), operator_3380, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_621, type_1446), Reflex::Literal("operator new"), operator_3381, 0, "", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_621), Reflex::Literal("operator delete"), operator_3382, 0, "aDigi", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("Draw"), method_3383, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("Print"), method_3384, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_235), Reflex::Literal("SetDetectorNumber"), method_3385, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("GetDetectorNumber"), method_3386, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_235), Reflex::Literal("SetFaceNumber"), method_3387, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("GetFaceNumber"), method_3388, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2401), Reflex::Literal("GetName"), method_3389, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_235), Reflex::Literal("SetPixelNumber"), method_3390, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("GetPixelNumber"), method_3391, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_1853), Reflex::Literal("SetFirstHitTime"), method_3392, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1853), Reflex::Literal("GetFirstHitTime"), method_3393, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_235), Reflex::Literal("SetPheCount"), method_3394, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("IncrementPheCount"), method_3395, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("GetPheCount"), method_3396, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_5952), Reflex::Literal("SetPMTPhysVol"), method_3397, 0, "physVol", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5952), Reflex::Literal("GetPMTPhysVol"), method_3398, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_5952), Reflex::Literal("SetPMTPhysVolMother"), method_3399, 0, "physVol", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5952), Reflex::Literal("GetPMTPhysVolMother"), method_3400, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_9060), Reflex::Literal("Clear"), method_3401, 0, "option=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2829), Reflex::Literal("GetName"), method_3402, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_367), Reflex::Literal("Class"), method_3403, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2829), Reflex::Literal("Class_Name"), method_3404, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1715), Reflex::Literal("Class_Version"), method_3405, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("Dictionary"), method_3406, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_367), Reflex::Literal("IsA"), method_3407, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_9061), Reflex::Literal("ShowMembers"), method_3408, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_4912), Reflex::Literal("Streamer"), method_3409, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_4912), Reflex::Literal("StreamerNVirtual"), method_3410, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2829), Reflex::Literal("DeclFileName"), method_3411, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46), Reflex::Literal("ImplFileLine"), method_3412, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2829), Reflex::Literal("ImplFileName"), method_3413, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46), Reflex::Literal("DeclFileLine"), method_3414, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class G4VDigi -------------------------------
static  void operator_3415( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4VDigi*)o)->operator=)(*(const ::G4VDigi*)arg[0]);
  else   (((::G4VDigi*)o)->operator=)(*(const ::G4VDigi*)arg[0]);
}

static void constructor_3416( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4VDigi(*(const ::G4VDigi*)arg[0]);
  else ::new(mem) ::G4VDigi(*(const ::G4VDigi*)arg[0]);
}

static void constructor_3417( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4VDigi();
  else ::new(mem) ::G4VDigi();
}

static void destructor_3418(void*, void * o, const std::vector<void*>&, void *) {
((::G4VDigi*)o)->::G4VDigi::~G4VDigi();
}
static  void operator_3419( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4int)((((const ::G4VDigi*)o)->operator==)(*(const ::G4VDigi*)arg[0]));
  else   (((const ::G4VDigi*)o)->operator==)(*(const ::G4VDigi*)arg[0]);
}

static  void method_3420( void*, void* o, const std::vector<void*>&, void*)
{
  (((::G4VDigi*)o)->Draw)();
}

static  void method_3421( void*, void* o, const std::vector<void*>&, void*)
{
  (((::G4VDigi*)o)->Print)();
}

static  void method_3422( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::G4VDigi*)o)->GetAttDefs)());
  else   (((const ::G4VDigi*)o)->GetAttDefs)();
}

static  void method_3423( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::G4VDigi*)o)->CreateAttValues)());
  else   (((const ::G4VDigi*)o)->CreateAttValues)();
}

static void method_newdel_495( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::G4VDigi >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::G4VDigi >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::G4VDigi >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::G4VDigi >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::G4VDigi >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class G4VDigi -------------------------------
void __G4VDigi_db_datamem(Reflex::Class*);
void __G4VDigi_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __G4VDigi_datamem_bld(&__G4VDigi_db_datamem);
Reflex::GenreflexMemberBuilder __G4VDigi_funcmem_bld(&__G4VDigi_db_funcmem);
void __G4VDigi_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("G4VDigi"), typeid(::G4VDigi), sizeof(::G4VDigi), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9662, type_9663), Reflex::Literal("operator="), operator_3415, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9663), Reflex::Literal("G4VDigi"), constructor_3416, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("G4VDigi"), constructor_3417, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~G4VDigi"), destructor_3418, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_495, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__G4VDigi_funcmem_bld);
}

//------Delayed data member builder for class G4VDigi -------------------
void __G4VDigi_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class G4VDigi -------------------
void __G4VDigi_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235, type_9663), Reflex::Literal("operator=="), operator_3419, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("Draw"), method_3420, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("Print"), method_3421, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("GetAttDefs"), method_3422, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9665), Reflex::Literal("CreateAttValues"), method_3423, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class Hep3Vector -------------------------------
static void constructor_4116( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector();
  else ::new(mem) ::CLHEP::Hep3Vector();
}

static void constructor_4117( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0]);
  else ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0]);
}

static void constructor_4118( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0],
      *(double*)arg[1]);
}

static void constructor_4119( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::CLHEP::Hep3Vector(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
}

static void constructor_4120( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CLHEP::Hep3Vector(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else ::new(mem) ::CLHEP::Hep3Vector(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static void destructor_4121(void*, void * o, const std::vector<void*>&, void *) {
((::CLHEP::Hep3Vector*)o)->::CLHEP::Hep3Vector::~Hep3Vector();
}
static  void operator_4122( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->operator())(*(int*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator())(*(int*)arg[0]);
}

static  void operator_4123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->operator[])(*(int*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator[])(*(int*)arg[0]);
}

static  void operator_4124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator())(*(int*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator())(*(int*)arg[0]);
}

static  void operator_4125( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator[])(*(int*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator[])(*(int*)arg[0]);
}

static  void method_4126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->x)());
  else   (((const ::CLHEP::Hep3Vector*)o)->x)();
}

static  void method_4127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->y)());
  else   (((const ::CLHEP::Hep3Vector*)o)->y)();
}

static  void method_4128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->z)());
  else   (((const ::CLHEP::Hep3Vector*)o)->z)();
}

static  void method_4129( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setX)(*(double*)arg[0]);
}

static  void method_4130( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setY)(*(double*)arg[0]);
}

static  void method_4131( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setZ)(*(double*)arg[0]);
}

static  void method_4132( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->set)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4133( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->phi)());
  else   (((const ::CLHEP::Hep3Vector*)o)->phi)();
}

static  void method_4134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->theta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->theta)();
}

static  void method_4135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->cosTheta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->cosTheta)();
}

static  void method_4136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->cos2Theta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->cos2Theta)();
}

static  void method_4137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->mag2)());
  else   (((const ::CLHEP::Hep3Vector*)o)->mag2)();
}

static  void method_4138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->mag)());
  else   (((const ::CLHEP::Hep3Vector*)o)->mag)();
}

static  void method_4139( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setPhi)(*(double*)arg[0]);
}

static  void method_4140( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setTheta)(*(double*)arg[0]);
}

static  void method_4141( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setMag)(*(double*)arg[0]);
}

static  void method_4142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->perp2)());
  else   (((const ::CLHEP::Hep3Vector*)o)->perp2)();
}

static  void method_4143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->perp)());
  else   (((const ::CLHEP::Hep3Vector*)o)->perp)();
}

static  void method_4144( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setPerp)(*(double*)arg[0]);
}

static  void method_4145( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setCylTheta)(*(double*)arg[0]);
}

static  void method_4146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->perp2)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->perp2)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4147( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->perp)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->perp)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4148( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator==)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator==)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4150( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator!=)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator!=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4151( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isNear)(*(const ::CLHEP::Hep3Vector*)arg[0]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isNear)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isNear)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isNear)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_4152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->howNear)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->howNear)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4153( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->deltaR)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->deltaR)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4154( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator+=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator+=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4155( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator-=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator-=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->operator-)());
  else   (((const ::CLHEP::Hep3Vector*)o)->operator-)();
}

static  void operator_4157( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator*=)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator*=)(*(double*)arg[0]);
}

static  void operator_4158( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator/=)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator/=)(*(double*)arg[0]);
}

static  void method_4159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->unit)());
  else   (((const ::CLHEP::Hep3Vector*)o)->unit)();
}

static  void method_4160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->orthogonal)());
  else   (((const ::CLHEP::Hep3Vector*)o)->orthogonal)();
}

static  void method_4161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->dot)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->dot)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4162( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->cross)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->cross)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4163( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->angle)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->angle)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->pseudoRapidity)());
  else   (((const ::CLHEP::Hep3Vector*)o)->pseudoRapidity)();
}

static  void method_4165( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setEta)(*(double*)arg[0]);
}

static  void method_4166( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setCylEta)(*(double*)arg[0]);
}

static  void method_4167( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotateX)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotateX)(*(double*)arg[0]);
}

static  void method_4168( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotateY)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotateY)(*(double*)arg[0]);
}

static  void method_4169( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotateZ)(*(double*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotateZ)(*(double*)arg[0]);
}

static  void method_4170( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotateUz)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotateUz)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4171( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(double*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(double*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]);
}

static  void operator_4172( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->operator*=)(*(const ::CLHEP::HepRotation*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->operator*=)(*(const ::CLHEP::HepRotation*)arg[0]);
}

static  void method_4173( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->transform)(*(const ::CLHEP::HepRotation*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->transform)(*(const ::CLHEP::HepRotation*)arg[0]);
}

static  void method_4174( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRThetaPhi)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4175( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setREtaPhi)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4176( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRhoPhiZ)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4177( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRhoPhiTheta)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4178( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRhoPhiEta)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_4179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getX)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getX)();
}

static  void method_4180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getY)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getY)();
}

static  void method_4181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getZ)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getZ)();
}

static  void method_4182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getR)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getR)();
}

static  void method_4183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getTheta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getTheta)();
}

static  void method_4184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getPhi)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getPhi)();
}

static  void method_4185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->r)());
  else   (((const ::CLHEP::Hep3Vector*)o)->r)();
}

static  void method_4186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->rho)());
  else   (((const ::CLHEP::Hep3Vector*)o)->rho)();
}

static  void method_4187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getRho)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getRho)();
}

static  void method_4188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->eta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->eta)();
}

static  void method_4189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->getEta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->getEta)();
}

static  void method_4190( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setR)(*(double*)arg[0]);
}

static  void method_4191( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CLHEP::Hep3Vector*)o)->setRho)(*(double*)arg[0]);
}

static  void method_4192( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::CLHEP::Hep3Vector*)o)->compare)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->compare)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4193( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator>)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator>)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4194( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator<)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator<)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4195( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator>=)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator>=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void operator_4196( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->operator<=)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->operator<=)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4197( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->diff2)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->diff2)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4198( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::CLHEP::Hep3Vector*)o)->setTolerance)(*(double*)arg[0]));
  else   (((::CLHEP::Hep3Vector*)o)->setTolerance)(*(double*)arg[0]);
}

static  void method_4199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::CLHEP::Hep3Vector*)o)->getTolerance)());
  else   (((::CLHEP::Hep3Vector*)o)->getTolerance)();
}

static  void method_4200( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isParallel)(*(const ::CLHEP::Hep3Vector*)arg[0]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isParallel)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isParallel)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isParallel)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_4201( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::CLHEP::Hep3Vector*)o)->isOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]));
    else     (((const ::CLHEP::Hep3Vector*)o)->isOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_4202( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->howParallel)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->howParallel)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4203( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->howOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->howOrthogonal)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->beta)());
  else   (((const ::CLHEP::Hep3Vector*)o)->beta)();
}

static  void method_4205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->gamma)());
  else   (((const ::CLHEP::Hep3Vector*)o)->gamma)();
}

static  void method_4206( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->coLinearRapidity)());
  else   (((const ::CLHEP::Hep3Vector*)o)->coLinearRapidity)();
}

static  void method_4207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->angle)());
  else   (((const ::CLHEP::Hep3Vector*)o)->angle)();
}

static  void method_4208( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->theta)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->theta)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4209( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->cosTheta)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->cosTheta)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->cos2Theta)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->cos2Theta)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->project)());
  else   (((const ::CLHEP::Hep3Vector*)o)->project)();
}

static  void method_4212( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->project)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->project)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->perpPart)());
  else   (((const ::CLHEP::Hep3Vector*)o)->perpPart)();
}

static  void method_4214( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (CLHEP::Hep3Vector)((((const ::CLHEP::Hep3Vector*)o)->perpPart)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->perpPart)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->rapidity)());
  else   (((const ::CLHEP::Hep3Vector*)o)->rapidity)();
}

static  void method_4216( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->rapidity)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->rapidity)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4217( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->eta)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->eta)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4218( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->polarAngle)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->polarAngle)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4219( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->deltaPhi)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->deltaPhi)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4220( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->azimAngle)(*(const ::CLHEP::Hep3Vector*)arg[0]));
  else   (((const ::CLHEP::Hep3Vector*)o)->azimAngle)(*(const ::CLHEP::Hep3Vector*)arg[0]);
}

static  void method_4221( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->polarAngle)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]));
  else   (((const ::CLHEP::Hep3Vector*)o)->polarAngle)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]);
}

static  void method_4222( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::CLHEP::Hep3Vector*)o)->azimAngle)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]));
  else   (((const ::CLHEP::Hep3Vector*)o)->azimAngle)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(const ::CLHEP::Hep3Vector*)arg[1]);
}

static  void method_4223( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(double*)arg[1]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::Hep3Vector*)arg[0],
    *(double*)arg[1]);
}

static  void method_4224( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::HepAxisAngle*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::HepAxisAngle*)arg[0]);
}

static  void method_4225( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::HepEulerAngles*)arg[0]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(const ::CLHEP::HepEulerAngles*)arg[0]);
}

static  void method_4226( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CLHEP::Hep3Vector*)o)->rotate)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
  else   (((::CLHEP::Hep3Vector*)o)->rotate)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static void method_newdel_1023( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::CLHEP::Hep3Vector >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Hep3Vector -------------------------------
void __CLHEP__Hep3Vector_db_datamem(Reflex::Class*);
void __CLHEP__Hep3Vector_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __CLHEP__Hep3Vector_datamem_bld(&__CLHEP__Hep3Vector_db_datamem);
Reflex::GenreflexMemberBuilder __CLHEP__Hep3Vector_funcmem_bld(&__CLHEP__Hep3Vector_db_funcmem);
void __CLHEP__Hep3Vector_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("CLHEP::Hep3Vector"), typeid(::CLHEP::Hep3Vector), sizeof(::CLHEP::Hep3Vector), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_88"), Reflex::Literal("X=0;Y=1;Z=2;NUM_COORDINATES=3;SIZE=3"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("_89"), Reflex::Literal("ToleranceTicks=100"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Hep3Vector"), constructor_4116, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_394), Reflex::Literal("Hep3Vector"), constructor_4117, 0, "x1", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_394, type_394), Reflex::Literal("Hep3Vector"), constructor_4118, 0, "x1;y1", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_394, type_394, type_394), Reflex::Literal("Hep3Vector"), constructor_4119, 0, "x1;y1;z1", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9826), Reflex::Literal("Hep3Vector"), constructor_4120, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Hep3Vector"), destructor_4121, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1023, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__CLHEP__Hep3Vector_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__CLHEP__Hep3Vector_funcmem_bld);
}

//------Delayed data member builder for class Hep3Vector -------------------
void __CLHEP__Hep3Vector_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_394, Reflex::Literal("dx"), OffsetOf(__shadow__::__CLHEP__Hep3Vector, dx), ::Reflex::PROTECTED)
  .AddDataMember(type_394, Reflex::Literal("dy"), OffsetOf(__shadow__::__CLHEP__Hep3Vector, dy), ::Reflex::PROTECTED)
  .AddDataMember(type_394, Reflex::Literal("dz"), OffsetOf(__shadow__::__CLHEP__Hep3Vector, dz), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Hep3Vector -------------------
void __CLHEP__Hep3Vector_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_46), Reflex::Literal("operator()"), operator_4122, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_46), Reflex::Literal("operator[]"), operator_4123, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6120, type_46), Reflex::Literal("operator()"), operator_4124, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6120, type_46), Reflex::Literal("operator[]"), operator_4125, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("x"), method_4126, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("y"), method_4127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("z"), method_4128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394), Reflex::Literal("setX"), method_4129, 0, "x1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394), Reflex::Literal("setY"), method_4130, 0, "y1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394), Reflex::Literal("setZ"), method_4131, 0, "z1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394, type_394, type_394), Reflex::Literal("set"), method_4132, 0, "x1;y1;z1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("phi"), method_4133, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("theta"), method_4134, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("cosTheta"), method_4135, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("cos2Theta"), method_4136, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("mag2"), method_4137, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("mag"), method_4138, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394), Reflex::Literal("setPhi"), method_4139, 0, "ph", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394), Reflex::Literal("setTheta"), method_4140, 0, "th", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394), Reflex::Literal("setMag"), method_4141, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("perp2"), method_4142, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("perp"), method_4143, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394), Reflex::Literal("setPerp"), method_4144, 0, "r1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394), Reflex::Literal("setCylTheta"), method_4145, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826), Reflex::Literal("perp2"), method_4146, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826), Reflex::Literal("perp"), method_4147, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9827, type_9826), Reflex::Literal("operator="), operator_4148, 0, "p", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_987, type_9826), Reflex::Literal("operator=="), operator_4149, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_987, type_9826), Reflex::Literal("operator!="), operator_4150, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_987, type_9826, type_394), Reflex::Literal("isNear"), method_4151, 0, ";epsilon=CLHEP::Hep3Vector::tolerance", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826), Reflex::Literal("howNear"), method_4152, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826), Reflex::Literal("deltaR"), method_4153, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9827, type_9826), Reflex::Literal("operator+="), operator_4154, 0, "p", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9827, type_9826), Reflex::Literal("operator-="), operator_4155, 0, "p", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1023), Reflex::Literal("operator-"), operator_4156, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9827, type_394), Reflex::Literal("operator*="), operator_4157, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9827, type_394), Reflex::Literal("operator/="), operator_4158, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1023), Reflex::Literal("unit"), method_4159, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1023), Reflex::Literal("orthogonal"), method_4160, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826), Reflex::Literal("dot"), method_4161, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1023, type_9826), Reflex::Literal("cross"), method_4162, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826), Reflex::Literal("angle"), method_4163, 0, "q", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("pseudoRapidity"), method_4164, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394), Reflex::Literal("setEta"), method_4165, 0, "p", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394), Reflex::Literal("setCylEta"), method_4166, 0, "p", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9827, type_394), Reflex::Literal("rotateX"), method_4167, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9827, type_394), Reflex::Literal("rotateY"), method_4168, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9827, type_394), Reflex::Literal("rotateZ"), method_4169, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9827, type_9826), Reflex::Literal("rotateUz"), method_4170, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9827, type_394, type_9826), Reflex::Literal("rotate"), method_4171, 0, ";", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9827, type_9828), Reflex::Literal("operator*="), operator_4172, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9827, type_9828), Reflex::Literal("transform"), method_4173, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394, type_394, type_394), Reflex::Literal("setRThetaPhi"), method_4174, 0, "r1;theta1;phi1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394, type_394, type_394), Reflex::Literal("setREtaPhi"), method_4175, 0, "r1;eta1;phi1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394, type_394, type_394), Reflex::Literal("setRhoPhiZ"), method_4176, 0, "rho1;phi1;z1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394, type_394, type_394), Reflex::Literal("setRhoPhiTheta"), method_4177, 0, "rho;phi;theta", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394, type_394, type_394), Reflex::Literal("setRhoPhiEta"), method_4178, 0, "rho;phi;eta", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("getX"), method_4179, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("getY"), method_4180, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("getZ"), method_4181, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("getR"), method_4182, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("getTheta"), method_4183, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("getPhi"), method_4184, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("r"), method_4185, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("rho"), method_4186, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("getRho"), method_4187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("eta"), method_4188, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("getEta"), method_4189, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394), Reflex::Literal("setR"), method_4190, 0, "r1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394), Reflex::Literal("setRho"), method_4191, 0, "rho1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_9826), Reflex::Literal("compare"), method_4192, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_987, type_9826), Reflex::Literal("operator>"), operator_4193, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_987, type_9826), Reflex::Literal("operator<"), operator_4194, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_987, type_9826), Reflex::Literal("operator>="), operator_4195, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_987, type_9826), Reflex::Literal("operator<="), operator_4196, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826), Reflex::Literal("diff2"), method_4197, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_394), Reflex::Literal("setTolerance"), method_4198, 0, "tol", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("getTolerance"), method_4199, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_987, type_9826, type_394), Reflex::Literal("isParallel"), method_4200, 0, "v;epsilon=CLHEP::Hep3Vector::tolerance", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_987, type_9826, type_394), Reflex::Literal("isOrthogonal"), method_4201, 0, "v;epsilon=CLHEP::Hep3Vector::tolerance", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826), Reflex::Literal("howParallel"), method_4202, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826), Reflex::Literal("howOrthogonal"), method_4203, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("beta"), method_4204, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("gamma"), method_4205, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("coLinearRapidity"), method_4206, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("angle"), method_4207, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826), Reflex::Literal("theta"), method_4208, 0, "q", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826), Reflex::Literal("cosTheta"), method_4209, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826), Reflex::Literal("cos2Theta"), method_4210, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1023), Reflex::Literal("project"), method_4211, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1023, type_9826), Reflex::Literal("project"), method_4212, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1023), Reflex::Literal("perpPart"), method_4213, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1023, type_9826), Reflex::Literal("perpPart"), method_4214, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394), Reflex::Literal("rapidity"), method_4215, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826), Reflex::Literal("rapidity"), method_4216, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826), Reflex::Literal("eta"), method_4217, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826), Reflex::Literal("polarAngle"), method_4218, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826), Reflex::Literal("deltaPhi"), method_4219, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826), Reflex::Literal("azimAngle"), method_4220, 0, "v2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826, type_9826), Reflex::Literal("polarAngle"), method_4221, 0, "v2;ref", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_9826, type_9826), Reflex::Literal("azimAngle"), method_4222, 0, "v2;ref", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9827, type_9826, type_394), Reflex::Literal("rotate"), method_4223, 0, "axis;delta", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9827, type_9829), Reflex::Literal("rotate"), method_4224, 0, "ax", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9827, type_9830), Reflex::Literal("rotate"), method_4225, 0, "e", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9827, type_394, type_394, type_394), Reflex::Literal("rotate"), method_4226, 0, "phi;theta;psi", ::Reflex::PUBLIC);
}
//------Stub functions for class G4VHit -------------------------------
static  void operator_4903( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::G4VHit*)o)->operator=)(*(const ::G4VHit*)arg[0]);
  else   (((::G4VHit*)o)->operator=)(*(const ::G4VHit*)arg[0]);
}

static void constructor_4904( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4VHit(*(const ::G4VHit*)arg[0]);
  else ::new(mem) ::G4VHit(*(const ::G4VHit*)arg[0]);
}

static void constructor_4905( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::G4VHit();
  else ::new(mem) ::G4VHit();
}

static void destructor_4906(void*, void * o, const std::vector<void*>&, void *) {
((::G4VHit*)o)->::G4VHit::~G4VHit();
}
static  void operator_4907( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4int)((((const ::G4VHit*)o)->operator==)(*(const ::G4VHit*)arg[0]));
  else   (((const ::G4VHit*)o)->operator==)(*(const ::G4VHit*)arg[0]);
}

static  void method_4908( void*, void* o, const std::vector<void*>&, void*)
{
  (((::G4VHit*)o)->Draw)();
}

static  void method_4909( void*, void* o, const std::vector<void*>&, void*)
{
  (((::G4VHit*)o)->Print)();
}

static  void method_4910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::G4VHit*)o)->GetAttDefs)());
  else   (((const ::G4VHit*)o)->GetAttDefs)();
}

static  void method_4911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::G4VHit*)o)->CreateAttValues)());
  else   (((const ::G4VHit*)o)->CreateAttValues)();
}

static void method_newdel_1766( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::G4VHit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::G4VHit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::G4VHit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::G4VHit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::G4VHit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class G4VHit -------------------------------
void __G4VHit_db_datamem(Reflex::Class*);
void __G4VHit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __G4VHit_datamem_bld(&__G4VHit_db_datamem);
Reflex::GenreflexMemberBuilder __G4VHit_funcmem_bld(&__G4VHit_db_funcmem);
void __G4VHit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("G4VHit"), typeid(::G4VHit), sizeof(::G4VHit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10803, type_10804), Reflex::Literal("operator="), operator_4903, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10804), Reflex::Literal("G4VHit"), constructor_4904, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("G4VHit"), constructor_4905, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~G4VHit"), destructor_4906, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1766, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__G4VHit_funcmem_bld);
}

//------Delayed data member builder for class G4VHit -------------------
void __G4VHit_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class G4VHit -------------------
void __G4VHit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235, type_10804), Reflex::Literal("operator=="), operator_4907, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("Draw"), method_4908, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("Print"), method_4909, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("GetAttDefs"), method_4910, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9665), Reflex::Literal("CreateAttValues"), method_4911, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class OpNoviceDetectorHit -------------------------------
static void constructor_5488( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::OpNoviceDetectorHit();
  else ::new(mem) ::OpNoviceDetectorHit();
}

static void destructor_5489(void*, void * o, const std::vector<void*>&, void *) {
((::OpNoviceDetectorHit*)o)->::OpNoviceDetectorHit::~OpNoviceDetectorHit();
}
static void constructor_5490( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::OpNoviceDetectorHit(*(const ::OpNoviceDetectorHit*)arg[0]);
  else ::new(mem) ::OpNoviceDetectorHit(*(const ::OpNoviceDetectorHit*)arg[0]);
}

static  void operator_5491( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::OpNoviceDetectorHit*)o)->operator=)(*(const ::OpNoviceDetectorHit*)arg[0]);
  else   (((::OpNoviceDetectorHit*)o)->operator=)(*(const ::OpNoviceDetectorHit*)arg[0]);
}

static  void operator_5492( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (G4int)((((const ::OpNoviceDetectorHit*)o)->operator==)(*(const ::OpNoviceDetectorHit*)arg[0]));
  else   (((const ::OpNoviceDetectorHit*)o)->operator==)(*(const ::OpNoviceDetectorHit*)arg[0]);
}

static  void operator_5493( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDetectorHit*)o)->operator new)(*(::size_t*)arg[0]));
  else   (((::OpNoviceDetectorHit*)o)->operator new)(*(::size_t*)arg[0]);
}

static  void operator_5494( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDetectorHit*)o)->operator delete)((void*)arg[0]);
}

static  void method_5495( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNoviceDetectorHit*)o)->Draw)();
}

static  void method_5496( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNoviceDetectorHit*)o)->Print)();
}

static  void method_5497( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDetectorHit*)o)->SetDrawit)(*(::G4bool*)arg[0]);
}

static  void method_5498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4bool)((((::OpNoviceDetectorHit*)o)->GetDrawit)());
  else   (((::OpNoviceDetectorHit*)o)->GetDrawit)();
}

static  void method_5499( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNoviceDetectorHit*)o)->IncrementNPhe)();
}

static  void method_5500( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNoviceDetectorHit*)o)->GetPheCount)());
  else   (((::OpNoviceDetectorHit*)o)->GetPheCount)();
}

static  void method_5501( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDetectorHit*)o)->SetDetectorNumber)(*(::G4int*)arg[0]);
}

static  void method_5502( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNoviceDetectorHit*)o)->GetDetectorNumber)());
  else   (((::OpNoviceDetectorHit*)o)->GetDetectorNumber)();
}

static  void method_5503( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDetectorHit*)o)->SetFaceNumber)(*(::G4int*)arg[0]);
}

static  void method_5504( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNoviceDetectorHit*)o)->GetFaceNumber)());
  else   (((::OpNoviceDetectorHit*)o)->GetFaceNumber)();
}

static  void method_5505( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDetectorHit*)o)->SetInFaceNumber)(*(::G4int*)arg[0]);
}

static  void method_5506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNoviceDetectorHit*)o)->GetInFaceNumber)());
  else   (((::OpNoviceDetectorHit*)o)->GetInFaceNumber)();
}

static  void method_5507( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDetectorHit*)o)->SetNPixels)(*(::G4int*)arg[0]);
}

static  void method_5508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNoviceDetectorHit*)o)->GetNPixels)());
  else   (((::OpNoviceDetectorHit*)o)->GetNPixels)();
}

static  void method_5509( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDetectorHit*)o)->SetHitData)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2],
    *(double*)arg[3],
    *(int*)arg[4]);
}

static  void method_5510( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::OpNoviceDetectorHit*)o)->GetX)(*(int*)arg[0]));
  else   (((::OpNoviceDetectorHit*)o)->GetX)(*(int*)arg[0]);
}

static  void method_5511( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::OpNoviceDetectorHit*)o)->GetY)(*(int*)arg[0]));
  else   (((::OpNoviceDetectorHit*)o)->GetY)(*(int*)arg[0]);
}

static  void method_5512( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::OpNoviceDetectorHit*)o)->GetT)(*(int*)arg[0]));
  else   (((::OpNoviceDetectorHit*)o)->GetT)(*(int*)arg[0]);
}

static  void method_5513( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::OpNoviceDetectorHit*)o)->GetE)(*(int*)arg[0]));
  else   (((::OpNoviceDetectorHit*)o)->GetE)(*(int*)arg[0]);
}

static  void method_5514( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::OpNoviceDetectorHit*)o)->GetPixel)(*(int*)arg[0]));
  else   (((::OpNoviceDetectorHit*)o)->GetPixel)(*(int*)arg[0]);
}

static  void method_5515( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDetectorHit*)o)->SetDetectorPhysVol)((::G4VPhysicalVolume*)arg[0]);
}

static  void method_5516( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDetectorHit*)o)->GetDetectorPhysVol)());
  else   (((::OpNoviceDetectorHit*)o)->GetDetectorPhysVol)();
}

static  void method_5517( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDetectorHit*)o)->SetDetectorPhysVolMother)((::G4VPhysicalVolume*)arg[0]);
}

static  void method_5518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDetectorHit*)o)->GetDetectorPhysVolMother)());
  else   (((::OpNoviceDetectorHit*)o)->GetDetectorPhysVolMother)();
}

static  void method_5519( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDetectorHit*)o)->SetDrawScaleMax)(*(::G4int*)arg[0]);
}

static  void method_5520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNoviceDetectorHit*)o)->GetDrawScaleMax)());
  else   (((::OpNoviceDetectorHit*)o)->GetDrawScaleMax)();
}

static  void method_5521( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDetectorHit*)o)->SetDrawScaleMin)(*(::G4int*)arg[0]);
}

static  void method_5522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (G4int)((((::OpNoviceDetectorHit*)o)->GetDrawScaleMin)());
  else   (((::OpNoviceDetectorHit*)o)->GetDrawScaleMin)();
}

static  void method_5523( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDetectorHit*)o)->SetName)(*(::std::string*)arg[0]);
}

static  void method_5524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::OpNoviceDetectorHit*)o)->GetName)());
  else   (((::OpNoviceDetectorHit*)o)->GetName)();
}

static  void method_5525( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::OpNoviceDetectorHit*)o)->Clear)();
  }
  else if ( arg.size() == 1 ) { 
    (((::OpNoviceDetectorHit*)o)->Clear)((::Option_t*)arg[0]);
  }
}

static  void method_5526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::OpNoviceDetectorHit*)o)->GetName)());
  else   (((const ::OpNoviceDetectorHit*)o)->GetName)();
}

static  void method_5527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDetectorHit*)o)->Class)());
  else   (((::OpNoviceDetectorHit*)o)->Class)();
}

static  void method_5528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDetectorHit*)o)->Class_Name)());
  else   (((::OpNoviceDetectorHit*)o)->Class_Name)();
}

static  void method_5529( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::OpNoviceDetectorHit*)o)->Class_Version)());
  else   (((::OpNoviceDetectorHit*)o)->Class_Version)();
}

static  void method_5530( void*, void* o, const std::vector<void*>&, void*)
{
  (((::OpNoviceDetectorHit*)o)->Dictionary)();
}

static  void method_5531( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::OpNoviceDetectorHit*)o)->IsA)());
  else   (((const ::OpNoviceDetectorHit*)o)->IsA)();
}

static  void method_5532( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDetectorHit*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5533( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDetectorHit*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5534( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::OpNoviceDetectorHit*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDetectorHit*)o)->DeclFileName)());
  else   (((::OpNoviceDetectorHit*)o)->DeclFileName)();
}

static  void method_5536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::OpNoviceDetectorHit*)o)->ImplFileLine)());
  else   (((::OpNoviceDetectorHit*)o)->ImplFileLine)();
}

static  void method_5537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::OpNoviceDetectorHit*)o)->ImplFileName)());
  else   (((::OpNoviceDetectorHit*)o)->ImplFileName)();
}

static  void method_5538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::OpNoviceDetectorHit*)o)->DeclFileLine)());
  else   (((::OpNoviceDetectorHit*)o)->DeclFileLine)();
}

static void method_newdel_2236( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::OpNoviceDetectorHit >::new_np_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::OpNoviceDetectorHit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::OpNoviceDetectorHit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::OpNoviceDetectorHit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::OpNoviceDetectorHit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::OpNoviceDetectorHit,::TObject >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("G4VHit")), ::Reflex::BaseOffset< ::OpNoviceDetectorHit,::G4VHit >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class OpNoviceDetectorHit -------------------------------
void __OpNoviceDetectorHit_db_datamem(Reflex::Class*);
void __OpNoviceDetectorHit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __OpNoviceDetectorHit_datamem_bld(&__OpNoviceDetectorHit_db_datamem);
Reflex::GenreflexMemberBuilder __OpNoviceDetectorHit_funcmem_bld(&__OpNoviceDetectorHit_db_funcmem);
void __OpNoviceDetectorHit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("OpNoviceDetectorHit"), typeid(::OpNoviceDetectorHit), sizeof(::OpNoviceDetectorHit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::OpNoviceDetectorHit::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1013, ::Reflex::BaseOffset< ::OpNoviceDetectorHit, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddBase(type_1766, ::Reflex::BaseOffset< ::OpNoviceDetectorHit, ::G4VHit >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("OpNoviceDetectorHit"), constructor_5488, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~OpNoviceDetectorHit"), destructor_5489, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5305), Reflex::Literal("OpNoviceDetectorHit"), constructor_5490, 0, "right", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2236, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__OpNoviceDetectorHit_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__OpNoviceDetectorHit_funcmem_bld);
}

//------Delayed data member builder for class OpNoviceDetectorHit -------------------
void __OpNoviceDetectorHit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_235, Reflex::Literal("fDetectorNumber"), OffsetOf(__shadow__::__OpNoviceDetectorHit, fDetectorNumber), ::Reflex::PRIVATE)
  .AddDataMember(type_235, Reflex::Literal("fFaceNumber"), OffsetOf(__shadow__::__OpNoviceDetectorHit, fFaceNumber), ::Reflex::PRIVATE)
  .AddDataMember(type_235, Reflex::Literal("fInFaceNumber"), OffsetOf(__shadow__::__OpNoviceDetectorHit, fInFaceNumber), ::Reflex::PRIVATE)
  .AddDataMember(type_235, Reflex::Literal("fNPhe"), OffsetOf(__shadow__::__OpNoviceDetectorHit, fNPhe), ::Reflex::PRIVATE)
  .AddDataMember(type_235, Reflex::Literal("fNPixels"), OffsetOf(__shadow__::__OpNoviceDetectorHit, fNPixels), ::Reflex::PRIVATE)
  .AddDataMember(type_9661, Reflex::Literal("fName"), OffsetOf(__shadow__::__OpNoviceDetectorHit, fName), ::Reflex::PRIVATE)
  .AddDataMember(type_2368, Reflex::Literal("fTime"), OffsetOf(__shadow__::__OpNoviceDetectorHit, fTime), ::Reflex::PRIVATE)
  .AddDataMember(type_2368, Reflex::Literal("fEnergy"), OffsetOf(__shadow__::__OpNoviceDetectorHit, fEnergy), ::Reflex::PRIVATE)
  .AddDataMember(type_2368, Reflex::Literal("fX"), OffsetOf(__shadow__::__OpNoviceDetectorHit, fX), ::Reflex::PRIVATE)
  .AddDataMember(type_2368, Reflex::Literal("fY"), OffsetOf(__shadow__::__OpNoviceDetectorHit, fY), ::Reflex::PRIVATE)
  .AddDataMember(type_2367, Reflex::Literal("fPixel"), OffsetOf(__shadow__::__OpNoviceDetectorHit, fPixel), ::Reflex::PRIVATE)
  .AddDataMember(type_5952, Reflex::Literal("fPhysVolMother"), OffsetOf(__shadow__::__OpNoviceDetectorHit, fPhysVolMother), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_5952, Reflex::Literal("fPhysVol"), OffsetOf(__shadow__::__OpNoviceDetectorHit, fPhysVol), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_1093, Reflex::Literal("fDrawit"), OffsetOf(__shadow__::__OpNoviceDetectorHit, fDrawit), ::Reflex::PRIVATE)
  .AddDataMember(type_235, Reflex::Literal("fDrawScaleMin"), OffsetOf(__shadow__::__OpNoviceDetectorHit, fDrawScaleMin), ::Reflex::PRIVATE)
  .AddDataMember(type_235, Reflex::Literal("fDrawScaleMax"), OffsetOf(__shadow__::__OpNoviceDetectorHit, fDrawScaleMax), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class OpNoviceDetectorHit -------------------
void __OpNoviceDetectorHit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5305, type_5305), Reflex::Literal("operator="), operator_5491, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235, type_5305), Reflex::Literal("operator=="), operator_5492, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_621, type_1446), Reflex::Literal("operator new"), operator_5493, 0, "", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_621), Reflex::Literal("operator delete"), operator_5494, 0, "aHit", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("Draw"), method_5495, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("Print"), method_5496, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_1093), Reflex::Literal("SetDrawit"), method_5497, 0, "b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1093), Reflex::Literal("GetDrawit"), method_5498, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("IncrementNPhe"), method_5499, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("GetPheCount"), method_5500, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_235), Reflex::Literal("SetDetectorNumber"), method_5501, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("GetDetectorNumber"), method_5502, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_235), Reflex::Literal("SetFaceNumber"), method_5503, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("GetFaceNumber"), method_5504, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_235), Reflex::Literal("SetInFaceNumber"), method_5505, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("GetInFaceNumber"), method_5506, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_235), Reflex::Literal("SetNPixels"), method_5507, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("GetNPixels"), method_5508, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_394, type_394, type_394, type_394, type_46), Reflex::Literal("SetHitData"), method_5509, 0, "t;e;x;y;pixel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_46), Reflex::Literal("GetX"), method_5510, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_46), Reflex::Literal("GetY"), method_5511, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_46), Reflex::Literal("GetT"), method_5512, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_394, type_46), Reflex::Literal("GetE"), method_5513, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46, type_46), Reflex::Literal("GetPixel"), method_5514, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_5952), Reflex::Literal("SetDetectorPhysVol"), method_5515, 0, "physVol", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5952), Reflex::Literal("GetDetectorPhysVol"), method_5516, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_5952), Reflex::Literal("SetDetectorPhysVolMother"), method_5517, 0, "physVol", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5952), Reflex::Literal("GetDetectorPhysVolMother"), method_5518, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_235), Reflex::Literal("SetDrawScaleMax"), method_5519, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("GetDrawScaleMax"), method_5520, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_235), Reflex::Literal("SetDrawScaleMin"), method_5521, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("GetDrawScaleMin"), method_5522, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_2401), Reflex::Literal("SetName"), method_5523, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2401), Reflex::Literal("GetName"), method_5524, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_9060), Reflex::Literal("Clear"), method_5525, 0, "option=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2829), Reflex::Literal("GetName"), method_5526, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_367), Reflex::Literal("Class"), method_5527, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2829), Reflex::Literal("Class_Name"), method_5528, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1715), Reflex::Literal("Class_Version"), method_5529, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("Dictionary"), method_5530, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_367), Reflex::Literal("IsA"), method_5531, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_9061), Reflex::Literal("ShowMembers"), method_5532, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_4912), Reflex::Literal("Streamer"), method_5533, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_4912), Reflex::Literal("StreamerNVirtual"), method_5534, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2829), Reflex::Literal("DeclFileName"), method_5535, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46), Reflex::Literal("ImplFileLine"), method_5536, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2829), Reflex::Literal("ImplFileName"), method_5537, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46), Reflex::Literal("DeclFileLine"), method_5538, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __OpNoviceScintHit_dict(); 
      __OpNoviceDigi_dict(); 
      __G4VDigi_dict(); 
      __CLHEP__Hep3Vector_dict(); 
      __G4VHit_dict(); 
      __OpNoviceDetectorHit_dict(); 
    }
    ~Dictionaries() {
      type_267.Unload(); // class OpNoviceScintHit 
      type_492.Unload(); // class OpNoviceDigi 
      type_495.Unload(); // class G4VDigi 
      type_1023.Unload(); // class CLHEP::Hep3Vector 
      type_1766.Unload(); // class G4VHit 
      type_2236.Unload(); // class OpNoviceDetectorHit 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
